{{meta {load_files: [«code/chapter/12_language.js»], zip: «node/html"}}}

# Project: Мова програмування

{{quote {author: «Hal Abelson and Gerald Sussman», title: 

Обчислювач, який визначає значення виразів у мові програмування, - це просто ще одна програма.

quote}}

{{index «Abelson, Hal», «Sussman, Gerald», SICP, «chapter of project»}}

{{figure {url: «img/chapter_picture_12.jpg», alt: «Ілюстрація із зображенням яйця з дірками, всередині якого знаходяться менші яйця, в яких, у свою чергу, є ще менші яйця, і так далі», »chapter: «Обрамлення"}}}.

Створити власну ((мову програмування)) напрочуд легко (якщо не цілитися занадто високо) і дуже пізнавально.

Головне, що я хочу показати у цій главі, це те, що у створенні мови програмування немає ніякої ((магії)). Мені часто здавалося, що деякі людські винаходи були настільки розумними і складними, що я ніколи не зможу їх зрозуміти. Але якщо трохи почитати і поекспериментувати, вони часто виявляються цілком буденними.

{{index «Egg language», [abstraction, «in Egg»]}}

Ми створимо мову програмування під назвою Egg. Це буде крихітна, проста мова - але достатньо потужна, щоб виражати будь-які обчислення, які ви можете собі уявити. Вона дозволить створювати прості ((абстракції)) на основі ((функцій)).

{{id parsing}}

## Синтаксичний аналіз

{{розбір індексів, валідація, [синтаксис, «of Egg»]}}

Найбільш видимою частиною мови програмування є її _синтаксис_, або нотація. Синтаксичний аналізатор - це програма, яка читає фрагмент тексту і створює структуру даних, яка відображає структуру програми, що міститься в цьому тексті. Якщо текст не є правильною програмою, синтаксичний аналізатор повинен вказати на помилку.

{{index «спеціальна форма», [функція, програма]}}

Наша мова матиме простий та уніфікований синтаксис. Все у мові Egg - це ((вираз)). Вираз може бути ім'ям прив'язки, числом, рядком або _програмою_. Додатки використовуються для виклику функцій, а також для таких конструкцій, як `if` або `while`.

{{індекс «символ подвійних лапок», розбір, [екранування, «у рядках»], [пробіли, синтаксис]}}

Щоб спростити роботу синтаксичного аналізатора, рядки у Egg не підтримують нічого подібного до екранування зворотним слешем. Рядок - це просто послідовність символів, які не є подвійними лапками, загорнута у подвійні лапки. Число - це послідовність цифр. Імена зв'язування можуть складатися з будь-яких символів, які не є пробілами і не мають спеціального значення у синтаксисі.

{{індекс «символ коми», [дужки, аргументи]}}

Програми записуються так само, як і у JavaScript, з використанням круглих дужок після виразу та довільної кількості ((аргументів)) між цими дужками, розділених комами.

```{lang: null}
do(define(x, 10),
   if(>(x, 5),
      print(«large»),
      print(«small»)))
```

{{index block, [syntax, «of Egg»]}}

((одноманітність)) мови ((Egg)) означає, що речі, які є ((операторами)) у JavaScript (наприклад, `>`), є звичайними зв'язками у цій мові, які застосовуються так само, як і інші ((функції)). Оскільки синтаксис не має поняття блоку, нам потрібна конструкція `do`, щоб представити виконання декількох дій послідовно.

{{індекс «властивість типу», parsing, [«структура даних», tree]}}

Структура даних, яку синтаксичний аналізатор використовуватиме для опису програми, складається з об'єктів ((вираз)), кожен з яких має властивість `type`, що вказує на тип виразу, та інші властивості для опису його вмісту.

{{ідентифікатор індексу}}

Вирази типу `«значення»` представляють літерні рядки або числа. Їх властивість `value` містить значення рядка або числа, яке вони представляють. Вирази типу ``word`` використовуються для ідентифікаторів (імен). Такі об'єкти мають властивість `name`, яка містить ім'я ідентифікатора у вигляді рядка. Нарешті, вирази типу apply представляють програми. Вони мають властивість `operator`, яка посилається на вираз, що застосовується, а також властивість `args`, яка містить масив виразів-аргументів.

Частину `>(x, 5)` попередньої програми буде представлено таким чином:

```{lang: «json"}
{
  type: «apply»,
  operator: {type: «word», name: “>”},
  args: [
    {type: «word», name: “x”},
    {type: «value», value: 5}
  ]
}
```

{{indexsee «абстрактне дерево синтаксису», «дерево синтаксису», [«структура даних», дерево]}}

Така структура даних називається _((дерево синтаксису))_. Якщо уявити об'єкти у вигляді точок, а зв'язки між ними у вигляді ліній між цими точками, як показано на наступній схемі, то структура матиме вигляд ((дерева))-подібної. Той факт, що вирази містять інші вирази, які, у свою чергу, можуть містити більше виразів, подібний до того, як гілки дерева розгалужуються і знову розгалужуються.

{{figure {url: «img/syntax_tree.svg», alt: «Діаграма, що показує структуру дерева синтаксису для прикладу програми. Корінь позначено як do і він має два дочірні елементи, один з яких позначено як define, а інший - як if. Ті, у свою чергу, мають більше дочірніх елементів, що описують їхній вміст.», width: “5cm”}}}

{{Розбір індексів}}

Порівняйте це з синтаксичним аналізатором, який ми написали для формату конфігураційного файлу у [Глава ?](regexp#ini), який мав просту структуру: він розбивав вхідні дані на рядки і опрацьовував ці рядки по одному. Існувало лише декілька простих форм, які дозволялося приймати рядкам.

{{індексна рекурсія, [вкладеність, «вирази»]}}

Тут ми повинні знайти інший підхід. Вирази не розділено на рядки, і вони мають рекурсивну структуру. Вирази програми _містять_ інші вирази.

{{витонченість індексів}}

На щастя, цю проблему можна вирішити дуже добре, написавши функцію синтаксичного аналізатора, яка є рекурсивною у спосіб, що відображає рекурсивну природу мови.

{{index «parseExpression function», «syntax tree»}}

Визначимо функцію `parseExpression`, яка отримує на вхід рядок. Вона повертає об'єкт, що містить структуру даних для виразу на початку рядка, а також частину рядка, що залишилася після розбору цього виразу. При розборі підвиразів (наприклад, аргументу програми) цю функцію можна викликати повторно, отримавши вираз-аргумент, а також текст, що залишився. Цей текст, у свою чергу, може містити більше аргументів або може бути закриваючою дужкою, яка завершує список аргументів.

Це перша частина синтаксичного аналізатора:

```{includeCode: true}
function parseExpression(program) {
  program = skipSpace(program);
  нехай match, expr;
  if (match = /^«([^»]*)"/.exec(program)) {
    expr = {type: «value», value: match[1]};
  } else if (match = /^\d+\b/.exec(program)) {
    expr = {type: «value», value: Number(match[0])};
  } else if (match = /^[^\s(),#"]+/.exec(program)) {
    expr = {type: «word», name: match[0]};
  } else {
    throw new SyntaxError("Неочікуваний синтаксис: » + program);
  }

  return parseApply(expr, program.slice(match[0].length));
}

function skipSpace(string) {
  let first = string.search(/\S/);
  if (first == -1) return «»;
  return string.slice(first);
}
```

{{index «skipSpace function», [пробіли, синтаксис]}}

Оскільки Egg, як і JavaScript, допускає будь-яку кількість пробілів між своїми елементами, нам доводиться неодноразово відрізати пробіли від початку рядка програми. Функція `skipSpace` допомагає у цьому.

{{index «буквальний вираз», «тип синтаксичної помилки»}}

Після пропуску будь-якого початкового пробілу, `parseExpression` використовує три ((регулярні вирази))и, щоб визначити три атомарні елементи, які підтримує Egg: рядки, числа та слова. Синтаксичний аналізатор створює різну структуру даних залежно від того, який вираз збігається. Якщо вхідні дані не відповідають жодній з цих трьох форм, це не є допустимим виразом, і синтаксичний аналізатор видасть помилку. Тут ми використовуємо конструктор `SyntaxError`. Це клас винятків, визначений стандартом, подібно до `Error`, але більш специфічний.

{{index «parseApply function»}}

Потім ми вирізаємо з рядка програми ту частину, яка була знайдена, і передаємо її разом з об'єктом для виразу до `parseApply`, яка перевіряє, чи вираз є додатком. Якщо так, то він розбирає список аргументів у круглих дужках.

```{includeCode: true}
function parseApply(expr, program) {
  program = skipSpace(program);
  if (program[0] != «(») {
    return {expr: expr, rest: program};
  }

  program = skipSpace(program.slice(1));
  expr = {type: «apply», operator: expr, args: []};
  while (program[0] != «)») {
    let arg = parseExpression(program);
    expr.args.push(arg.expr);
    program = skipSpace(arg.rest);
    if (program[0] == «,») { { program
      program = skipSpace(program.slice(1));
    } else if (program[0] != «)») {
      throw new SyntaxError(«Expected “,” or “)”»);
    }
  }
  return parseApply(expr, program.slice(1));
}
```

{{індексний розбір, рекурсія}}

Якщо наступний символ у програмі не є відкриваючою круглою дужкою, це не додаток, і `parseApply` повертає вираз, який йому було передано. В іншому випадку він пропускає відкриваючу дужку і створює об'єкт ((дерево синтаксису)) для цього прикладного виразу. Потім він рекурсивно викликає `parseExpression` для розбору кожного аргументу, доки не буде знайдено закриваючу дужку. Рекурсія є непрямою, через виклики `parseApply` і `parseExpression` один одного.

Оскільки прикладний вираз може сам застосовуватися (наприклад, у `multiplier(2)(1)`), `parseApply` повинен, після того як він розібрав приклад, викликати себе знову, щоб перевірити, чи не слідує інша пара дужок.

{{index «дерево синтаксису», «мова Egg», «функція розбору»}}

Це все, що нам потрібно для розбору мови Egg. Ми обертаємо його у зручну функцію `parse`, яка перевіряє, чи досягнуто кінця вхідного рядка після розбору виразу (програма на мові Egg - це один вираз), і яка дає нам структуру даних програми.

```{includeCode: strip_log, test: join}
function parse(program) {
  let {expr, rest} = parseExpression(program);
  if (skipSpace(rest).length > 0) {
    throw new SyntaxError(«Неочікуваний текст після програми»);
  }
  return expr;
}

console.log(parse(«+(a, 10)»));
// → {type: «apply»,
// оператор: {type: «word», name: “+”},
// args: [{type: «word», name: “a”},
// {type: «value», value: 10}]}
```

{{index «повідомлення про помилку»}}

Працює! Він не дає нам дуже корисної інформації у випадку помилки і не зберігає рядок і стовпець, з якого починається кожен вираз, що могло б бути корисним при подальшому повідомленні про помилки, але для наших цілей цього цілком достатньо.

## Обчислювач

{{індекс «оцінити функцію», оцінка, інтерпретація, «дерево синтаксису», «яєчна мова»}}

Що ми можемо зробити з деревом синтаксису програми? Звичайно ж, запустити її на виконання! Саме цим і займається оцінювач. Ви даєте йому дерево синтаксису і об'єкт області видимості, який пов'язує імена зі значеннями, і він обчислить вираз, який представляє дерево, і поверне значення, яке це дає.

```{includeCode: true}
const specialForms = Object.create(null);

function evaluate(expr, scope) {
  if (expr.type == «value») {
    повернути expr.value;
  } else if (expr.type == «word») {
    if (expr.name in scope) {
      return scope[ім'я_експресу];
    } else {
      throw new ReferenceError(
        Невизначене зв'язування: ${expr.name}`);
    }
  } else if (expr.type == «apply») {
    let {оператор, аргументи} = expr;
    if (operator.type == «word» &&
        ім'я оператора в specialForms) { {
      return specialForms[ім'я оператора](expr.args, область видимості);
    } else {
      let op = evaluate(operator, scope);
      if (typeof op == «функція») {
        return op(...args.map(arg => evaluate(arg, scope)));
      } else {
        throw new TypeError(«Застосування не функції.»);
      }
    }
  }
}
```

{{index «буквальний вираз», scope}}

Обчислювач має код для кожного з типів ((вираз)). Вираз з буквальним значенням виводить своє значення. (Наприклад, вираз `100` обчислюється до числа 100.) Для зв'язування ми повинні перевірити, чи дійсно воно визначене в області видимості, і якщо так, то отримати значення зв'язування.

{{index [функція, додаток]}}

Додатки є більш складними. Якщо це спеціальна форма, як-от `if`, ми нічого не обчислюємо - ми просто передаємо вираз аргументів разом з областю видимості функції, яка обробляє цю форму. Якщо це звичайний виклик, ми обчислюємо оператор, перевіряємо, що це функція, і викликаємо її з обчисленими аргументами.

Ми використовуємо звичайні значення функцій JavaScript для представлення значень функцій Egg. Ми повернемося до цього [пізніше] (language#egg_fun), коли буде визначено спеціальну форму `fun`.

{{читабельність індексів, «оцінити функцію», рекурсія, синтаксичний аналіз}}

Рекурсивна структура `evaluate` нагадує структуру синтаксичного аналізатора, і обидві відображають структуру самої мови. Можна було б також об'єднати синтаксичний аналізатор і обчислювач в одну функцію і виконувати обчислення під час синтаксичного аналізу, але розділення їх таким чином робить програму зрозумілішою і гнучкішою.

{{index «Egg language», інтерпретація}}

Це дійсно все, що потрібно для інтерпретації мови Egg. Це дуже просто. Але без визначення декількох спеціальних форм та додавання деяких корисних значень до ((оточення)), ви не зможете багато чого зробити з цією мовою.

## Спеціальні форми

{{index «special form», «specialForms object»}}

Об'єкт `specialForms` використовується для визначення спеціального синтаксису в Egg. Він пов'язує слова з функціями, які обчислюють такі форми. Наразі він порожній. Давайте додамо `if`.

```{includeCode: true}
specialForms.if = (args, scope) => {
  if (args.length != 3) {
    throw new SyntaxError(«Неправильна кількість аргументів для if»);
  } else if (evaluate(args[0], scope) !== false) {
    return evaluate(args[1], scope);
  } else {
    return evaluate(args[2], scope);
  }
};
```

{{індекс «умовне виконання», «тернарний оператор», «?: оператор», «умовний оператор»}}

Конструкція `if` в Egg очікує рівно три аргументи. Вона обчислює перший, і якщо результат не є значенням `false`, вона обчислює другий. В іншому випадку обчислюється третій. Ця форма `if` більше схожа на потрійний оператор JavaScript `?:`, ніж на `if`. Це вираз, а не оператор, і він створює значення, а саме результат другого або третього аргументу.

{{index Boolean}}

Egg також відрізняється від JavaScript тим, як вона обробляє значення умови в `if`. Вона вважатиме хибним лише значення `false`, а не нуль або порожній рядок.

{{index «оцінка короткого замикання»}}

Причина, з якої нам потрібно представляти `if` як спеціальну форму, а не як звичайну функцію, полягає у тому, що всі аргументи функцій обчислюються перед викликом функції, тоді як `if` має обчислювати лише _або_ другий, або третій аргумент, залежно від значення першого.

Форма `while` подібна.

```{includeCode: true}
specialForms.while = (args, scope) => {
  if (args.length != 2) {
    throw new SyntaxError(«Неправильна кількість аргументів для while»);
  }
  while (evaluate(args[0], scope) !== false) { {
    evaluate(args[1], scope);
  }

  // Оскільки в Egg не існує undefined, повертаємо false,
  // через відсутність осмисленого результату
  повертаємо false;
};
```

Ще одним базовим будівельним блоком є `do`, який виконує всі свої аргументи зверху вниз. Його значенням є значення, отримане від останнього аргументу.

```{includeCode: true}
specialForms.do = (args, scope) => {
  let value = false;
  for (let arg of args) {
    value = evaluate(arg, scope);
  }
  return value;
};
```

{{index [«= оператор», «in Egg»], [binding, «in Egg»]}}

Щоб мати можливість створювати прив'язки і надавати їм нові значення, ми також створюємо форму, яка називається `define`. Вона очікує, що першим аргументом буде слово, а другим аргументом - вираз, що створює значення, яке слід присвоїти цьому слову. Оскільки `define`, як і все інше, є виразом, вона повинна повертати значення. Ми зробимо так, щоб він повертав значення, яке було присвоєно (подібно до оператора `=` у JavaScript).

```{includeCode: true}
specialForms.define = (args, scope) => {
  if (args.length != 2 || args[0].type != «word») { {} if (args.length != 2 || args[0].type != «word»)
    throw new SyntaxError(«Неправильне використання define»);
  }
  let value = evaluate(args[1], scope);
  scope[args[0].name] = value;
  return value;
};
```

## Оточення

{{index «Egg language», «evaluate function», [binding, «in Egg»]}}

((область видимості)), прийнята функцією `evaluate` - це об'єкт з властивостями, назви яких відповідають назвам зв'язувань, а значення - значенням, до яких ці зв'язування прив'язані. Давайте визначимо об'єкт для представлення ((глобальної області видимості)).

Щоб мати змогу використовувати конструкцію `if`, яку ми щойно визначили, ми повинні мати доступ до значень ((Boolean)). Оскільки існує лише два булевих значення, нам не потрібен спеціальний синтаксис для них. Ми просто прив'язуємо два імені до значень `true` і `false` і використовуємо їх.

```{includeCode: true}
const topScope = Object.create(null);

topScope.true = true
topScope.false = false;
```

Тепер ми можемо обчислити простий вираз, який заперечує булеве значення.

```
нехай prog = parse(`if(true, false, true)`);
console.log(evaluate(prog, topScope));
// → false
```

{{index arithmetic, «Конструктор функцій»}}

Щоб надати базові ((арифметика)) та ((порівняння)) ((оператор)), ми також додамо деякі значення функцій до ((область видимості)). Щоб скоротити код, ми будемо використовувати `Function` для синтезу групи операторних функцій у циклі замість того, щоб визначати їх окремо.

```{includeCode: true}
for (let op of [«+», «-», «*», «/», «==», «<», «>»]) {
  topScope[op] = Function(«a, b», `повертає a ${op} b;`);
}
```

Також корисно мати спосіб ((виведення)) значень, тому ми обернемо `console.log` у функцію і викличемо її `print`.

```{includeCode: true}
topScope.print = value => {
  console.log(value);
  повернути value;
};
```

{{index parsing, «run function»}}

Це дає нам достатньо елементарних інструментів для написання простих програм. Наступна функція надає зручний спосіб розбору програми і запуску її на виконання у свіжій області видимості:

```{includeCode: true}
function run(program) {
  return evaluate(parse(program), Object.create(topScope));
}
```

{{index «Object.create function», prototype}}

Ми будемо використовувати ланцюжки прототипів об'єктів для представлення вкладених областей видимості, щоб програма могла додавати прив'язки до своєї локальної області видимості, не змінюючи область видимості верхнього рівня.

```
run(`
do(define(total, 0),
   define(count, 1),
   while(<(count, 11),
         do(define(total, +(total, count)),
            define(count, +(count, 1)))),
   print(total))
`);
// → 55
```

{{index «summing example», «Egg language»}}

Це програма, яку ми вже бачили кілька разів, яка обчислює суму чисел від 1 до 10, виражену мовою Egg. Вона явно потворніша за еквівалентну програму на JavaScript - але непогана для мови, реалізованої менш ніж за 150 ((рядків коду)).

{{id egg_fun}}

## Функції

{{index function, «Egg language»}}

Мова програмування без функцій - це справді погана мова програмування. На щастя, неважко додати конструкцію `fun`, яка розглядає свій останній аргумент як тіло функції, а всі аргументи до нього використовує як імена параметрів функції.

```{includeCode: true}
specialForms.fun = (args, scope) => {
  if (!args.length) {
    throw new SyntaxError(«Функції потрібне тіло»);
  }
  let body = args[args.length - 1];
  let params = args.slice(0, args.length - 1).map(expr => {
    if (expr.type != «word») {
      throw new SyntaxError(«Імена параметрів повинні бути словами»);
    }
    return expr.name;
  });

  return function(...args) {
    if (args.length != params.length) {
      throw new TypeError(«Неправильна кількість аргументів»);
    }
    let localScope = Object.create(scope);
    for (let i = 0; i < args.length; i++) {
      localScope[params[i]] = args[i];
    }
    return evaluate(body, localScope);
  };
};
```

{{index «local scope»}}

Функції в Egg отримують власну локальну область видимості. Функція, створена формою `fun`, створює цю локальну область видимості і додає до неї прив'язки аргументів. Потім вона обчислює тіло функції у цій області видимості і повертає результат.

```{startCode: true}
run(`
do(define(plusOne, fun(a, +(a, 1))),
   print(plusOne(10))
`);
// → 11

run(`
do(define(pow, fun(base, exp,
     if(==(exp, 0),
        1,
        *(base, pow(base, -(exp, 1)))))),
   print(pow(2, 10)))
`);
// → 1024
```

## Компіляція

{{інтерпретація індексів, компіляція}}

Те, що ми створили, є інтерпретатором. Під час оцінки він діє безпосередньо на представлення програми, отримане синтаксичним аналізатором.

{{індекс ефективності, продуктивності, [зв'язування, визначення], [пам'ять, швидкість]}}

Компіляція - це процес додавання ще одного кроку між синтаксичним аналізом і виконанням програми, який перетворює програму на те, що можна оцінити більш ефективно, виконавши якомога більше роботи заздалегідь. Наприклад, у добре спроектованих мовах для кожного використання зв'язування очевидно, на яке саме зв'язування посилається програма, навіть не запускаючи її на виконання. Це дозволяє уникнути необхідності шукати зв'язування за іменем кожного разу, коли до нього звертаються, натомість безпосередньо отримувати його з деякої наперед визначеної ділянки пам'яті.

Традиційно, ((компіляція)) передбачає перетворення програми у ((машинний код)), необроблений формат, який може виконати процесор комп'ютера. Але будь-який процес, який перетворює програму в інше представлення, можна вважати компіляцією.

{{індекс простоти, «Конструктор функцій», трансполяція}}

Можна було б написати альтернативну стратегію ((оцінки)) для Egg, яка спочатку перетворює програму на програму на JavaScript, використовує `Function` для виклику компілятора JavaScript, а потім запускає результат. Якщо все зроблено правильно, це зробить роботу Egg дуже швидкою, але при цьому досить простою у реалізації.

Якщо вас зацікавила ця тема і ви готові витратити на неї трохи часу, я рекомендую вам спробувати реалізувати такий компілятор у якості вправи.

## Шахрайство

{{index «Egg language»}}

Коли ми визначили `if` і `while`, ви, мабуть, помітили, що вони є більш-менш тривіальними обгортками навколо власних `if` і `while` JavaScript. Аналогічно, значення в Egg - це звичайні старі добрі значення JavaScript. Подолання розриву до більш примітивної системи, такої як машинний код, який розуміє процесор, вимагає більше зусиль - але спосіб, яким він працює, нагадує те, що ми робимо тут.

Хоча іграшкова мова в цій главі не робить нічого такого, що не можна було б зробити краще в JavaScript,  існують ситуації, коли написання маленьких мов допомагає виконати реальну роботу.

Така мова не обов'язково має бути схожою на типову мову програмування. Наприклад, якби в JavaScript не було регулярних виразів, ви могли б написати власний синтаксичний аналізатор та обчислювач регулярних виразів.

{{index «parser generator»}}

Або уявіть, що ви створюєте програму, яка дозволяє швидко створювати синтаксичні аналізатори, надаючи логічний опис мови, яку вони мають аналізувати. Ви можете визначити для цього спеціальну нотацію і компілятор, який скомпілює її у програму синтаксичного аналізатора.

```{lang: null}
expr = number | string | name | application

число = цифра+

ім'я = літера +

string = '«“ (! ”»')* '"'

application = expr '(' (expr (',' expr)*)? ')'
```

{{виразність індексу}}

Це те, що зазвичай називають _((предметно-специфічною мовою))_, мовою, пристосованою для вираження вузької галузі знань. Така мова може бути більш виразною, ніж мова загального призначення, оскільки вона призначена для опису саме тих речей, які потрібно описувати у своїй галузі, і нічого іншого.

## Вправи

### Масиви

{{index «Egg language», «arrays in egg (exercise)», [array, «in Egg»]}}

Додайте підтримку масивів до мови Egg, додавши наступні три функції до верхньої області видимості: `array(...values)` для створення масиву, що містить значення аргументів, `length(array)` для отримання довжини масиву та `element(array, n)` для отримання *n*-гоелементу з масиву.

{{якщо інтерактивний

```{test: no}
// Змініть ці визначення...

topScope.array = «...»;

topScope.length = «...»;

topScope.element = «...»;

run(`
do(define(sum, fun(array,
     do(define(i, 0),
        define(sum, 0),
        while(<(i, length(array)),
          do(define(sum, +(sum, element(array, i))),
             define(i, +(i, 1)))),
        sum))),
   print(sum(array(1, 2, 3))))
`);
// → 6
```

if}}

{{hint

{{index «масиви у яйці (вправа)»}}

Найпростіший спосіб зробити це - представити масиви Egg масивами JavaScript.

{{index «метод зрізу»}}

Значення, що додаються до верхньої області видимості, мають бути функціями. Використовуючи аргумент rest (з нотацією з трьома крапками), визначення `array` може бути  дуже простим.

підказка}}

### Закриття

{{індекс закриття, [функція, область видимості], «закриття у яйці (вправа)»}}

Те, як ми визначили `fun`, дозволяє функціям в Egg посилатися на навколишню область видимості, дозволяючи тілу функції використовувати локальні значення, які були видимі на момент визначення функції, так само, як це роблять функції JavaScript.

Наступна програма ілюструє це: функція `f` повертає функцію, яка додає свій аргумент до аргументу `f`, що означає, що їй потрібен доступ до локальної області видимості всередині `f`, щоб мати змогу використовувати прив'язку `a`.

```
run(`
do(define(f, fun(a, fun(b, +(a, b)))),
   print(f(4)(5)))
`);
// → 9
```

Поверніться до визначення форми `fun` і поясніть, який механізм змушує її працювати.

{{hint

{{index closure, «закриття у яйці (вправа)»}}

Знову ж таки, ми використовуємо механізм JavaScript, щоб отримати еквівалентну функцію в Egg. Спеціальним формам передається локальна область видимості, в якій вони обчислюються, щоб вони могли обчислювати свої підформи у цій області видимості. Функція, яку повертає `fun`, має доступ до аргументу `scope`, переданого її охоплюючій функції, і використовує його для створення локальної області видимості функції під час її виклику.

{{індексна компіляція}}

Це означає, що ((прототипом)) локальної області видимості буде область видимості, у якій було створено функцію, що дає змогу отримати доступ до прив'язок у цій області видимості з функції. Це все, що потрібно для реалізації закриття (хоча для ефективної компіляції вам потрібно буде виконати ще деяку роботу).

підказка}}

### Коментарі

{{index «hash character», «Egg language», «comments in egg (exercise)»}}

Було б добре, якби ми могли писати ((коментар))и мовою Egg. Наприклад, коли ми знаходимо хеш-символ (`#`), ми можемо вважати решту рядка коментарем і ігнорувати його, подібно до `//` у JavaScript.

{{index «skipSpace function»}}

Нам не потрібно вносити значних змін до синтаксичного аналізатора, щоб підтримати цю можливість. Ми можемо просто змінити `skipSpace` так, щоб вона пропускала коментарі так, ніби вони є ((пробілами)), так що у всіх точках, де викликається `skipSpace`, тепер також пропускатимуться коментарі. Зробіть цю зміну.

{{якщо інтерактивно

```{test: no}
// Це старий skipSpace. Змініть його...
function skipSpace(string) {
  let first = string.search(/\S/);
  if (first == -1) return «»;
  return string.slice(first);
}

console.log(parse(«# hello\nx»));
// → {type: «word», name: “x”} }

console.log(parse(«a # one\n # two\n()»));
// → {type: «apply»,
// оператор: {type: «word», name: “a”},
// args: []}
```
if}}

{{hint

{{index «comments in egg (exercise)», [whitespace, syntax]}}

Переконайтеся, що ваш розв'язок обробляє декілька коментарів підряд, між або після яких можуть бути пропуски.

((регулярний вираз)) - це, мабуть, найпростіший спосіб вирішити цю проблему. Напишіть щось, що відповідає «пробіл або коментар, нуль або більше разів». Використовуйте метод `exec` або `match` і подивіться на довжину першого елемента у повернутому масиві (весь вираз), щоб дізнатися, скільки символів потрібно відрізати.

підказка}}

### Фіксація області видимості

{{index [зв'язування, визначення], присвоєння, «фіксування області видимості (вправа)»}}

Наразі єдиним способом присвоїти прив'язці значення є `define`. За допомогою цієї конструкції можна як визначати нові прив'язки, так і надавати нове значення існуючим прив'язкам.

{{index «local binding»}}

Ця ((неоднозначність)) викликає проблему. Коли ви намагаєтеся надати нелокальному зв'язуванню нове значення, ви зрештою визначите локальне зв'язування з тим самим іменем. Деякі мови працюють так за замовчуванням, але я завжди вважав це незручним способом роботи з ((область видимості)).

{{index «ReferenceError type»}}

Додайте спеціальну форму `set`, подібну до `define`, яка надає прив'язці нове значення, оновлюючи прив'язку у зовнішній області видимості, якщо вона ще не існує у внутрішній області. Якщо прив'язка взагалі не визначена, згенерує `ReferenceError` (ще один стандартний тип помилки).

{{index «hasOwn function», prototype, «getPrototypeOf function»}}

Техніка представлення діапазонів як простих об'єктів, яка досі робила речі зручними, на цьому етапі трохи заважатиме вам. Можливо, ви захочете скористатися функцією `Object.getPrototypeOf`, яка повертає прототип об'єкта. Також пам'ятайте, що ви можете використовувати `Object.hasOwn`, щоб дізнатися, чи має даний об'єкт властивість.

{{if інтерактивний

```{test: no}
specialForms.set = (args, scope) => {
  // Ваш код тут.
};

run(`
do(define(x, 4),
   define(setx, fun(val, set(x, val))),
   setx(50),
   print(x))
`);
// → 50
run(`set(quux, true)`);
// → Якась ReferenceError
```
if}}

{{hint

{{index [прив'язка, «компіляція»], присвоєння, «getPrototypeOf функції», «hasOwn function», «фіксація області видимості (вправи)»}}

Вам доведеться циклічно проходити через одну ((область видимості)) за раз, використовуючи `Object.getPrototypeOf` для переходу до наступної зовнішньої області видимості. Для кожної області видимості використовуйте `Object.hasOwn`, щоб з'ясувати, чи існує прив'язка, вказана властивістю `name` першого аргументу в `set`, у цій області видимості. Якщо так, то встановіть його як результат обчислення другого аргументу до `set` і поверніть це значення.

{{index «глобальна область видимості», «помилка часу виконання»}}

Якщо досягнуто граничної області видимості (`Object.getPrototypeOf` повертає `null`), а прив'язки ще не знайдено, то її не існує, і слід згенерувати помилку.

підказка}}
