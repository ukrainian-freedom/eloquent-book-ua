{{meta {load_files: [«code/chapter/06_object.js»], zip: «node/html"}}}

# Таємне життя об'єктів

{{quote {автор: «Barbara Liskov», title: 

Абстрактний тип даних реалізується шляхом написання спеціального виду програми [...], яка визначає тип в термінах операцій, які можна над ним виконувати.

quote}}

{{index «Liskov, Barbara», «abstract data type»}}

{{figure {url: «img/chapter_picture_6.jpg», alt: «Ілюстрація кролика поруч з його прототипом, схематичним зображенням кролика», chapter: framed}}}

[Глава ?](дані) представила об'єкти JavaScript як контейнери, що містять інші дані. У культурі програмування _((об'єктно-орієнтоване програмування))_ - це набір методів, які використовують об'єкти як центральний принцип організації програм. Хоча ніхто не має точного визначення, об'єктно-орієнтоване програмування визначило дизайн багатьох мов програмування, включаючи JavaScript. У цій главі описано, як ці ідеї можна застосувати у JavaScript.

## Абстрактні типи даних

{{index «abstract data type», type, «mixer example»}}

Основна ідея об'єктно-орієнтованого програмування полягає у використанні об'єктів, а точніше _типів_ об'єктів, як одиниці організації програми. Створення програми як низки строго відокремлених типів об'єктів дає змогу думати про її структуру і, таким чином, забезпечувати певну дисципліну, запобігаючи переплутуванню.

Спосіб зробити це - думати про об'єкти приблизно так, як ви думаєте про електричний міксер або інший споживач ((прилад)). Люди, які проектують і збирають змішувач, мають виконувати спеціалізовану роботу, що вимагає матеріалознавства і розуміння електрики. Вони ховають все це в гладку пластикову оболонку, щоб люди, які хочуть лише замісити тісто для млинців, не турбувалися про все це - вони повинні розуміти лише кілька ручок, за допомогою яких можна керувати міксером.

{{index «class»}}

Аналогічно, _абстрактний тип даних_, або _об'єктний клас_, - це підпрограма, яка може містити як завгодно складний код, але розкриває обмежений набір методів і властивостей, які повинні використовувати люди, що працюють з нею. Це дозволяє створювати великі програми з декількох типів пристроїв, обмежуючи ступінь переплетення цих різних частин, вимагаючи, щоб вони взаємодіяли один з одним лише певними способами.

{Інкапсуляція, ізоляція, модульність}}

Якщо проблему виявлено в одному з таких класів об'єктів, його часто можна виправити або навіть повністю переписати, не впливаючи на решту програми. Навіть краще, можна використовувати об'єктні класи в декількох різних програмах, уникаючи необхідності відтворювати їх функціональність з нуля. Ви можете думати про вбудовані структури даних JavaScript, такі як масиви та рядки, як про такі багаторазові абстрактні типи даних.

{{id інтерфейсу}}
{{index [інтерфейс, об'єкт]}}

Кожен абстрактний тип даних має _інтерфейс_- набір операцій, які може виконувати над ним зовнішній код. Будь-які деталі, що виходять за межі цього інтерфейсу,  інкапсулюються, розглядаються як внутрішні дані типу і не мають відношення до решти програми.

Навіть такі базові речі, як числа, можна розглядати як абстрактний тип даних, інтерфейс якого дозволяє їх додавати, множити, порівнювати тощо. Насправді, зацикленість на окремих _об'єктах_ як основній одиниці організації у класичному об'єктно-орієнтованому програмуванні є дещо невдалою, оскільки корисні частини функціональності часто включають групу різних класів об'єктів, що тісно співпрацюють між собою.

{{id obj_methods}}

## Методи

{{index «rabbit example», method, [property, access]}}

У JavaScript методи - це не що інше, як властивості, які зберігають значення функцій. Це простий метод:

```{includeCode: «top_lines:6"}}
function speak(line) {
  console.log(`Кролик ${this.type} говорить '${line}'`);
}
let whiteRabbit = {type: «white», speak};
let hungryRabbit = {type: «hungry», speak};

whiteRabbit.speak(«Oh my fur and whiskers»);
// → Білий кролик каже «Oh my fur and whiskers
hungryRabbit.speak(«Got any carrots?»);
// → Голодний кролик каже: «Є морква?
```

{{index «this binding», «method call»}}

Зазвичай метод повинен щось зробити з об'єктом, на якому його було викликано. Коли функція викликається як метод - шукається як властивість і одразу ж викликається, як у `object.method()`, - прив'язка з назвою `this` у її тілі автоматично вказує на об'єкт, на якому її було викликано.

{{id call_method}}

{{index «метод_виклику»}}

Ви можете думати про `this` як про додатковий ((параметр)), який передається у функцію не так, як звичайні параметри. Якщо ви хочете надати його явно, ви можете використати метод `call` функції, який отримує значення `this` як перший аргумент і обробляє подальші аргументи як звичайні параметри.

```
speak.call(whiteRabbit, «Поспішай»);
// → Білий кролик каже «Поспішай
```

Оскільки кожна функція має власне прив'язування `this`, значення якого залежить від способу її виклику, ви не можете звертатися до `this` області видимості обгортки у звичайній функції, визначеній за допомогою ключового слова `function`.

{{index «this binding», «arrow function»}}

Функції-стрілки відрізняються - вони не зв'язують власне `this`, але можуть бачити зв'язування `this` області видимості навколо себе. Таким чином, ви можете зробити щось на кшталт наступного коду, який посилається на `this` зсередини локальної функції:

```
let finder = {
  find(array) {
    return array.some(v => v == this.value);
  },
  value: 5
};
console.log(finder.find([4, 5]));
// → true
```

Властивість типу `find(array)` в об'єктному виразі є скороченим способом визначення методу. Вона створює властивість з іменем `find` і передає їй функцію як значення.

Якби я записав аргумент до `ome` з використанням ключового слова `function`, цей код не працював би.

{{id prototypes}}

## Прототипи

Одним із способів створити тип об'єкта rabbit з методом `speak` може бути створення допоміжної функції, яка має тип rabbit як параметр і повертає об'єкт, що має цей тип у властивості `type` і нашу функцію speak у властивості `speak`.

Усі кролики використовують один і той самий метод. Особливо для типів з багатьма методами було б добре, якби існував спосіб зберігати методи типу в одному місці, а не додавати їх до кожного об'єкта окремо.

{{індекс [властивість, успадкування], [об'єкт, властивість], «Прототип об'єкта»}}

У JavaScript, _((прототип))s_ - це спосіб зробити це. Об'єкти можуть бути пов'язані з іншими об'єктами, щоб чарівним чином отримати всі властивості, які має інший об'єкт. Старі добрі об'єкти, створені за допомогою нотації `{}`, зв'язуються з об'єктом, який називається `Object.prototype`.

{{index «toString method»}}

```
let empty = {};
console.log(empty.toString);
// → функція toString(){...}
console.log(empty.toString());
// → [об'єкт Object]
```

Виглядає так, ніби ми просто витягли властивість з порожнього об'єкту. Але насправді, `toString` - це метод, що зберігається в `Object.prototype`, тобто він доступний у більшості об'єктів.

Коли об'єкт отримує запит на властивість, якої у нього немає, він шукає цю властивість у своєму прототипі. Якщо його немає, шукається прототип _прототипу_, і так далі, доки не буде знайдено об'єкт без прототипу (`Object.prototype` є таким об'єктом).

```
console.log(Object.getPrototypeOf({}) == Object.prototype);
// → true
console.log(Object.getPrototypeOf(Object.prototype));
// → null
```

{{index «getPrototypeOf функції»}}

Як ви можете здогадатися, `Object.getPrototypeOf` повертає прототип об'єкту.

{{спадкування індексу, «прототип функції», «прототип масиву», «прототип об'єкта»}}

Багато об'єктів не мають безпосередньо `Object.prototype` як свого ((прототипу)), а натомість мають інший об'єкт, який надає інший набір властивостей за замовчуванням. Функції походять від `Function.prototype`, а масиви - від `Array.prototype`.

```
console.log(Object.getPrototypeOf(Math.max) ==
            Function.prototype);
// → true
console.log(Object.getPrototypeOf([]) == Array.prototype);
// → true
```

{{index «Object prototype»}}

Такий об'єкт-прототип сам матиме прототип, найчастіше `Object.prototype`, так що він все одно опосередковано надає методи на кшталт `toString`.

{{index «rabbit example», «Object.create function»}}

Ви можете використовувати `Object.create` для створення об'єкта за певним ((прототипом)).

```{includeCode: «top_lines: 7"}
let protoRabbit = {
  speak(line) {
    console.log(`Кролик ${this.type} говорить '${line}'`);
  }
};
нехай blackRabbit = Object.create(protoRabbit);
blackRabbit.type = «black»;
blackRabbit.speak(«Я - страх і темрява»);
// → Чорний кролик говорить «Я є страх і темрява
```

{{index «shared property»}}

«Прото» кролик діє як контейнер для властивостей, спільних для всіх кроликів. Окремий об'єкт-кролик, наприклад, чорний кролик, містить властивості, які застосовуються лише до нього самого - у цьому випадку до його типу - і отримує спільні властивості від свого прототипу.

{{id classes}}

## Класи

{{index «об'єктно-орієнтоване програмування», «абстрактний тип даних»}}

Систему ((прототип)) JavaScript можна інтерпретувати як дещо вільний погляд на абстрактні типи даних або ((класи)). Клас визначає форму типу об'єкта - які методи та властивості він має. Такий об'єкт називається _((екземпляром))_ класу.

{{індекс [властивість, успадкування]}}

Прототипи корисні для визначення властивостей, які мають однакове значення для всіх екземплярів класу. Властивості, які відрізняються для кожного екземпляра, такі як властивість `type` наших кроликів, потрібно зберігати безпосередньо у самих об'єктах.

{{id конструктори}}

Щоб створити екземпляр певного класу, вам потрібно створити об'єкт, який є похідним від відповідного прототипу, але ви _також_ повинні переконатися, що він сам має властивості, які повинні мати екземпляри цього класу. Саме цим займається функція _((конструктор))_.

```
function makeRabbit(type) {
  let rabbit = Object.create(protoRabbit);
  rabbit.type = type;
  return rabbit;
}
```

Нотація ((клас)) у JavaScript полегшує визначення цього типу функцій разом з об'єктом ((прототип)).

{{index «rabbit example», constructor}}

```{includeCode: true}
class Rabbit {
  constructor(type) {
    this.type = type;
  }
  speak(line) {
    console.log(`Кролик ${this.type} говорить '${line}'`);
  }
}
```

{{index «властивість прототипу», [дужки, клас]}}

Ключове слово `class` починає ((оголошення класу)), що дозволяє нам визначити конструктор і набір методів разом. У фігурних дужках оголошення може бути записана будь-яка кількість методів. Цей код визначає зв'язування під назвою `Rabbit`, яке містить функцію, що запускає код у `constructor` і має властивість `prototype`, яка містить метод `peak`.

{{index «new operator», «this binding», [object, creation]}}

Цю функцію не можна викликати як звичайну функцію. Конструктори в JavaScript викликаються за допомогою ключового слова `new` перед ними. При цьому створюється новий об'єкт, прототипом якого є об'єкт з властивості `prototype` функції, потім запускається функція з `this`, прив'язаним до нового об'єкта, і нарешті повертається об'єкт.

```{includeCode: true}
let killerRabbit = new Rabbit(«killer»);
```

Насправді, `class` було введено лише у версії JavaScript 2015 року. Будь-яка функція може бути використана як конструктор, і до 2015 року спосіб визначити клас полягав у тому, щоб написати звичайну функцію, а потім маніпулювати її властивістю `prototype`.

```
function ArchaicRabbit(type) {
  this.type = type;
}
ArchaicRabbit.prototype.speak = function(line) { this.type = type; }
  console.log(`Кролик ${this.type} говорить '${line}'`);
};
let oldSchoolRabbit = new ArchaicRabbit(«стара школа»);
```

З цієї причини всі функції, що не є стрілками, починаються з властивості `prototype`, яка містить порожній об'єкт.

{{капіталізація індексу}}

За домовленістю, імена конструкторів пишуться з великої літери, щоб їх можна було легко відрізнити від інших функцій.

{{індекс «властивість прототипу», «getPrototypeOf function»}}

Важливо розуміти різницю між тим, як прототип асоціюється з конструктором (через його властивість `prototype`) і тим, як об'єкти _мають_ прототип (який можна знайти за допомогою `Object.getPrototypeOf`). Фактичним прототипом конструктора є `Function.prototype`, оскільки конструктори є функціями. Властивість `prototype` функції-конструктора містить прототип, який використовується для екземплярів, створених за її допомогою.

```
console.log(Object.getPrototypeOf(Rabbit) ==
            Function.prototype);
// → true
console.log(Object.getPrototypeOf(killerRabbit) ==
            Кролик.прототип);
// → true
```

{{Конструктор індексу}}

Конструктори зазвичай додають до `this` деякі властивості для кожного екземпляра. Також можна оголошувати властивості безпосередньо в розділі ((оголошення класу)). На відміну від методів, такі властивості додаються до об'єктів ((екземпляра)), а не до прототипу.

```
class Particle {
  speed = 0;
  constructor(position) {
    this.position = position;
  }
}
```

Як і `function`, `class` можна використовувати як в операторах, так і у виразах. Коли він використовується як вираз, він не визначає прив'язку, а просто створює конструктор як значення. Ви можете опустити ім'я класу у виразі класу.

```
let object = new class { getWord() { return «hello»; } };
console.log(object.getWord());
// → hello
```


## Приватні властивості

{{index [властивість, private], [властивість, public], «оголошення класу»}}

У класах зазвичай визначають деякі властивості та ((методи)) для внутрішнього використання, які не є частиною їхнього ((інтерфейсу)). Такі властивості називаються _приватними_, на відміну від _загальних_, які є частиною зовнішнього інтерфейсу об'єкта.

{{index [метод, private]}}

Щоб оголосити приватний метод, поставте перед його іменем знак `#`. Такі методи можна викликати тільки з оголошення класу, який їх визначає.

```
class SecretiveObject {
  #getSecret() {
    return «Я з'їв усі сливи»;
  }
  interrogate() {
    let shallISayIt = this.#getSecret();
    return «never»;
  }
}
```

Коли клас не оголошує конструктор, він автоматично отримує порожній.

Якщо ви спробуєте викликати `#getSecret` ззовні класу, то отримаєте помилку. Його існування повністю приховано всередині оголошення класу.

Щоб використовувати приватні властивості екземпляра, ви повинні їх оголосити. Звичайні властивості можна створювати простим присвоюванням, але приватні властивості _обов'язково_ мають бути оголошені в оголошенні класу, щоб бути доступними взагалі.

Цей клас реалізує пристрій для отримання випадкового цілого числа, меншого за задане максимальне число. Він має лише одну ((загальнодоступну)) властивість: `getNumber`.

```
class RandomSource {
  #max;
  constructor(max) {
    this.#max = max;
  }
  getNumber() {
    return Math.floor(Math.random() * this.#max);
  }
}
```

## Перевизначення похідних властивостей

{{індекс «спільна властивість», перевизначення, [властивість, успадкування]}}

Коли ви додаєте властивість до об'єкта, незалежно від того, присутня вона у прототипі чи ні, властивість додається до об'єкта _самостійно_. Якщо у прототипі вже була властивість з такою ж назвою, ця властивість більше не впливатиме на об'єкт, оскільки тепер вона прихована за власною властивістю об'єкта.

```
Rabbit.prototype.teeth = «small»;
console.log(killerRabbit.teeth);
// → small
killerRabbit.teeth = «довгі, гострі та криваві»;
console.log(killerRabbit.teeth);
// → довгі, гострі та криваві
console.log((new Rabbit(«basic»)).teeth);
// → маленькі
console.log(Rabbit.prototype.teeth);
// → маленькі
```

{{index [прототип, діаграма]}}

На наступній діаграмі показано ситуацію після виконання цього коду. Кролик та об'єкти `Rabbit` та `Object` ((прототип)) знаходяться позаду `killerRabbit` як своєрідне тло, на якому можна побачити властивості, яких немає в самому об'єкті.

{{figure {url: «img/rabbits.svg», alt: «Діаграма, що показує об'єктну структуру кроликів та їх прототипів. Тут зображено блок для екземпляра «killerRabbit» (містить властивості екземпляра, такі як «type»), а за ним - два його прототипи, «Rabbit.prototype» (містить метод «speak») та «Object.prototype» (містить методи, такі як «toString»).»,width: “8cm”}}}}

{{index «shared property»}}

Перевизначення властивостей, що існують у прототипі, може бути корисним. Як показує приклад з кролячими зубами, перевизначення можна використовувати для вираження виняткових властивостей в екземплярах більш загального класу об'єктів, дозволяючи невинятковим об'єктам приймати стандартне значення з їхнього прототипу.

{{index «метод toString», «прототип масиву», «прототип функції»}}

Перевизначення також використовується для того, щоб надати стандартним прототипам функцій та масивів інший метод `toString`, ніж прототип базового об'єкта.

```
console.log(Array.prototype.toString == Array.prototype.toString
            Об'єкт.прототип.toString);
// → false
console.log([1, 2].toString());
// → 1,2
```

{{індекс «метод toString», «метод приєднання», «метод виклику»}}

Виклик `toString` для масиву дає результат, подібний до виклику `.join(«,»)` - він розставляє коми між значеннями в масиві. Прямий виклик `Object.prototype.toString` з масивом створює інший рядок. Ця функція не знає про масиви, тому вона просто бере слово _об'єкт_ і назву типу у квадратні дужки.

```
console.log(Object.prototype.toString.call([1, 2]));
// → [масив об'єктів]
```

## Мапи

{{index «map method»}}

У [попередньому розділі] ми бачили, що слово _map_ використовується для позначення операції, яка перетворює структуру даних, застосовуючи функцію до її елементів. Як це не дивно, але у програмуванні те саме слово використовується для споріднених, але досить різних речей.

{{index «map (data structure)», «ages example», [«data structure», map]}}

Карта_ (іменник) - це структура даних, яка пов'язує значення (ключі) з іншими значеннями. Наприклад, вам може знадобитися зіставити імена з віком. Для цього можна використовувати об'єкти.

```
let ages = {
  Борис: 39,
  Лян: 22,
  Юля: 62
};

console.log(`Júlia is ${ages[«Júlia»]}`);
// → Юлії 62 роки
console.log(«Is Jack's age known?», «Jack» in ages);
// → Чи відомий вік Джека? false
console.log(«Чи відомий вік toString?», «toString» в роках);
// → Чи відомий вік toString? true
```

{{index «Object.prototype», «toString method»}}

Тут іменами властивостей об'єкта є імена людей, а значеннями властивостей - їхній вік. Але ми, звичайно, не додали до нашої мапи нікого з іменем toString. Проте, оскільки звичайні об'єкти походять від `Object.prototype`, схоже, що ця властивість там є.

{{index «Object.create function», prototype}}

З цієї причини використання простих об'єктів як мап є небезпечним. Існує декілька можливих способів уникнути цієї проблеми. По-перше, ви можете створювати об'єкти  без прототипу. Якщо ви передасте `null` функції `Object.create`, отриманий об'єкт не буде похідним від `Object.prototype` і його можна буде безпечно використовувати як мапу.

```
console.log(«toString» в Object.create(null));
// → false
```

{{index [властивість, назва]}}

Імена властивостей об'єктів повинні бути рядками. Якщо вам потрібна мапа, ключі якої не можуть бути легко перетворені у рядки (наприклад, об'єкти), ви не можете використовувати об'єкт як мапу.

{{index «Клас мапи»}}

На щастя, JavaScript постачається з класом `Map`, який написано саме для цієї мети. Він зберігає відображення і дозволяє використовувати будь-які типи ключів.

```
let ages = new Map();
ages.set(«Boris», 39);
ages.set(«Liang», 22);
ages.set(«Júlia», 62);

console.log(`Júlia is ${ages.get(«Júlia»)}`);
// → Юлії 62 роки
console.log(«Чи відомий вік Джека?», ages.has(«Jack»));
// → Чи відомий вік Джека? false
console.log(ages.has(«toString»));
// → false
```

{{index [інтерфейс, об'єкт], «метод set», «метод get», «метод has», інкапсуляція}}

Методи `set`, `get` та `has` є частиною інтерфейсу об'єкту `Map`. Написати структуру даних, яка може швидко оновлювати і шукати великий набір значень, нелегко, але нам не потрібно про це турбуватися. Хтось інший зробив це за нас, і ми можемо скористатися цим простим інтерфейсом для використання їхньої роботи.

{{index «hasOwn function», «in operator»}}

Якщо у вас є звичайний об'єкт, який з якихось причин потрібно обробляти як мапу, корисно знати, що `Object.keys` повертає лише  власні ключі об'єкта, а не ті, що є у прототипі. Як альтернативу оператору `in` можна використовувати функцію `Object.hasOwn`, яка ігнорує прототип об'єкта.

```
console.log(Object.hasOwn({x: 1}, «x»));
// → true
console.log(Object.hasOwn({x: 1}, «toString»));
// → false
```

## Поліморфізм

{{індекс «метод toString», «функція String», поліморфізм, перевизначення, «об'єктно-орієнтоване програмування»}}

Коли ви викликаєте функцію `String` (яка перетворює значення у рядок) на об'єкті, вона викликає метод `toString` на цьому об'єкті, щоб спробувати створити з нього осмислений рядок. Я вже згадував, що деякі стандартні прототипи визначають власну версію методу `toString`, щоб можна було створити рядок, який містить більше корисної інформації, ніж `«[об'єкт Object]»`. Ви також можете зробити це самостійно.

```{includeCode: «top_lines: 3"}
Rabbit.prototype.toString = function() {
  повернути `кролика ${this.type};
};

console.log(String(killerRabbit));
// → кролик-вбивця
```

{{index «об'єктно-орієнтоване програмування», [interface, object]}}

Це простий приклад потужної ідеї. Коли написаний фрагмент коду для роботи з об'єктами, які мають певний інтерфейс - у цьому випадку метод `toString` - будь-який тип об'єкта, який підтримує цей інтерфейс, може бути підключений до коду і зможе з ним працювати.

Цей прийом називається _поліморфізм_. Поліморфний код може працювати зі значеннями різної форми, якщо вони підтримують інтерфейс, який він очікує.

{{index «forEach method»}}

Прикладом широко використовуваного інтерфейсу є інтерфейс ((об'єктів типу масив)), які мають властивість `length`, що містить число та нумеровані властивості для кожного з їхніх елементів. Цей інтерфейс підтримують як масиви, так і рядки, а також різні інші об'єкти, деякі з яких ми розглянемо пізніше у розділах про браузер. Наша реалізація `forEach` з [Глава ?](вищий_порядок) працює з усім, що підтримує цей інтерфейс. Насправді, так само як і `Array.prototype.forEach`.

```
Array.prototype.forEach.call({
  довжина: 2,
  0: «A»,
  1: «B»
}, elt => console.log(elt));
// → A
// → B
```

## Геттери, сеттери та статика

{{index [інтерфейс, об'єкт], [властивість, визначення], «Map class»}}

Інтерфейси часто містять звичайні властивості, а не лише методи. Наприклад, об'єкти `Map` мають властивість `size`, яка показує, скільки ключів у них зберігається.

Для такого об'єкта не обов'язково обчислювати і зберігати таку властивість безпосередньо в екземплярі. Навіть властивості, доступ до яких здійснюється безпосередньо, можуть приховувати виклик методу. Такі методи називаються _((getter))s_ і визначаються написанням `get` перед іменем методу у виразі об'єкта або оголошенні класу.

```{test: no}
let varyingSize = {
  get size() {
    return Math.floor(Math.random() * 100);
  }
};

console.log(varyingSize.size);
// → 73
console.log(varyingSize.size);
// → 49
```

{{index «temperature example»}}

Кожного разу, коли хтось читає з властивості ``size`` цього об'єкта, викликається пов'язаний з нею метод. Ви можете зробити те саме, коли властивість записується, використовуючи _((сеттер))_.

```{startCode: true, includeCode: «top_lines: 16"}
class Temperature {
  constructor(celsius) {
    this.celsius = celsius;
  }
  get fahrenheit() {
    return this.celsius * 1.8 + 32;
  }
  set fahrenheit(значення) {
    this.celsius = (value - 32) / 1.8;
  }

  static fromFahrenheit(value) {
    return new Temperature((значення - 32) / 1.8);
  }
}

let temp = new Temperature(22);
console.log(temp.fahrenheit);
// → 71.6
temp.fahrenheit = 86;
console.log(temp.celsius);
// → 30
```

Клас `Temperature` дозволяє читати і записувати температуру в градусах ((Celsius)) або градусах ((Fahrenheit)), але внутрішньо він зберігає тільки градуси Цельсія і автоматично конвертує в градуси Цельсія і з градусів Цельсія в гетері і сетері `fahrenheit`.

{{index «статичний метод», «статична властивість»}}

Іноді ви хочете прикріпити деякі властивості безпосередньо до функції-конструктора, а не до прототипу. Такі методи не матимуть доступу до екземпляру класу, але можуть, наприклад, використовуватися для надання додаткових способів створення екземплярів.

Усередині оголошення класу методи або властивості, що мають перед своїм іменем `static`, зберігаються у конструкторі. Наприклад, клас `Temperature` дозволяє вам написати `Temperature.fromFahrenheit(100)` для створення температури у градусах Фаренгейта.

```
нехай boil = Temperature.fromFahrenheit(212);
console.log(boil.celsius);
// → 100
```

## Символи

{{індекс «for/of циклу», «інтерфейс ітератора»}}

У [Глава ?](data#for_of_loop) я згадував, що цикл `for`/`of` може перебирати декілька типів структур даних. Це ще один випадок поліморфізму - такі цикли очікують, що структура даних надасть певний інтерфейс, як це роблять масиви та рядки. І ми також можемо додати цей інтерфейс до наших власних об'єктів! Але перш ніж ми це зробимо, нам потрібно коротко розглянути тип символу.

Існує можливість для декількох інтерфейсів використовувати одне й те саме ім'я властивості для різних речей. Наприклад, на об'єктах, подібних до масивів, `length` означає кількість елементів у колекції. Але інтерфейс об'єкта, що описує пішохідний маршрут, може використовувати `length` для визначення довжини маршруту у метрах. Неможливо, щоб об'єкт відповідав обом цим інтерфейсам.

Об'єкт, який намагається бути одночасно і маршрутом, і масивом (можливо, щоб перерахувати точки маршруту), є дещо надуманим, і на практиці такі проблеми зустрічаються не так часто. Однак для таких речей, як ітераційний протокол, розробникам мови потрібен був тип властивості, який _справді_ не конфліктує з іншими. Тож у 2015 році до мови було додано _((символ))s_.

{{index «Symbol function», [property, naming]}}

Більшість властивостей, включаючи всі ті, які ми бачили досі, називаються рядками. Але також можна використовувати символи як назви властивостей. Символи - це значення, створені за допомогою функції `Symbol`. На відміну від рядків, новостворені символи є унікальними - ви не можете створити той самий символ двічі.

```
let sym = Symbol(«name»);
console.log(sym == Symbol(«name»));
// → false
Rabbit.prototype[sym] = 55;
console.log(killerRabbit[sym]);
// → 55
```

Рядок, який ви передаєте до `Symbol`, включається при перетворенні його у рядок і може полегшити розпізнавання символу, наприклад, при показі його у консолі. Але це не має жодного іншого значення - декілька символів можуть мати однакову назву.

Унікальність та можливість використання символів як імен властивостей робить їх придатними для визначення інтерфейсів, які можуть мирно співіснувати з іншими властивостями, незалежно від того, як вони називаються.

```{includeCode: «top_lines: 1"}
const length = Symbol(«length»);
Array.prototype[length] = 0;

console.log([1, 2].length);
// → 2
console.log([1, 2][length]);
// → 0
```

{{index [властивість, іменування]}}

Властивості символів можна включати у вирази об'єктів і класів, використовуючи ((квадратні дужки)) навколо імені властивості. Це призводить до обчислення виразу між дужками для отримання імені властивості, аналогічно до позначення доступу до властивостей у квадратних дужках.

```
нехай myTrip = {{}.
  length: 2,
  0: «Lankwitz»,
  1: «Babelsberg»,
  [length]: 21500
};
console.log(myTrip[length], myTrip.length);
// → 21500 2
```

## Інтерфейс ітератора

{{index «iterable interface», «Symbol.iterator symbol», «for/of loop»}}

Очікується, що об'єкт, який передається у цикл `for`/`of`, є _ітерабельним_. Це означає, що він має метод з іменем `Symbol.iterator` (символьне значення, визначене мовою, що зберігається як властивість функції `Symbol`).

{{index «iterator interface», «next method»}}

При виклику цей метод має повернути об'єкт, який надає другий інтерфейс, _ітератор_. Це власне те, що виконує ітерації. Він має метод `next`, який повертає наступний результат. Цей результат має бути об'єктом з властивістю `value`, яка надає наступне значення, якщо воно є, і властивістю `done`, яка має бути істинною, коли більше немає результатів, і хибною в іншому випадку.

Зверніть увагу, що імена властивостей `next`, `value` і `done` є звичайними рядками, а не символами. Тільки `Symbol.iterator`, який, ймовірно, буде додано до _багато_ різних об'єктів, є справжнім символом.

Ми можемо безпосередньо використовувати цей інтерфейс самі.

```
let okIterator = «OK»[Symbol.iterator]();
console.log(okIterator.next());
// → {значення: «O», done: false}}
console.log(okIterator.next());
// → {значення: «K», done: false}}
console.log(okIterator.next());
// → {value: undefined, done: true}
```

{{index [«структура даних», list], «зв'язаний список», collection}}

Реалізуємо ітеровану структуру даних, подібну до зв'язаного списку з вправи у [Розділ ?](дані). Цього разу ми запишемо список як клас.

```{includeCode: true}
class List {
  constructor(value, rest) {
    this.value = value
    this.rest = rest;
  }

  get length() {
    return 1 + (this.rest ? this.rest.length : 0);
  }

  static fromArray(array) {
    let result = null;
    for (let i = array.length - 1; i >= 0; i--) {
      result = new this(array[i], result);
    }
    return result;
  }
}
```

Зверніть увагу, що `this` у статичному методі вказує на конструктор класу, а не на його екземпляр - під час виклику статичного методу екземпляра класу не існує.

Ітерація над списком повинна повертати всі елементи списку від початку до кінця. Напишемо окремий клас для ітератора.

{{index «ListIterator class»}}

```{includeCode: true}
class ListIterator {
  constructor(list) {
    this.list = list;
  }

  next() {
    if (this.list == null) {
      return {done: true};
    }
    let value = this.list.value;
    this.list = this.list.rest;
    return {value, done: false};
  }
}
```

Клас відстежує хід ітерації по списку, оновлюючи свою властивість `list` для переходу до наступного об'єкту списку щоразу, коли повертається значення, і повідомляє про завершення, коли список стає порожнім (нульовим).

Давайте налаштуємо клас `List`, щоб він був ітерованим. У цій книзі я буду час від часу використовувати маніпуляції з прототипами для додавання методів до класів, щоб окремі фрагменти коду залишалися невеликими і самодостатніми. У звичайній програмі, де немає необхідності розбивати код на маленькі шматочки, ви б оголосили ці методи безпосередньо в класі.

```{includeCode: true}
List.prototype[Symbol.iterator] = function() {
  return new ListIterator(this);
};
```

{{index «for/of loop»}}

Тепер ми можемо обходити список з допомогою `for`/`of`.

```
let list = List.fromArray([1, 2, 3]);
for (let element of list) {
  console.log(element);
}
// → 1
// → 2
// → 3
```

{{розкид індексів}}

Синтаксис `...` у нотації масивів і викликах функцій аналогічно працює з будь-яким ітерованим об'єктом. Наприклад, ви можете використовувати `[...value]` для створення масиву, що містить елементи довільного ітерованого об'єкта.

```
console.log([... «PCI»]);
// → [«P», «C», «I»]
```

## Успадкування

{{індексна спадковість, «зв'язаний список», «об'єктно-орієнтоване програмування», «клас LengthList»}}

Уявіть, що нам потрібен тип списку, подібний до класу `List`, який ми розглядали раніше, але оскільки ми будемо постійно запитувати його довжину, ми не хочемо, щоб він щоразу сканував його `решту`. Замість цього ми хочемо зберігати довжину у кожному екземплярі для ефективного доступу.

{{перевизначення індексу, прототип}}

Система прототипів JavaScript дозволяє створити _новий_ клас, подібний до старого, але з новими визначеннями деяких його властивостей. Прототип нового класу походить від старого прототипу, але додає нове визначення, скажімо, для геттера `length`.

В термінах об'єктно-орієнтованого програмування це називається _((успадкування))_. Новий клас успадковує властивості та поведінку старого класу.

```{includeCode: «top_lines: 12"}
class LengthList extends List {
  #length;

  constructor(value, rest) {
    super(value, rest);
    this.#length = super.length;
  }

  get length() {
    повернути this.#length;
  }
}

console.log(LengthList.fromArray([1, 2, 3]).length);
// → 3
```

Використання слова `extends` вказує на те, що цей клас не повинен безпосередньо базуватися на прототипі за замовчуванням `Object`, а на якомусь іншому класі. Такий  клас називається _((суперклас))_. Похідним класом є _((підклас))_.

Щоб ініціалізувати екземпляр `LengthList`, конструктор викликає конструктор його суперкласу через ключове слово super. Це необхідно, оскільки якщо новий об'єкт має поводитися (приблизно) як `List`, йому знадобляться властивості екземпляра, які мають списки.

Конструктор зберігає довжину списку у приватній властивості. Якби ми написали там `this.length`, був би викликаний власний геттер класу, що поки що не працює, оскільки `#length` ще не заповнено. Ми можемо використовувати `super.something` для виклику методів і гетерів у прототипі суперкласу, що часто буває корисно.

Спадкування дозволяє нам створювати типи даних, що дещо відрізняються від існуючих, з відносно невеликими зусиллями. Це фундаментальна частина об'єктно-орієнтованої традиції, поряд з інкапсуляцією та поліморфізмом. Але якщо останні дві ідеї зараз загалом вважаються чудовими, то успадкування є більш суперечливим.

{Складність індексів, повторне використання, «ієрархія класів»}}

В той час як ((інкапсуляція)) та поліморфізм можна використовувати для _відокремлення_ частин коду одна від одної, зменшуючи заплутаність програми в цілому, ((успадкування)) фундаментально пов'язує класи разом, створюючи _більший_ клубок. При успадкуванні від класу зазвичай потрібно знати більше про те, як він працює, ніж при простому його використанні. Спадкування може бути корисним інструментом для того, щоб зробити деякі типи програм більш лаконічними, але воно не повинно бути першим інструментом, до якого ви потягнетесь, і ви, ймовірно, не повинні активно шукати можливості для побудови ієрархій класів (родинних дерев класів).

## Оператор instanceof

{{тип індексу, «оператор instanceof», конструктор, об'єкт}}

Іноді буває корисно дізнатися, чи був об'єкт похідним від певного класу. Для цього у JavaScript передбачено бінарний оператор, який називається `instanceof`.

```
console.log(
  new LengthList(1, null) instanceof LengthList);
// → true
console.log(new LengthList(2, null) instanceof List);
// → true
console.log(new List(3, null) instanceof LengthList);
// → false
console.log([1] instanceof Array);
// → true
```

{{Успадкування індексів}}

Оператор бачить успадковані типи наскрізь, тому `LengthList` є екземпляром `List`. Оператор також можна застосовувати до стандартних конструкторів, таких як `Array`. Майже кожен об'єкт є екземпляром `Object`.

## Підсумок

Об'єкти роблять більше, ніж просто володіють власними властивостями. Вони мають прототипи, якими є інші об'єкти. Вони поводитимуться так, ніби мають властивості, яких не мають, доки їхній прототип має цю властивість. Прості об'єкти мають `Object.prototype` як свій прототип.

Конструктори, тобто функції, назви яких зазвичай починаються з великої літери, можна використовувати з оператором `new` для створення нових об'єктів. Прототипом нового об'єкта буде об'єкт, знайдений у властивості `prototype` конструктора. Ви можете добре використати цю властивість, помістивши у прототип властивості, які є спільними для всіх значень даного типу. Існує нотація `class`, яка забезпечує чіткий спосіб визначення конструктора та його прототипу.

Ви можете визначити гетери та сетери для таємного виклику методів кожного разу, коли відбувається доступ до властивості об'єкта. Статичні методи - це методи, що зберігаються у конструкторі класу, а не у його прототипі.

Оператор `instanceof` може, маючи об'єкт і конструктор, сказати вам, чи є цей об'єкт екземпляром цього конструктора.

Одна з корисних речей, яку можна зробити з об'єктами - це визначити для них інтерфейс і сказати всім, що вони повинні звертатися до вашого об'єкту тільки через цей інтерфейс. Решта деталей, з яких складається ваш об'єкт, тепер «інкапсульовані», тобто сховані за інтерфейсом. Ви можете використовувати приватні властивості, щоб приховати частину вашого об'єкту від зовнішнього світу.

Більш ніж один тип може реалізовувати один і той самий інтерфейс. Код, написаний для використання інтерфейсу, автоматично знає, як працювати з будь-якою кількістю різних об'єктів, що надають інтерфейс. Це називається _поліморфізм_.

При реалізації декількох класів, які відрізняються лише деякими деталями, може бути корисним написання нових класів як _підкласів_ існуючого класу, що  успадковують частину його поведінки.

## Вправи

{{id exercise_vector}}

### Тип вектора

{{index dimensions, «Vec class», coordinates, «vector (exercise)»}}

Напишіть ((клас)) `Vec`, який представляє вектор у двовимірному просторі. Він отримує параметри `x` та `y` (числа), які зберігає в однойменних властивостях.

{{додавання, віднімання індексів}}

Додайте до прототипу `Vec` два методи, `plus` та `minus`, які приймають інший вектор як параметр і повертають новий вектор, що є сумою або різницею значень двох векторів (цього та параметра) _x_ та _y_.

Додайте до прототипу властивість ((getter)) `length`, яка обчислює довжину вектора - тобто відстань точки (_x_, _y_) від початку координат (0, 0).

{{якщо інтерактивно

```{test: no}
// Ваш код тут.

console.log(new Vec(1, 2).plus(new Vec(2, 3));
// → Vec{x: 3, y: 5}
console.log(new Vec(1, 2).minus(new Vec(2, 3));
// → Vec{x: -1, y: -1}
console.log(new Vec(3, 4).length);
// → 5
```
if}}

{{hint

{{index «вектор (вправа)»}}

Зверніться до прикладу класу `Rabbit`, якщо ви не впевнені, як виглядають оголошення `class`.

{{index «Pythagoras», «defineProperty function», «square root», «Math.sqrt function»}}

Додати властивість-геттер до конструктора можна, поставивши слово `get` перед іменем методу. Для обчислення відстані від (0, 0) до (x, y) можна скористатися теоремою Піфагора, яка говорить, що квадрат відстані, яку ми шукаємо, дорівнює квадрату координати x плюс квадрат координати y. Таким чином, [√(x^2^ + y^2^)]{if html}[[$\sqrt{x^2 + y^2}$]{latex}]{if tex} - шукане число. `Math.sqrt` - це спосіб обчислення квадратного кореня в JavaScript, а `x ** 2` можна використовувати для піднесення числа до квадрату.

підказка}}

### Групи

{{index «groups (вправа)», «клас множини», «клас групи», «множина (структура даних)»}}

{{id groups}}

Стандартне середовище JavaScript надає ще одну структуру даних, яка називається `Set`. Як і екземпляр `Map`, множина містить набір значень. На відміну від `Map`, він не пов'язує інші значення з цими - він просто відстежує, які значення є частиною набору. Значення може бути частиною множини лише один раз - повторне додавання не має жодного ефекту.

{{index «add method», «delete method», «has method»}}

Напишіть клас з назвою `Group` (оскільки `Set` вже зайнято). Як і `Set`, він має методи `add`, `delete` та `has`. Його конструктор створює порожню групу, `add` додає значення до групи (але тільки якщо він ще не є її членом), `delete` видаляє його аргумент з групи (якщо він був її членом), а `has` повертає булеве значення, яке вказує, чи є його аргумент членом групи.

{{індекс «=== оператор», «індекс методу»}}

Використовуйте оператор `===` або його еквівалент, наприклад `indexOf`, щоб визначити, чи є два значення однаковими.

{{index «статичний метод»}}

Додайте класу статичний метод `from`, який отримує об'єкт, що ітерується, як аргумент і створює групу, яка містить усі значення, отримані в результаті ітерації над ним.

{{якщо інтерактивний

```{test: no}}
class Group {
  // Ваш код тут.
}

let group = Group.from([10, 20]);
console.log(group.has(10));
// → true
console.log(group.has(30));
// → false
group.add(10);
group.delete(10);
console.log(group.has(10));
// → false
```

if}}

{{hint

{{index «groups (exercise)», «Group class», «indexOf method», «includes method»}}

Найпростіший спосіб зробити це - зберігати масив членів групи у властивості екземпляра. Методи `includes` або `indexOf` можна використовувати для перевірки наявності заданого значення у масиві.

{{index «метод push»}}

Конструктор вашого класу може встановити колекцію членів у порожній масив. Коли викликається `add`, він повинен перевірити, чи є задане значення у масиві, або додати його інакше, можливо, використовуючи `push`.

{{index «метод фільтрації»}}

Видалення елемента з масиву методом `delete` є менш простим, але ви можете використовувати `filter` для створення нового масиву без цього значення. Не забудьте перезаписати властивість, що містить члени масиву, новою відфільтрованою версією масиву.

{{index «for/of loop», «iterable interface»}}

Метод `from` може використовувати цикл `for`/`of` для отримання значень з ітерованого об'єкта і викликати `add` для додавання їх до новоствореної групи.

підказка}}

### Змінні групи

{{index «groups (exercise)», [interface, object], «iterator interface», «Group class»}}

{{id group_iterator}}

Зробіть клас `Group` з попередньої вправи ітерованим. Зверніться до розділу про інтерфейс ітератора на початку розділу, якщо вам не зрозуміла точна форма інтерфейсу.

Якщо ви використовували масив для представлення членів групи, не повертайте просто ітератор, створений викликом методу `Symbol.iterator` на масиві. Це може спрацювати, але це суперечить меті цієї вправи.

Нічого страшного, якщо ваш ітератор поводитиметься дивно, коли групу буде змінено під час ітерації.

{{if інтерактивний

```{test: no}
// Ваш код тут (і код з попередньої вправи)

for (let value of Group.from([«a», «b», «c»])) {
  console.log(value);
}
// → a
// → b
// → c
```

if}}

{{hint

{{індекс «групи (вправа)», «клас групи», «наступний метод»}}

Можливо, варто визначити новий клас `GroupIterator`. Екземпляри ітератора повинні мати властивість, яка відстежує поточну позицію в групі. Кожного разу, коли викликається `next`, вона перевіряє, чи це зроблено, і якщо ні, пересувається далі поточного значення і повертає його.

Сам клас `Group` отримує метод з іменем `Symbol.iterator`, який при виклику повертає новий екземпляр класу ітератора для цієї групи.

підказка}}
