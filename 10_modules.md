{{meta {load_files: [«code/packages_chapter_10.js», «code/chapter/07_robot.js»]}}}

# Модулі

{{quote {author: «Tef», title: 

Пишіть код, який легко видалити, але не легко розширити.

quote}}

{{index «Yuan-Ma», «Книга з програмування»}}

{{figure {url: «img/chapter_picture_10.jpg», alt: «Ілюстрація складної будівлі, побудованої з модульних частин», chapter: framed}}}

{{Організація індексів, [код, «структура»]}}

В ідеалі, програма має чітку, зрозумілу структуру. Те, як вона працює, легко пояснити, і кожна частина відіграє чітко визначену роль.

{{Індекс «органічне зростання»}

На практиці програми ростуть органічно. Частини функціональності додаються, коли програміст виявляє нові потреби. Підтримання такої програми добре структурованою вимагає постійної уваги та роботи. Це робота, яка окупиться лише  у майбутньому, коли хтось працюватиме над програмою, тому є велика спокуса знехтувати нею і дозволити різним частинам програми глибоко переплутатися.

{{читабельність, повторне використання, ізоляція}}

Це викликає дві практичні проблеми. По-перше, зрозуміти заплутану систему важко. Якщо все може торкатися всього іншого, важко розглядати будь-яку частину ізольовано. Ви змушені вибудовувати цілісне розуміння всієї системи. По-друге, якщо ви хочете використати якийсь функціонал з такої програми в іншій ситуації, переписати його може бути простіше, ніж намагатися вирвати його з контексту.

Для таких великих, безструктурних програм часто використовують фразу «((великий клубок бруду))». Все злипається, і коли ви намагаєтесь витягнути шматочок, все розвалюється на частини, і ви досягаєте успіху лише у створенні безладу.

## Модульні програми

{{індексна залежність, [інтерфейс, модуль]}}

_Модулі_ - це спроба уникнути цих проблем. Модуль - це частина програми, яка визначає, на які інші частини вона покладається і яку функціональність вона надає іншим модулям для використання (її _інтерфейс_).

{{index «big ball of mud»}}

Інтерфейси модулів мають багато спільного з інтерфейсами об'єктів, як ми бачили у [Розділ ?](об'єкт#інтерфейс). Вони роблять частину модуля доступною для зовнішнього світу, а решту залишають приватною.

{{залежність від індексів}}

Але інтерфейс, який модуль надає для використання іншими, - це лише половина справи. Хороша модульна система також вимагає, щоб модулі вказували, який код _вони_ використовують з інших модулів. Ці відношення називаються _залежностями_. Якщо модуль A використовує функціональність модуля B, то кажуть, що він _залежить_ від цього модуля. Коли вони чітко визначені в самому модулі, їх можна використовувати, щоб з'ясувати, які інші модулі повинні бути присутніми, щоб мати можливість використовувати даний модуль, а також для автоматичного завантаження залежностей.

Коли способи взаємодії модулів між собою чітко визначені, система стає більш схожою на конструктор ((LEGO)), де деталі взаємодіють через чітко визначені роз'єми, і менш схожою на багнюку, де все змішується з усім іншим.

{{id es}}

## Модулі ES

{{index «global scope», [binding, global]}}

Оригінальна мова JavaScript не мала поняття модуля. Усі скрипти працювали в одній області видимості, і доступ до функції, визначеної в іншому скрипті, здійснювався через посилання на глобальні прив'язки, створені цим скриптом. Це активно заохочувало випадкове, важко помітне переплетення коду і породжувало проблеми, такі як спроби непов'язаних скриптів використовувати одне й те саме ім'я прив'язки.

{{index «Модулі ES»}}

Починаючи з ECMAScript 2015, JavaScript підтримує два різних типи програм. _Сценарії_ поводяться по-старому: їх прив'язки визначаються у глобальній області видимості, і вони не мають можливості безпосередньо посилатися на інші сценарії. Модулі_ отримують власну окрему область видимості і підтримують ключові слова `import` та `export`, які недоступні для скриптів, для оголошення своїх залежностей та інтерфейсу. Цю систему модулів зазвичай називають _ES-модулями_ (де _ES_ означає ECMAScript).

Модульна програма складається з декількох таких модулів, пов'язаних між собою за допомогою їхнього імпорту та експорту.

{{index «Date class», «weekDay module»}}

Наступний приклад модуля перетворює назви днів у числа (що повертаються методом `getDay` класу `Date`). Він визначає константу, яка не є частиною його інтерфейсу, і дві функції, які є частиною інтерфейсу. Він не має жодних залежностей.

```
const names = [«Sunday», «Monday», «Tuesday», «Wednesday»,
               «четвер», “п'ятниця”, “субота”];

export function dayName(number) {
  return names[number];
}
export function dayNumber(name) {
  return names.indexOf(name);
}
```

Ключове слово `export` можна поставити перед визначенням функції, класу або зв'язування, щоб вказати, що це зв'язування є частиною інтерфейсу модуля. Це дає змогу іншим модулям використовувати це зв'язування, імпортуючи його.

```{test: no}
імпортуємо {dayName} з «./dayname.js»;
let now = new Date();
console.log(`Сьогодні ${dayName(now.getDay())}`);
// → Сьогодні понеділок
```

{{index «ключове слово import», dependency, «Модулі ES»}}

Ключове слово `import`, за яким слідує список імен прив'язок у дужках, робить прив'язки з іншого модуля доступними у поточному модулі. Модулі ідентифікуються за допомогою рядків у лапках.

{{index [модуль, роздільна здатність], роздільна здатність}}

Те, як таке ім'я модуля перетворюється на реальну програму, залежить від платформи. Браузер сприймає їх як веб-адреси, тоді як Node.js перетворює їх на файли. Коли ви запускаєте модуль, завантажуються всі інші модулі, від яких він залежить, і модулі, від  яких він залежить, а експортовані зв'язки стають доступними для модулів, які їх імпортують.

Оголошення імпорту та експорту не можуть з'являтися всередині функцій, циклів або інших блоків. Вони одразу ж розв'язуються при завантаженні модуля, незалежно від того, як виконується код у модулі. Щоб відобразити це, вони повинні з'являтися лише у зовнішньому тілі модуля.

Таким чином, інтерфейс модуля складається з набору іменованих прив'язок, до яких можуть звертатися інші модулі, залежні від модуля. Імпортовані прив'язки можна перейменовувати, щоб надати їм нове локальне ім'я, використовуючи `as` після їхнього імені.

```
import {dayName as nomDeJour} from «./dayname.js»;
console.log(nomDeJour(3));
// → середа
```

Модуль також може мати спеціальний експорт з назвою `default`, який часто використовується для модулів, що експортують лише одну прив'язку. Щоб визначити експорт за замовчуванням, ви пишете `export default` перед виразом, оголошенням функції або класу.

```
export default [«Winter», «Spring», «Summer», «Autumn»];
```

Така прив'язка імпортується, опускаючи дужки навколо імені імпорту.

```
імпортувати seasonNames з «./seasonname.js»;
```

Щоб імпортувати всі прив'язки з модуля одночасно, ви можете використовувати `import *`. Ви вказуєте ім'я, і це ім'я буде прив'язано до об'єкта, що містить всі експорти модуля. Це може бути корисно, коли ви використовуєте багато різних експортів.

```
імпортує * як dayName з «./dayname.js»;
console.log(dayName.dayName(3));
// → середа
```

## Пакунки

{{індексна помилка, залежність, структура, повторне використання}}

Однією з переваг побудови програми з окремих частин і можливості запускати деякі з них самостійно є те, що ви можете використовувати ту саму частину у різних програмах.

{{index «parseINI function»}}

Але як це налаштувати? Скажімо, я хочу використати функцію `parseINI` з [Глава ?](regexp#ini) в іншій програмі. Якщо зрозуміло, від чого залежить функція (у цьому випадку - ні від чого), я можу просто скопіювати цей модуль у свій новий проект і використовувати його. Але потім, якщо я знайду помилку в коді, я, ймовірно, виправлю її в тій програмі, з якою працюю в цей час, і забуду виправити її в іншій програмі.

{{дублювання індексів, «програмування копіпастом»}}

Як тільки ви почнете дублювати код, ви швидко виявите, що витрачаєте час і енергію на переміщення копій і підтримання їх в актуальному стані. Ось тут і  з 'являються _((пакунки))_. Пакунок - це фрагмент коду, який можна поширювати (копіювати та встановлювати). Він може містити один або декілька модулів та інформацію про те, від яких інших пакунків він залежить. Зазвичай до пакунка також додається документація, яка пояснює, що він робить, щоб люди, які не писали його, могли ним користуватися.

Якщо у пакунку виявлено проблему або додано нову можливість, пакунок оновлюється. Тепер програми, які залежать від нього (які також можуть бути пакунками), можуть скопіювати нову ((версію)), щоб отримати покращення, які було зроблено у коді.

{{id modules_npm}}

{{індекс встановлення, оновлення, «менеджер пакунків», завантаження, повторне використання}}

Робота у такий спосіб вимагає ((інфраструктури)). Нам потрібне місце для зберігання та пошуку пакунків, а також зручний спосіб їх встановлення та оновлення. У світі JavaScript цю інфраструктуру забезпечує ((NPM)) ([https://npmjs.com_](https://npmjs.com)).

NPM - це дві речі: онлайн-сервіс, де ви можете завантажувати (і вивантажувати) пакунки, і програма (у комплекті з Node.js), яка допомагає вам встановлювати і керувати ними.

{{index «ini package»}}

На момент написання цієї статті на NPM було доступно понад три мільйони різних пакунків. Значна частина з них, чесно кажучи, є сміттям. Але майже кожен корисний загальнодоступний пакунок JavaScript можна знайти на NPM. Наприклад, синтаксичний аналізатор INI-файлів, подібний до того, який ми створили у [Розділ ?](regexp), доступний під назвою пакунка `ini`.

{{index «командний рядок»}}

У [Розділі ?](node) буде показано, як встановити такі пакунки локально за допомогою програми командного рядка `npm`.

Наявність якісних пакунків, доступних для завантаження, є надзвичайно цінною. Це означає, що часто можна уникнути повторного винаходу програми, яку до цього написали 100 людей, і отримати надійну, добре протестовану реалізацію натисканням декількох клавіш.

{{підтримка індексу}}

Програмне забезпечення дешево копіювати, тому, якщо хтось написав його, розповсюдження його серед інших людей є ефективним процесом. Втім, саме написання програми -  це робота, а відповідати людям, які знайшли проблеми у коді або хочуть запропонувати нові можливості - це ще більше роботи.

За замовчуванням, ви володієте авторськими правами на код, який ви пишете, і інші люди можуть використовувати його лише з вашого дозволу. Але оскільки деякі люди просто добрі, і оскільки публікація хорошого програмного забезпечення може допомогти вам стати трохи відомим серед програмістів, багато пакунків публікуються під ((ліцензією)), яка явно дозволяє іншим людям використовувати його.

Більшість коду на ((NPM)) ліцензовано таким чином. Деякі ліцензії вимагають, щоб ви також публікували код, який ви збираєте поверх пакунка, під тією ж ліцензією. Інші менш вимогливі і вимагають лише, щоб ви зберігали ліцензію разом з кодом, який ви розповсюджуєте. Спільнота JavaScript здебільшого користується останнім типом ліцензії. Використовуючи чужі пакунки, переконайтеся, що ви знаєте про їхні ліцензії.

{{id modules_ini}}

{{index «ini package»}}

Тепер, замість написання власного синтаксичного аналізатора INI-файлів, ми можемо скористатися одним з ((NPM)).

```
import {parse} from «ini»;

console.log(parse(«x = 10\ny = 20»));
// → {x: «10», y: «20"}
```

{{id commonjs}}

## Модулі CommonJS

До 2015 року, коли мова JavaScript не мала вбудованої системи модулів, люди вже будували великі системи на JavaScript. Для того, щоб це працювало, їм _потрібні_ ((модулі))и.

{{індекс [функція, область видимості], [інтерфейс, модуль], [об'єкт, як модуль]}}

Спільнота розробила власну імпровізовану систему ((модулів)) поверх мови. Вони використовують функції для створення локальної області видимості модулів та звичайні об'єкти для представлення інтерфейсів модулів.

Спочатку люди просто вручну обгортали весь свій модуль у «((функція, що викликається негайно
вираз))», щоб створити область видимості модуля, і призначали об'єкти інтерфейсу до єдиної глобальної
змінній.

```
const weekDay = function() {
  const names = [«неділя», «понеділок», «вівторок», «середа»,
                 «четвер», “п'ятниця”, “субота”];
  return { name(number) { return names[number]; }
    name(number) { return names[number]; },
    number(name) { return names.indexOf(name); }
  };
}();

console.log(weekDay.name(weekDay.number(«Sunday»)));
// → неділя
```

{{індексна залежність, [інтерфейс, модуль]}}

Цей стиль модулів забезпечує ((ізоляцію)), до певної міри, але він не оголошує залежності. Замість цього, він просто поміщає свій інтерфейс у ((глобальну область видимості)) і очікує, що його залежності, якщо такі є, зроблять те ж саме. Це не є ідеальним варіантом.

{{index «CommonJS modules»}}

Якщо ми реалізуємо власний завантажувач модулів, ми можемо зробити це краще. Найпоширеніший підхід до прикручених модулів JavaScript називається _CommonJS модулі_. ((Node.js)) використовував цю систему модулів від самого початку (хоча зараз він також вміє завантажувати модулі ES), і це система модулів, яка використовується багатьма пакунками на ((NPM)).

{{index «require function», [interface, module], «exports object»}}

Модуль CommonJS виглядає як звичайний скрипт, але він має доступ до двох прив'язок, які використовуються для взаємодії з іншими модулями. Першою є функція, яка називається `require`. Коли ви викликаєте її з ім'ям модуля вашої залежності, вона переконується, що модуль завантажено, і повертає його інтерфейс. Другий - це об'єкт з назвою `exports`, який є об'єктом інтерфейсу модуля. Початково він порожній, і ви додаєте до нього властивості для визначення експортованих значень.

{{index «formatDate module», «Date class», «ordinal package», «date-names package»}}

Цей приклад модуля CommonJS надає функцію форматування дати. Він використовує два ((пакети)) з NPM - `ordinal` для перетворення чисел у рядки типу `«1st»` та `«2nd»`, та `date-names` для отримання англійських назв днів тижня та місяців. Він експортує єдину функцію `formatDate`, яка приймає об'єкт `Date` і рядок ((шаблон)).

Рядок-шаблон може містити коди, які керують форматом, наприклад, `YYYY` для повного року і `Do` для порядкового дня місяця. Ви можете задати рядок на кшталт `«MMMM Do YYYY»`, щоб отримати висновок на кшталт `22 листопада 2017 року`.

```
const ordinal = require(«ordinal»);
const {дні, місяці} = require(«date-names»);

exports.formatDate = function(date, format) {
  return format.replace(/YYYY|M(MMM)?|Do?|dddd/g, tag => {
    if (tag == «YYYY») return date.getFullYear();
    if (tag == «M») return date.getMonth()
    if (tag == «MMMM») return months[date.getMonth()];
    if (tag == «D») return date.getDate();
    if (tag == «Do») return ordinal(date.getDate());
    if (tag == «dddd») return days[date.getDay()];
  });
};
```

{{index «destructuring binding»}}

Інтерфейс `ordinal` - це одна функція, тоді як `date-names` експортує об'єкт, що містить декілька елементів - `days` і `months` - це масиви імен. Деструктуризація дуже зручна при створенні прив'язок для імпортованих інтерфейсів.

Модуль додає свою інтерфейсну функцію до `exports`, щоб модулі, які від неї залежать, отримали до неї доступ. Ми можемо використовувати модуль так:

```
const {formatDate} = require(«./format-date.js»);

console.log(formatDate(new Date(2017, 9, 13),
                       «dddd the Do"));
// → п'ятниця, 13-е
```

У CommonJS реалізовано завантажувач модулів, який при завантаженні модуля обертає його код у функцію (надаючи йому власну локальну область видимості) і передає прив'язки `require` та `exports` до цієї функції в якості аргументів.

{{id require}}

{{index «require function», «CommonJS modules», «readFile function»}}

Якщо припустити, що у нас є доступ до функції `readFile`, яка читає файл за іменем і повертає нам його вміст, ми можемо визначити спрощену форму `require` таким чином:

```{test: wrap, sandbox: require}
function require(name) {
  if (!(name in require.cache)) {
    let code = readFile(name);
    let exports = require.cache[name] = {};
    let wrapper = Function(«require, exports», code);
    wrapper(require, exports);
  }
  return require.cache[name];
}
require.cache = Object.create(null);
```

{{id eval}}

{{index «Конструктор функцій», eval, security}}

Функція - це вбудована функція JavaScript, яка приймає список аргументів (у вигляді рядка, розділеного комами) і рядок, що містить тіло функції, і повертає значення функції з цими аргументами і тілом. Це цікава концепція - вона дозволяє програмі створювати нові фрагменти програми з рядкових даних, але також і небезпечна, оскільки якщо хтось може обдурити вашу програму, вставивши наданий ними рядок у `Функцію`, він може змусити програму робити все, що завгодно.

{{index [файл, доступ]}}

Стандартний JavaScript не надає такої функції як `readFile`, але різні середовища JavaScript, такі як браузер та Node.js, надають власні способи доступу до файлів. У прикладі просто робиться вигляд, що `readFile` існує.

Щоб уникнути багаторазового завантаження одного і того ж модуля, `require` зберігає сховище (кеш) вже завантажених модулів. При виклику він спочатку перевіряє, чи був завантажений запитуваний модуль, і якщо ні, то завантажує його. Це включає в себе читання коду модуля, обгортання його у функцію та виклик.

{{index «ordinal package», «exports object», «module object», [interface, module]}}

Визначаючи `require` та `exports` як ((параметр))и для згенерованої функції-обгортки (і передаючи відповідні значення при її виклику), завантажувач переконується, що ці зв'язки доступні у ((області видимості)) модуля.

Важливою відмінністю між цією системою та модулями ES є те, що імпорт модулів ES відбувається до того, як починає виконуватися скрипт модуля, тоді як `require` є звичайною функцією, яка викликається, коли модуль вже запущено. На відміну від оголошення `import`, виклики `require`  можуть з'являтися всередині функцій, а ім'я залежності може бути будь-яким виразом, який обчислюється в рядок, тоді як `import` допускає лише звичайні рядки в лапках.

Перехід JavaScript-спільноти від стилю CommonJS до модулів ES був повільним і дещо грубим. На щастя, зараз ми знаходимося в точці, де більшість популярних пакетів на NPM надають свій код у вигляді модулів ES, а Node.js дозволяє імпортувати модулі ES з модулів CommonJS. Хоча код CommonJS все ще можна зустріти, більше немає реальних причин писати нові програми в цьому стилі.

## Збірка та пакування

{{індексна компіляція, «перевірка типів»}}

Багато пакунків JavaScript технічно не написані на JavaScript. Широко використовуються розширення мови, такі як TypeScript, перевірка типів ((діалект)), згадана у [Глава ?](помилки#типізація). Люди також часто починають використовувати заплановані нові можливості мови задовго до того, як їх буде додано до платформ, на яких фактично виконується JavaScript. Щоб зробити це можливим, вони _компілюють_ свій код, перекладаючи його з обраного діалекту JavaScript на звичайний старий JavaScript - або навіть на стару версію JavaScript - так, щоб ((браузери)) могли його виконувати.

{{індекс затримки, продуктивність, [файл, доступ], [мережа, швидкість]}}

Включення модульної програми, яка складається з 200 різних файлів, у ((веб-сторінку)) створює свої проблеми. Якщо отримання одного файлу через мережу займає 50 мілісекунд, то завантаження всієї програми займає 10 секунд, або, можливо, вдвічі менше, якщо ви можете завантажувати кілька файлів одночасно. Це дуже багато втраченого часу. Оскільки завантаження одного великого файлу, як правило, відбувається швидше, ніж завантаження багатьох маленьких файлів, веб-програмісти почали використовувати інструменти, які об'єднують їхні програми (які вони ретельно розбивають на модулі) в один великий файл, перш ніж публікувати його в Інтернеті. Такі інструменти називаються _((bundler))s_.

{{index «розмір файлу»}}

І ми можемо піти далі. Окрім кількості файлів, _розмір_ файлів також визначає, наскільки швидко вони можуть передаватися мережею. Таким чином, спільнота JavaScript винайшла _((мініфікатори))s_. Це інструменти, які беруть програму на JavaScript і роблять її меншою, автоматично видаляючи коментарі та пробіли, перейменовуючи прив'язки та замінюючи частини коду еквівалентним кодом, який займає менше місця.

{{індексний конвеєр, інструмент}}

Нерідко код, який ви знаходите в NPM-пакунку або який виконується на веб-сторінці, пройшов _багато_ етапів трансформації - перетворення з сучасного JavaScript на історичний JavaScript, об'єднання модулів в один файл і мінімізацію коду. У цій книзі ми не будемо вдаватися в подробиці цих інструментів, оскільки їх багато, і те, які з них популярні, регулярно змінюється. Просто знайте, що вони існують, і шукайте їх, коли вони вам знадобляться.

## Дизайн модуля

{{index [модуль, дизайн], [інтерфейс, модуль], [код, «структура»]}}

Структурування програм є одним з найтонших аспектів програмування. Будь-яку нетривіальну частину функціональності можна організувати різними способами.

Хороший дизайн програми є суб'єктивним - тут є компроміси і справи смаку. Найкращий спосіб зрозуміти цінність добре структурованого дизайну - це прочитати або попрацювати над великою кількістю програм і помітити, що працює, а що ні. Не думайте, що хворобливий безлад - це «просто так, як є». Ви можете покращити структуру майже всього, якщо вкладете в неї більше думок.

{{index [інтерфейс, модуль]}}

Одним з аспектів дизайну модулів є простота використання. Якщо ви розробляєте щось, що буде використовуватися кількома людьми - або навіть вами самим через три місяці, коли ви вже не пам'ятатимете деталей того, що ви робили - корисно, щоб ваш інтерфейс був простим і передбачуваним.

{{index «ini package», JSON}}

Це може означати дотримання існуючих угод. Хорошим прикладом є пакунок `ini`. Цей модуль імітує стандартний об'єкт `JSON`, надаючи функції `parse` і `stringify` (для запису INI-файлу), і, як і `JSON`, конвертує між рядками і простими об'єктами. Інтерфейс невеликий і звичний, і після того, як ви попрацюєте з ним один раз, ви, швидше за все, запам'ятаєте, як ним користуватися.

{{index «side effect», «hard disk», composability}}

Навіть якщо немає стандартної функції або широко використовуваного пакунка для імітації, ви можете зробити свої модулі передбачуваними, використовуючи прості ((структура даних))и і роблячи одну, сфокусовану річ. Багато модулів синтаксичного аналізу INI-файлів на NPM надають функцію, яка безпосередньо зчитує такий файл з жорсткого диска і розбирає його, наприклад. Це унеможливлює використання таких модулів у браузері, де ми не маємо прямого доступу до файлової системи, і додає складності, яку краще було б вирішити шляхом _складання_ модуля з деякою функцією читання файлів.

{{index «pure function»}}

Це вказує на ще один корисний аспект проектування модулів - легкість, з якою щось можна компонувати з іншим кодом. Сфокусовані модулі, які обчислюють значення, застосовуються у ширшому діапазоні програм, ніж великі модулі, які виконують складні дії з побічними ефектами. Читач INI-файлів, який наполягає на зчитуванні файлу з диска, марний у випадку, коли вміст файлу надходить з іншого джерела.

{{індекс «об'єктно-орієнтоване програмування»}}

Аналогічно, об'єкти зі станом іноді бувають корисними або навіть необхідними, але якщо щось можна зробити за допомогою функції, використовуйте функцію. Деякі з читачів INI-файлів у NPM надають стиль інтерфейсу, який вимагає спочатку створити об'єкт, потім завантажити файл у ваш об'єкт і, нарешті, використати спеціалізовані методи для отримання результатів. Подібні речі поширені в об'єктно-орієнтованій традиції, і це жахливо. Замість того, щоб зробити один виклик функції і рухатися далі, вам доводиться виконувати ритуал переміщення вашого об'єкта через різні його стани. А оскільки дані тепер загорнуті в спеціалізований об'єктний тип, весь код, який взаємодіє з ними, повинен знати про цей тип, створюючи непотрібні взаємозалежності.

Часто визначення нових структур даних не уникнути - стандартом мови передбачено лише кілька базових, і багато типів даних мають бути складнішими, ніж масив або карта. Але коли масиву достатньо, використовуйте масив.

Прикладом дещо складнішої структури даних є граф з [Глава ?](робот). Не існує єдиного очевидного способу представлення ((графа)) у JavaScript. У цій главі ми використовували об'єкт, властивості якого містять масиви рядків - інші вершини, до яких можна дістатися з цієї вершини.

Існує декілька різних пакетів для пошуку шляхів на ((NPM)), але жоден з них не використовує цей формат графа. Зазвичай вони дозволяють ребрам графа мати вагу, яка є вартістю або відстанню, пов'язаною з ним. У нашому поданні це неможливо.

{{index «Dijkstra, Edsger», pathfinding, «Dijkstra's algorithm», «dijkstrajs package»}}

Наприклад, існує пакет `dijkstrajs`. Відомий підхід до пошуку шляху, дуже схожий на нашу функцію `findRoute`, називається _алгоритм Дейкстри_, на честь Едсгера Дейкстри, який вперше його записав. Суфікс `js` часто додають до назв пакунків, щоб вказати на те, що вони написані на JavaScript. Цей пакет `dijkstrajs` використовує формат графа, подібний до нашого, але замість масивів він використовує об'єкти, значеннями властивостей яких є числа - ваги ребер.

Якщо ми захочемо скористатися цим пакетом, нам потрібно буде переконатися, що наш граф зберігається у тому форматі, якого він очікує. Всі ребра мають однакову вагу, оскільки наша спрощена модель розглядає кожну дорогу як таку, що має однакову вартість (один поворот).

```
const {find_path} = require(«dijkstrajs»);

let graph = {};
for (let node of Object.keys(roadGraph)) {
  let edges = graph[node] = {};
  for (let dest of roadGraph[node]) {
    edges[dest] = 1;
  }
}

console.log(find_path(graph, «Пошта», «Хатина»));
// → [«Post Office», «Alice's House», «Cabin»]
```

Це може бути перешкодою для компонування - коли різні пакети використовують різні структури даних для опису схожих речей, їх важко об'єднати. Тому, якщо ви бажаєте проектувати з урахуванням сумісності, з'ясуйте, яку ((структуру даних)) використовують інші користувачі, і, за можливості, наслідуйте їхній приклад.

{{Проектування індексів}}

Проектування відповідної структури модулів для програми може бути складним завданням. На етапі, коли ви все ще досліджуєте проблему, пробуєте різні варіанти, щоб побачити, що працює, ви можете не турбуватися про це надто сильно, оскільки упорядкування всього може сильно відволікати. Коли у вас з'явиться щось, що здаватиметься вам надійним, саме час зробити крок назад і впорядкувати це.

## Підсумок

Модулі надають структуру великим програмам, розділяючи код на частини з чіткими інтерфейсами та залежностями. Інтерфейс - це частина модуля, видима для інших модулів, а залежності - це інші модулі, які він використовує.

Оскільки JavaScript історично не мав системи модулів, система CommonJS була побудована на його основі. Потім в якийсь момент вона  отримала вбудовану систему, яка зараз неспокійно співіснує з системою CommonJS.

Пакунок - це частина коду, яка може розповсюджуватися самостійно. NPM - це репозиторій JavaScript-пакетів. З нього можна завантажити всілякі корисні (і непотрібні) пакунки.

## Вправи

### Модульний робот

{{index «модульний робот (вправа)», module, robot, NPM}}

{{id modular_robot}}

Це прив'язки, які створює проект з [Розділ ?](робот):

```{lang: «null"}}
дороги
buildGraph
roadGraph
VillageState
runRobot
randomPick
randomRobot
mailRoute
routeRobot
findRoute
goalOrientedRobot
```

Якби ви написали цей проект як модульну програму, які модулі ви б створили? Який модуль залежав би від іншого модуля і як виглядали б їхні інтерфейси?

Які частини, ймовірно, будуть доступні у готовому вигляді на NPM? Ви б надали перевагу використанню пакунків NPM чи написанню їх самостійно?

{{hint

{{index «модульний робот (вправа)»}}

Ось як би я зробив (але знову ж таки, не існує єдиного _правильного_ способу проектування даного модуля):

{{index «dijkstrajs package»}}

Код, який використовується для побудови графіка доріг, знаходиться у модулі `graph.js`. Оскільки я вважаю за краще використовувати `dijkstrajs` з NPM, а не наш власний код для пошуку шляхів, ми зробимо цю збірку з тими даними графіка, які очікує `dijkstrajs`. Цей модуль експортує єдину функцію `buildGraph`. Я б зробив так, щоб `buildGraph` приймала масив двоелементних масивів, а не рядки, що містять дефіси, щоб зробити модуль менш залежним від формату вхідних даних.

Модуль `roads.js` містить вихідні дані про дороги (масив `roads`) та прив'язку `roadGraph`. Цей модуль залежить від `./graph.js` і експортує дорожній графік.

{{index «random-item package»}}

Клас `VillageState` знаходиться в модулі `state.js`. Він залежить від модуля `./roads.js`, тому що йому потрібно мати можливість перевірити, чи існує дана дорога. Також йому потрібна функція `randomPick`. Оскільки це трирядкова функція, ми могли б просто помістити її в модуль `state.js` як внутрішню допоміжну функцію. Але `randomRobot` також потребує її. Тому нам доведеться або продублювати її, або помістити в його власний модуль. Оскільки ця функція існує на NPM у пакунку `random-item`, розумним рішенням буде просто зробити обидва модулі залежними від неї. Ми також можемо додати функцію `runRobot` до цього модуля, оскільки вона невелика і тісно пов'язана з керуванням станом. Модуль експортує як клас `VillageState`, так і функцію `runRobot`.

Нарешті, роботи разом зі значеннями, від яких вони залежать, наприклад, `mailRoute`, можуть потрапляти в модуль `example-robots.js`, який залежить від `./roads.js` і експортує функції роботів. Щоб зробити можливим для `goalOrientedRobot` пошук маршрутів, цей модуль також залежить від `dijkstrajs`.

Вивантаживши частину роботи на модулі ((NPM)), код став трохи меншим. Кожен окремий модуль робить щось досить просте і може бути прочитаний самостійно. Поділ коду на модулі також часто підказує подальше покращення дизайну програми. У цьому випадку здається трохи дивним, що `VillageState` і роботи залежать від конкретного дорожнього графа. Можливо, було б краще зробити граф аргументом для конструктора штату і змусити роботів зчитувати його з об'єкта штату - це зменшує залежність (що завжди добре) і дає можливість запускати симуляції на різних картах (що ще краще).

Чи варто використовувати NPM-модулі для речей, які ми могли б написати самі? В принципі, так - для нетривіальних речей, таких як функція пошуку шляху, ви, швидше за все, зробите помилки і витратите час на їх написання самостійно. Для крихітних функцій, таких як `random-item`, написати їх самостійно досить легко. Але додавання їх усюди, де вони вам потрібні, має тенденцію захаращувати ваші модулі.

Втім, не варто також недооцінювати роботу, пов'язану з _пошуком_ відповідного NPM-пакунка. І навіть якщо ви його знайдете, він може не працювати належним чином або у ньому може бути відсутня якась необхідна вам функція. Крім того, залежність від пакунків NPM означає, що ви повинні переконатися, що їх встановлено, ви повинні розповсюджувати їх разом з вашою програмою, і, можливо, вам доведеться періодично оновлювати їх.

Отже, знову ж таки, це компроміс, і ви можете прийняти будь-яке рішення залежно від того, наскільки даний пакунок дійсно допомагає вам.

підказка}}

### Модуль доріг

{{index «модуль доріг (вправа)»}}

Напишіть модуль ЕС на основі прикладу з [Розділ ?](робот), який містить масив доріг і експортує структуру даних у вигляді графа, що представляє їх як `roadGraph`. Він залежить від модуля `./graph.js`, який експортує функцію `buildGraph`, що використовується для побудови графа. Ця функція очікує масив двохелементних масивів (початкові та кінцеві точки доріг).

{{якщо інтерактивно

```{test: no}
// Додавання залежностей та експорт

const roads = [
  «Будинок Аліси - Будинок Боба», “Будинок Аліси - Хатина”,
  «Будинок Аліси-Пошта», “Будинок Боба-Ратуша”,
  «Будинок Дарини - будинок Ерні», “Будинок Дарини - ратуша”,
  «Будинок Ерні - будинок Грети», “Будинок Грети - ферма”,
  «Будинок Грети - магазин», “Ринок - ферма”,
  «Ринок-пошта», “Ринок-магазин”,
  «Ринок-ратуша», »Магазин-ратуша»
];
```

if}}

{{hint

{{індекс «модуль доріг (вправа)», «прив'язка деструктуризації», «об'єкт експорту»}}

Оскільки це модуль ES, для доступу до модуля графів потрібно використовувати `import`. Це було описано як експорт функції `buildGraph`, яку ви можете вибрати з її інтерфейсного об'єкта за допомогою деструктуючого оголошення `const`.

Щоб експортувати `roadGraph`, вам слід додати ключове слово `export` перед її визначенням. Оскільки `buildGraph` отримує структуру даних, яка не зовсім відповідає `roads`, розбиття рядків доріг має відбуватися у вашому модулі.

підказка}}

### Циклічні залежності

{{індексна залежність, «кругова залежність», «вимагати функцію»}}

Циклічна залежність - це ситуація, коли модуль A залежить від B, а B також, прямо чи опосередковано, залежить від A. Багато модульних систем просто забороняють це, тому що який би порядок завантаження таких модулів ви не вибрали, ви не можете переконатися, що залежності кожного модуля були завантажені перед його запуском.

((Модулі CommonJS)) дозволяють обмежену форму циклічних залежностей. Якщо модулі не звертаються до інтерфейсу один одного до завершення завантаження, циклічні залежності є нормальними.

Функція `require`, наведена [раніше у цій главі](modules#require), підтримує цей тип циклу залежностей. Ви можете подивитися, як вона обробляє цикли?

{{підказка

{{перевизначення індексу, «циклічна залежність», «експортує об'єкт»}}

Хитрість полягає у тому, що `require` додає об'єкт інтерфейсу модуля до свого кешу _до_ того,  як почне завантажувати модуль. Таким чином, якщо будь-який виклик `require`, зроблений під час роботи модуля, спробує його завантажити, він вже буде відомий, і поточний інтерфейс буде повернуто, замість того, щоб починати завантажувати модуль ще раз (що зрештою призведе до переповнення стеку).

підказка}}
