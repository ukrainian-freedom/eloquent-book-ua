{{meta {code_links: [«code/file_server.mjs»]}}}

# Node.js

{{quote {author: «Master Yuan-Ma», title: «The Book of Programming», chapter: true}}} {{quote {author: “Master Yuan-Ma”, title.

Учень запитав: «Старі програмісти використовували лише прості машини і не знали мов програмування, але вони створювали прекрасні програми. Чому ми використовуємо складні машини і мови програмування? Фу-Цзи відповів: «Стародавні будівельники використовували лише палиці та глину, але будували прекрасні хатини».

quote}}

{{index «Yuan-Ma», «Книга про програмування»}}

{{figure {url: «img/chapter_picture_20.jpg», alt: «Ілюстрація із зображенням телефонного стовпа з клубком дротів, що розходяться на всі боки», »chapter: «Обрамлення"}}}

{{index «командний рядок»}}

Досі ми використовували мову JavaScript у єдиному середовищі: у браузері. У цій главі та [наступній] (обмін навичками) ми коротко познайомимося з ((Node.js)), програмою, яка дозволяє застосовувати ваші навички JavaScript за межами браузера. З її допомогою ви можете створювати що завгодно - від невеликих інструментів командного рядка до HTTP-серверів, які забезпечують роботу динамічних веб-сайтів.

Ці розділи мають на меті навчити вас основним концепціям, які використовує Node.js, і дати вам достатньо інформації для написання корисних програм на цій мові. Вони не намагаються бути повним або навіть ґрунтовним описом платформи.

{{якщо інтерактивний

Якщо код у попередніх розділах можна було запускати безпосередньо на цих сторінках, оскільки він був або сирим JavaScript, або написаний для браузера, то приклади коду в цій главі написані для Node і часто не будуть виконуватися в браузері.

if}}

Якщо ви хочете продовжити і запустити код у цій главі, вам потрібно встановити Node.js версії 18 або вище. Для цього перейдіть на [_https://nodejs.org_](https://nodejs.org) і дотримуйтесь інструкцій по встановленню для вашої операційної системи. Там же ви можете знайти додаткову ((документацію)) для Node.js.

## Передумови

{{індекс відгуку, введення, [мережа, швидкість]}}

При створенні систем, які взаємодіють через мережу, те, як ви керуєте вводом і ((виводом)) - тобто читанням і записом даних у мережу і з мережі та ((жорсткого диска)) - може мати велике значення для того, як швидко система реагує на запити користувача або на запити мережі.

{{index [«асинхронне програмування», «у Node.js»]}}

У таких програмах асинхронне програмування часто буває корисним. Воно дозволяє програмі надсилати та отримувати дані з та на декілька пристроїв одночасно без складного управління потоками та синхронізації.

{{index «мова програмування», «Node.js», standard}}

Node спочатку був задуманий з метою зробити асинхронне програмування простим і зручним. JavaScript добре підходить для такої системи, як Node. Це одна з небагатьох мов програмування, яка не має вбудованого способу вводу-виводу. Таким чином, JavaScript можна вписати в досить ексцентричний підхід Node до програмування мережі та файлової системи, не отримуючи в результаті два неузгоджених інтерфейси. У 2009 році, коли розроблявся Node, люди вже виконували програмування на основі зворотного виклику в браузері, тому ((спільнота)) навколо мови звикла до асинхронного стилю програмування.

## Команда node

{{index «node program»}}

Коли ((Node.js)) встановлюється в системі, він надає програму під назвою `node`, яка використовується для запуску файлів JavaScript. Скажімо, у вас є файл `hello.js`, що містить такий код:

```
let message = «Hello world»;
console.log(message);
```

Потім ви можете запустити `node` з командного рядка ось так, щоб виконати програму:

```{lang: null}
$ node hello.js
Привіт, світе
```

{{index «console.log»}}

Метод `console.log` у Node робить щось подібне до того, що він робить у браузері. Він виводить фрагмент тексту. Але в Node текст потрапляє в потік процесу ((стандартний вивід)), а не в браузер ((консоль JavaScript)). При запуску `node` з командного рядка це означає, що ви побачите записані значення у вашому ((терміналі)).

{{index «node program», «read-eval-print loop»}}

Якщо ви запустите `node` без передачі йому файлу, він надасть вам підказку, в якій ви можете ввести код JavaScript і одразу побачити результат.

```{lang: null}
$ node
> 1 + 1
2
> [-1, -2, -3].map(Math.abs)
[1, 2, 3]
> process.exit(0)
$
```

{{індекс «об'єкт процесу», «глобальна область видимості», [прив'язка, глобальна], «метод виходу», «код стану»}}

Прив'язка `process`, як і прив'язка `console`, доступна у Node глобально. Вона надає різні способи перевірки та маніпулювання поточною програмою. Метод `exit` завершує процес і може отримати код статусу виходу, який повідомляє програмі, що запустила `node` (у даному випадку, оболонку командного рядка), чи програма завершилася успішно (код нуль), чи зіткнулася з помилкою (будь-який інший код).

{{index «command line», «argv property»}}

Щоб дізнатися аргументи командного рядка, передані вашому скрипту, ви можете прочитати файл `process.argv`, який являє собою масив рядків. Зверніть увагу, що він також містить назву команди `node` і назву вашого скрипта, тому фактичні аргументи починаються з індексу 2. Якщо `showargv.js` містить оператор `console.log(process.argv)`, ви можете запустити його так:

```{lang: null}
$ node showargv.js one --and two
[«node», «/tmp/showargv.js», «one», «--and», «two»]
```

{{index [binding, global]}}

Усі ((стандартні)) глобальні прив'язки JavaScript, такі як `Array`, `Math` та `JSON`, також присутні у середовищі Node. Функціональність, пов'язана з браузером, наприклад, `document` або `prompt`, відсутня.

## Модулі

{{index «Node.js», «global scope», «module loader»}}

Окрім згаданих мною прив'язок, таких як `console` та `process`, Node має ще декілька додаткових прив'язок у глобальній області видимості. Якщо ви хочете отримати доступ до вбудованої функціональності, вам слід звернутися до системи модулів.

{{index «require function»}}

Node спочатку використовував систему модулів ((CommonJS)), засновану на функції `require`, яку ми бачили в [Глава ?](modules#commonjs). Він і надалі використовуватиме цю систему за замовчуванням, коли ви завантажуватимете файл `.js`.

{{index «import keyword», «ES modules»}}

Але сьогодні Node також підтримує більш сучасну систему модулів ES. Коли ім'я файлу скрипта закінчується на `.mjs`, він вважається таким модулем, і в ньому можна використовувати `import` і `export` (але не `require`). У цій главі ми будемо використовувати ES-модулі.

{{index [шлях, «файлова система»], «відносний шлях», роздільна здатність}}

При імпорті модуля - чи то за допомогою `require` чи `import` - вузол має перетворити заданий рядок у реальний ((файл)), який він може завантажити. Імена, що починаються з `/`, `./` або `../`, розпізнаються як файли, відносно шляху до поточного модуля. Тут `.` означає поточний каталог, `../` - каталог на один вище, а `/` - корінь файлової системи. Якщо ви запитаєте `«./graph.mjs»` з файлу `/tmp/robot/robot.mjs`, Node спробує завантажити файл `/tmp/robot/graph.mjs`.

{{index «каталог_модулів_нода», каталог}}

Коли імпортується рядок, який не виглядає як відносний або абсолютний шлях, вважається, що він посилається або на вбудований ((модуль)), або на модуль, встановлений у каталозі `node_modules`. Наприклад, імпорт з `«node:fs»` дасть вам вбудований модуль файлової системи Node. Імпорт з `«robot»` може спробувати завантажити бібліотеку з каталогу `node_modules/robot/`. Зазвичай такі бібліотеки встановлюють за допомогою ((NPM)), до якого ми повернемося пізніше.

{{index «import keyword», «Node.js», «garble example»}}

Давайте створимо невеликий проект, що складається з двох файлів. Перший, який називається `main.mjs`, визначає скрипт, який можна викликати з ((командного рядка)) для реверсування рядка.

```
import {reverse} from «./reverse.mjs»;

// Індекс 2 містить перший фактичний аргумент командного рядка
let argument = process.argv[2];

console.log(reverse(argument));
```

{{повторне використання індексу, «функція Array.from», «метод приєднання»}}

Файл `reverse.mjs` визначає бібліотеку для реверсування рядків, яка може бути використана як цим інструментом командного рядка, так і іншими скриптами, яким потрібен прямий доступ до функції реверсування рядків.

```
export function reverse(string) {
  return Array.from(string).reverse().join(«»);
}
```

{{index «ключове слово export», «Модулі ES», [інтерфейс, модуль]}}

Пам'ятайте, що `export` використовується для оголошення того, що зв'язування є частиною інтерфейсу модуля. Це дозволяє `main.mjs` імпортувати та використовувати функцію.

Тепер ми можемо викликати наш інструмент так:

```{lang: null}
$ вузол main.mjs JavaScript
tpircSavaJ
```

## Встановлення за допомогою NPM

{{index NPM, «Node.js», «npm program», library}}

NPM, представлений у [Розділі ?](модулі#модулі_npm), є онлайн сховищем JavaScript ((модулів)), багато з яких написано спеціально для Node. Коли ви встановлюєте Node на свій комп'ютер, ви також отримуєте команду `npm`, за допомогою якої ви можете взаємодіяти з цим репозиторієм.

{{index «ini package»}}

Основне використання NPM - це завантаження пакунків. Ми розглядали пакунок `ini` у [Глава ?](modules#modules_ini). Ми можемо скористатися NPM для отримання та встановлення цього пакунка на наш комп'ютер.

```{lang: null}
$ npm install ini
додано 1 пакунок за 723 мс

$ node
> const {parse} = require(«ini»);
> parse(«x = 1\ny = 2»);
{ x: '1', y: '2' }
```

{{index «require function», «node_modules directory», «npm program»}}

Після запуску `npm install`, ((NPM)) створить каталог з назвою `node_modules`. Усередині цього каталогу буде створено каталог `ini`, який міститиме ((бібліотеку)). Ви можете відкрити його і подивитися на код. Коли ми імпортуємо `«ini»`, ця бібліотека завантажується, і ми можемо викликати її властивість `parse` для розбору конфігураційного файлу.

За замовчуванням NPM встановлює пакунки до поточного каталогу, а не у центральне місце. Якщо ви звикли до інших менеджерів пакунків, це може здатися незвичним, але це має свої переваги - це дає кожній програмі повний контроль над пакунками, які вона встановлює, а також полегшує керування версіями та очищення при видаленні програми.

### Файли пакунків

{{index «package.json», dependency}}

Після запуску `npm install` для встановлення якогось пакунка, ви знайдете у вашому поточному каталозі не лише каталог `node_modules`, але й файл з назвою `package.json. Рекомендується мати такий файл для кожного проекту. Ви можете створити його вручну або запустити `npm init`. Цей файл містить інформацію про проект, зокрема його назву та ((версію)), а також список його залежностей.

Симуляція робота з [Розділ ?](robot), модульована у вправі з [Розділ ?](modules#modular_robot), може мати такий файл `package.json`:

```{lang: «json"}
{
  «author": «Marijn Haverbeke»,
  «name": «eloquent-javascript-robot»,
  «description": «Моделювання робота з доставки пакунків»,
  «version": «1.0.0»,
  «main": «run.mjs»,
  «dependencies": {
    «dijkstrajs": «^1.0.1»,
    «random-item": «^1.0.0»
  },
  «license": «ISC»
}
```

{{index «npm program», tool}}

Коли ви запускаєте `npm install` без назви пакунка для встановлення, NPM встановить залежності, перелічені у `package.json`. Коли ви встановлюєте певний пакунок, якого ще не вказано як залежність, NPM додасть його до `package.json`.

### Версії

{{index «package.json», dependency, evolution}}

Файл `package.json` містить список версій як самої програми ((версія)), так і версій її залежностей. Версії - це спосіб врахувати той факт, що ((пакунки)) розвиваються окремо, і код, написаний для роботи з пакунком у тому вигляді, у якому він існував у певний момент, може не працювати з пізнішою, зміненою версією пакунка.

{Сумісність з індексами

NPM вимагає, щоб пакунки слідували схемі, яка називається _((семантична версійність))_, яка кодує деяку інформацію про те, які версії є _сумісними_ (не порушують старий інтерфейс) у номері версії. Семантична версія складається з трьох чисел, розділених крапками, наприклад `2.3.0`. Кожного разу, коли додається нова функціональність, середнє число має бути збільшено. Щоразу, коли порушується сумісність, так що існуючий код, який використовує пакунок, може не працювати з новою версією, перше число має бути збільшено.

{{index «символ лапок»}}

Символ лапок (`^`) перед номером версії для залежності у `package.json` вказує на те, що можна встановити будь-яку версію, сумісну з цим номером. Наприклад, `«^2.3.0»` означатиме, що дозволено встановлювати будь-яку версію, більшу або рівну 2.3.0 і меншу за 3.0.0.

{{публікація індексів}}

Команда `npm` також використовується для публікації нових пакунків або нових версій пакунків. Якщо ви запустите `npm publish` у ((каталозі)), який містить файл `package.json`, вона опублікує до реєстру пакунок з назвою і версією, вказаними у файлі JSON. Будь-хто може публікувати пакунки до NPM, але лише під назвою пакунка, який ще не використовується, оскільки не хотілося б, щоб випадкові люди могли оновлювати існуючі пакунки.

У цій книзі ми не будемо заглиблюватися у деталі використання ((NPM)). Зверніться до [https://npmjs.com_](https://npmjs.com) для отримання додаткової документації та способу пошуку пакунків.

## Модуль файлової системи

{{index directory, «node:fs package», «Node.js», [file, access]}}

Одним з найпоширеніших вбудованих модулів у Node є модуль `node:fs`, що розшифровується як _((файлова система))_. Він експортує функції для роботи з файлами та каталогами.

{{index «функція readFile», «функція зворотного виклику»}}

Наприклад, функція з назвою `readFile` читає файл, а потім викликає функцію зворотного виклику з вмістом файлу.

```
import {readFile} from «node:fs»;
readFile(«file.txt», «utf8», (error, text) => {
  if (error) throw error;
  console.log(«Файл містить:», text);
});
```

{{index «Buffer class»}}

Другий аргумент `readFile` вказує на _((кодування символів))_, що використовується для декодування файлу у рядок. Існує декілька способів кодування ((текст)) у ((двійкові дані)), але більшість сучасних систем використовують ((UTF-8)). Якщо у вас немає причин вважати, що використовується інше кодування, передавайте `«utf8»` при читанні текстового файлу. Якщо ви не вкажете кодування, Node вважатиме, що вас цікавлять двійкові дані, і надасть вам об'єкт `Buffer` замість рядка. Це об'єкт типу масив, який містить числа, що відповідають байтам (8-бітним фрагментам даних) у файлах.

```
import {readFile} from «node:fs»;
readFile(«file.txt», (error, buffer) => {
  if (error) throw error;
  console.log(«Файл містить», buffer.length, «bytes.»,
              «Перший байт:», buffer[0]);
});
```

{{index «writeFile function», «filesystem», [file, access]}}

Аналогічна функція, `writeFile`, використовується для запису файлу на диск.

```
import {writeFile} from «node:fs»;
writeFile(«graffiti.txt», «Node was here», err => {
  if (err) console.log(`Не вдалося записати файл: ${err}`);
  else console.log(«Файл записано.»);
});
```

{{index «Клас буфера», «кодування символів»}}

Тут не потрібно було вказувати кодування - `writeFile` вважатиме, що коли йому передається рядок для запису, а не об'єкт `Buffer`, він повинен вивести його як текст, використовуючи своє кодування символів за замовчуванням, тобто ((UTF-8)).

{{index «node:fs package», «readdir function», «stat function», «rename function», «unlink function»}}

Модуль `node:fs` містить багато інших корисних функцій: `readdir` надасть вам файли у ((каталозі)) у вигляді масиву рядків, `stat` отримає інформацію про файл, `rename` перейменує файл, `unlink` вилучить файл, і так далі. Докладнішу інформацію можна знайти у документації за адресою [https://nodejs.org_](https://nodejs.org).

{{index [«асинхронне програмування», «у Node.js»], «Node.js», «обробка помилок», «функція зворотного виклику»}}

Більшість з них приймають функцію зворотного виклику як останній параметр, яку вони викликають або при помилці (перший аргумент), або при успішному результаті (другий). Як ми бачили у [Розділ ?](async), у такого стилю програмування є недоліки, найбільшим з яких є те, що обробка помилок стає багатослівною і схильною до помилок.

{{index «Promise class», «node:fs/promises package»}}

Модуль `node:fs/promises` експортує більшість тих самих функцій, що і старий модуль `node:fs`, але використовує обіцянки замість функцій зворотного виклику.

```
імпортує {readFile} з «node:fs/promises»;
readFile(«file.txt», «utf8»)
  .then(text => console.log(«Файл містить:», text));
```

{{index «синхронне програмування», «node:fs package», «функція readFileSync»}}

Іноді асинхронність не потрібна, і вона просто заважає. Багато функцій у `node:fs` також мають синхронний варіант, який має ту саму назву з додаванням `Sync` у кінці. Наприклад, синхронна версія функції `readFile` називається `readFileSync`.

```
import {readFileSync} from «node:fs»;
console.log(«Файл містить:»,
            readFileSync(«file.txt», «utf8»));
```

{{Оптимізація індексів, продуктивність, блокування}}

Зверніть увагу, що під час виконання такої синхронної операції ваша програма повністю зупиняється. Якщо вона повинна відповідати користувачеві або іншим машинам у мережі, застрягання на синхронній дії може призвести до неприємних затримок.

## Модуль HTTP

{{index «Node.js», «node:http package», [HTTP, сервер]}}

Ще один центральний модуль називається `node:http`. Він надає функціональність для запуску HTTP ((сервера)).

{{index «listening (TCP)», «listen method», «createServer function»}}

Це все, що потрібно для запуску HTTP-сервера:

```
import {createServer} from «node:http»;
let server = createServer((request, response) => {
  response.writeHead(200, {«Content-Type»: «text/html»});
  response.write(`
    <h1>Привіт! </h1>
    <p>Ви запитували <code>${request.url}</code></p>`);
  response.end();
});
server.listen(8000);
console.log("Слухаю! (порт 8000)");
```

{{index port, localhost}}

Якщо ви запускаєте цей скрипт на своєму комп'ютері, ви можете вказати веб-браузеру на [_http://localhost:8000/hello_](http://localhost:8000/hello), щоб зробити запит до вашого сервера. Він відповість невеликою HTML-сторінкою.

{{index «createServer function», HTTP}}

Функція, передана як аргумент до `createServer`, викликається кожного разу, коли клієнт з'єднується з сервером. Зв'язки `request` та `response` - це об'єкти, що представляють вхідні та вихідні дані. Перша містить інформацію про ((запит)), наприклад, його властивість `url`, яка повідомляє нам, до якої URL-адреси було зроблено запит.

Коли ви відкриваєте цю сторінку у своєму браузері, він надсилає запит на ваш власний комп'ютер. Це призводить до того, що функція сервера запускається і надсилає відповідь, яку ви можете побачити в браузері.

{{index «200 (код стану HTTP)», «Content-Type header», «writeHead method»}}

Щоб відправити щось клієнту, ви викликаєте методи на об'єкті `response`. Перший, `writeHead`, випише ((відповідь)) ((заголовок)) (див. [Глава ?](http#headers)). Ви передаєте йому код статусу (у цьому випадку 200 для «OK») і об'єкт, який містить значення заголовків. У прикладі задано заголовок `Content-Type`, щоб повідомити клієнту, що ми надсилатимемо назад HTML-документ.

{{index «writable stream», «body (HTTP)», stream, «write method», «end method»}}

Далі за допомогою `response.write` надсилається власне тіло відповіді (сам документ). Ви можете викликати цей метод декілька разів, якщо хочете надсилати відповідь по частинах - наприклад, щоб передавати дані клієнту по мірі їх надходження. Нарешті, `response.end` сигналізує про кінець відповіді.

{{index «метод прослуховування»}}

Виклик `server.listen` призводить до того, що ((сервер)) починає очікувати з'єднання на ((порт)) 8000. Ось чому для зв'язку з цим сервером вам слід підключатися до _localhost:8000_, а не просто до _localhost_, який використовує порт 80 за замовчуванням.

{{index «Node.js», «kill process»}}

Коли ви запускаєте цей скрипт, процес просто сидить і чекає. Коли скрипт прослуховує події - у цьому випадку мережеві з'єднання - `node` не буде автоматично завершувати роботу, коли досягне кінця скрипта. Щоб закрити його, натисніть [ctrl]{ім'я}-C.

{{index [метод, HTTP]}}

Справжній веб-сервер зазвичай робить більше, ніж показано у прикладі - він дивиться на метод запиту (властивість `method`), щоб побачити, яку дію намагається виконати клієнт, і дивиться на URL-адресу запиту, щоб дізнатися, на якому ресурсі ця дія виконується. Ми розглянемо більш просунутий сервер [пізніше у цій главі] (node#file_server).

{{index «node:http package», «request function», «fetch function», [HTTP, client]}}

Модуль `node:http` також надає функцію `request`, за допомогою якої можна робити HTTP-запити. Однак, вона набагато більш громіздка у використанні, ніж `fetch`, яку ми розглядали у [Розділ ?](http). На щастя, `fetch` також доступна у Node як глобальна прив'язка. Якщо ви не хочете робити щось дуже специфічне, наприклад, обробляти документ-відповідь шматок за шматком по мірі надходження даних по мережі, я рекомендую використовувати `fetch`.

## Потоки

{{index «Node.js», stream, «потік для запису», «функція зворотного виклику», [«асинхронне програмування», «в Node.js»], «метод запису», «метод завершення», «клас буфера»}}

Об'єкт-відповідь, до якого може писати HTTP-сервер, є прикладом об'єкта _записуваного потоку_, який є широко використовуваною концепцією в Node. Такі об'єкти мають метод `write`, якому можна передати рядок або об'єкт `Buffer`, щоб записати щось у потік. Їх метод `end` закриває потік і за бажанням приймає значення для запису в потік перед закриттям. Обом цим методам також можна передавати як додатковий аргумент функцію зворотного виклику, яку вони викличуть після завершення запису або закриття.

{{index «createWriteStream function», «writeFile function», [file, stream]}}

Можна створити доступний для запису потік, який вказує на файл, за допомогою функції `createWriteStream` з модуля `node:fs`. Ви можете використовувати метод `write` на отриманому об'єкті для запису файлу по частинах, а не за один раз, як у випадку з `writeFile`.

{{index «createServer function», «request function», «event handling», «readable stream»}}

_Readable ((stream))s_ трохи більше задіяні. Аргумент `request` для зворотного виклику HTTP-сервера є потоком для читання. Читання з потоку здійснюється за допомогою обробників подій, а не методів.

{{index «on method», «addEventListener method»}}

Об'єкти, які генерують події у Node, мають метод з назвою `on`, який подібний до методу `addEventListener` у браузері. Ви даєте йому ім'я події, а потім функцію, і він зареєструє цю функцію для виклику щоразу, коли відбувається дана подія.

{{index «createReadStream function», «data event», «end event», «readable stream»}}

Потоки для читання мають події «дані» та «кінець». Перша виконується щоразу, коли надходять дані, а друга викликається, коли потік досягає кінця. Ця модель найкраще підходить для _потокових_ даних, які можна негайно обробити, навіть якщо весь документ ще не доступний. Файл можна прочитати як потік для читання за допомогою функції `createReadStream` з `node:fs`.

{{index «upcasing server example», capitalization, «toUpperCase method»}}

Цей код створює ((сервер)), який читає тіла запитів і передає їх назад клієнту у вигляді тексту у верхньому регістрі:

```
import {createServer} from «node:http»;
createServer((request, response) => {
  response.writeHead(200, {«Content-Type»: «text/plain»});
  request.on(«data», chunk =>)
    response.write(chunk.toString().toUpperCase()));
  request.on(«end», () => response.end());
}).listen(8000);
```

{{index «Buffer class», «toString method»}}

Значення `chunk`, передане обробнику даних, буде двійковим `Buffer`. Ми можемо перетворити його в рядок, декодувавши його в символи в кодуванні UTF-8 за допомогою методу `toString`.

Наступний фрагмент коду, якщо запустити його з активним сервером верхнього регістру, надішле запит до цього сервера і виведе відповідь, яку він отримає:

```
fetch(«http://localhost:8000/», {
  метод: «POST»,
  тіло: «Hello server»
}).then(resp => resp.text()).then(console.log);
// → ПРИВІТ СЕРВЕРУ
```

{{id file_server}}

## Файловий сервер

{{index «file server example», «Node.js», [HTTP, server]}}

Давайте об'єднаємо наші нові знання про HTTP ((сервер)) і роботу з ((файловою системою)), щоб створити міст між ними: HTTP-сервер, який дозволяє ((віддалений доступ)) до файлової системи. Такий сервер має безліч застосувань - він дозволяє веб-програмам зберігати та обмінюватися даними, або може надати групі людей спільний доступ до групи файлів.

{{index [шлях, URL], «метод GET», «метод PUT», «метод DELETE», [файл, ресурс]}}

Коли ми розглядаємо файли як HTTP ((ресурс))и, HTTP-методи `GET`, `PUT` і `DELETE` можна використовувати для читання, запису і видалення файлів відповідно. Ми будемо інтерпретувати шлях у запиті як шлях до файлу, на який посилається запит.

{{index [шлях, «файлова система»], «відносний шлях»}}

Ймовірно, ми не хочемо ділитися всією нашою файловою системою, тому будемо інтерпретувати ці шляхи як такі, що починаються в робочому ((каталозі)) сервера, тобто в каталозі, в якому його було запущено. Якщо я запустив сервер з `/tmp/public/` (або `C:\tmp\public\` у Windows), то запит до `/file.txt` має посилатися на `/tmp/public/file.txt` (або `C:\tmp\public\file.txt`).

{{index «example of file server», «Node.js», «methods object», «Promise class»}}

Ми будемо збирати програму по частинах, використовуючи об'єкт під назвою `methods` для зберігання функцій, які обробляють різні методи HTTP. Обробники методів - це функції `async`, які отримують об'єкт запиту як аргумент і повертають обіцянку, що перетворюється в об'єкт, який описує відповідь.

```{includeCode: «>code/file_server.mjs"}}
import {createServer} from «node:http»;

const methods = Object.create(null);

createServer((request, response) => {
  let handler = methods[request.method] || notAllowed;
  handler(request).catch(error => {
    if (error.status != null) return error;
    return {body: String(error), status: 500};
  }).then(({body, status = 200, type = «text/plain»}) => {
    response.writeHead(status, {«Content-Type»: type});
    if (body?.pipe) body.pipe(response);
    else response.end(body);
  });
}).listen(8000);

async-функція notAllowed(request) {
  return {}}
    статус: 405,
    body: `Метод ${request.method} не дозволений.
  };
}
```

{{index «405 (код стану HTTP)»}}

Це запускає сервер, який просто повертає відповідь про помилку 405, що є кодом, який використовується для позначення того, що сервер відмовляється обробляти даний метод.

{{index «500 (HTTP status code)», «error handling», «error response»}}

Коли обіцянку обробника запиту відхилено, виклик `catch` переводить помилку в об'єкт відповіді, якщо він ще не є таким, щоб сервер міг відправити назад відповідь про помилку, щоб повідомити клієнту, що він не зміг обробити запит.

{{index «200 (код статусу HTTP)», «Content-Type header»}}

Поле `status` в описі відповіді може бути опущено, у цьому випадку воно за замовчуванням дорівнює 200 (OK). Тип вмісту у властивості `type` також можна не вказувати, у цьому випадку відповідь вважатиметься звичайним текстом.

{{index «end method», «pipe method», stream}}

Якщо значенням `body` є ((потік для читання)), він матиме метод `pipe`, який ми можемо використати для пересилання всього вмісту з потоку для читання до потоку для запису. Якщо ні, то вважається, що це або `null` (без тіла), або рядок, або буфер, і він передається безпосередньо до методу `end` ((response)).

{{index [шлях, URL], «функція urlPath», «клас URL», parsing, [екранування, «в URL»], «функція decodeURIComponent», «метод startsWith»}}

Щоб з'ясувати, який шлях до файлу відповідає URL запиту, функція `urlPath` використовує вбудований клас `URL` (який також існує в браузері) для розбору URL. Цей конструктор очікує повну URL-адресу, а не лише частину, що починається з косої риски, яку ми отримуємо з `request.url`, тому ми даємо йому фіктивне доменне ім'я для заповнення. Він витягує ім'я шляху, яке матиме вигляд `«/file.txt»`, декодує його, щоб позбутися екранних кодів у стилі `%20`, і розв'язує його відносно робочого каталогу програми.

```{includeCode: «>code/file_server.mjs"}{includeCode: “>code/file_server.mjs”}
import {resolve, sep} from «node:path»;

const baseDirectory = process.cwd();

function urlPath(url) {
  let {pathname} = new URL(url, «http://d»);
  let path = resolve(decodeURIComponent(pathname).slice(1));
  if (path != baseDirectory &&
      !path.startsWith(baseDirectory + sep)) {
    throw {status: 403, body: «Forbidden"};
  }
  шлях повернення;
}
```

Як тільки ви налаштували програму на прийом мережевих запитів, ви повинні почати турбуватися про ((безпеку)). У цьому випадку, якщо ми не будемо обережними, є ймовірність того, що ми випадково відкриємо всю нашу ((файлову систему)) для мережі.

Шляхи до файлів - це рядки у Node. Щоб зіставити такий рядок з реальним файлом, потрібно виконати нетривіальну інтерпретацію. Шляхи можуть, наприклад, містити `../` для посилання на батьківський каталог. Очевидним джерелом проблем можуть бути запити для шляхів на кшталт `/../secret_file`.

{{index «node:path package», «resolve function», «cwd function», «process object», «403 (HTTP status code)», «sep binding», [«backslash character», «as path separator»], «slash character»}}

Щоб уникнути таких проблем, `urlPath` використовує функцію `resolve` з модуля `node:path`, яка вирішує відносні шляхи. Потім вона перевіряє, що результат знаходиться _нижче_ робочого каталогу. Функція `process.cwd` (де `cwd` означає _поточний робочий каталог_) може бути використана для пошуку цього робочого каталогу. Зв'язка `ep` з пакунка `node:path` є системним роздільником шляху - зворотна коса риска у Windows і пряма коса риска у більшості інших систем. Якщо шлях не починається з базового каталогу, функція згенерує об'єкт відповіді про помилку, використовуючи код стану HTTP, який вказує на те, що доступ до ресурсу заборонено.

{{index «приклад файлового сервера», «Node.js», «метод GET», [файл, ресурс]}}

Ми налаштуємо метод `GET` на повернення списку файлів при читанні ((каталогу)) і на повернення вмісту файлу при читанні звичайного файлу.

{{index «media type», «Content-Type header», «mime-types package»}}

Одне з складних питань полягає в тому, який саме заголовок `Content-Type` ми повинні встановити при поверненні вмісту файлу. Оскільки ці файли можуть бути чим завгодно, наш сервер не може просто повернути однаковий тип вмісту для всіх файлів. ((NPM)) знову може допомогти нам тут. Пакет `mime-types` (індикатори типу вмісту, такі як `text/plain`, також називаються _((MIME тип))s_) знає правильний тип для великої кількості ((розширення файлу))s.

{{index «npm програма»}}

Наступна команда `npm` у каталозі, де знаходиться серверний скрипт, встановлює певну версію `mime`:

```{lang: null}
$ npm install mime-types@2.1.0
```

{{index «404 (код статусу HTTP)», «stat function», [файл, ресурс]}}

Коли запитуваний файл не існує, правильним кодом статусу HTTP буде 404. Ми будемо використовувати функцію `stat`, яка шукає інформацію про файл, щоб з'ясувати, чи існує файл і чи є він ((каталогом)).

```{includeCode: «>code/file_server.mjs"}}{includeCode: “>code/file_server.mjs”}}
import {createReadStream} from «node:fs»;
import {stat, readdir} from «node:fs/promises»;
import {lookup} from «mime-types»;

methods.GET = async function(request) {
  let path = urlPath(request.url);
  let stats;
  try {
    stats = await stat(path);
  } catch (error) {
    if (error.code != «ENOENT») вивести помилку;
    else return {status: 404, body: «Файл не знайдено"};
  }
  if (stats.isDirectory()) {
    return {body: (await readdir(path)).join(«\n»)};
  } else {
    return {body: createReadStream(path),
            type: lookup(path)};
  }
};
```

{{index «функція createReadStream», [«асинхронне програмування», «у Node.js»], «обробка помилок», «ENOENT (код стану)», «Тип помилки», успадкування}}

Оскільки `stat` має звертатися до диска, що може зайняти деякий час, він є асинхронним. Оскільки ми використовуємо обіцянки, а не стиль зворотного виклику, його слід імпортувати з `node:fs/promises`, а не безпосередньо з `node:fs`.

Якщо файл не існує, `stat` викине об'єкт помилки з властивістю `code`, рівною `«ENOENT»`. За допомогою цих дещо незрозумілих кодів, натхненних ((Unix)), ви розпізнаєте типи помилок у Node.

{{index «Stats type», «stat function», «isDirectory method»}}

Об'єкт `stats`, що повертається функцією `stat`, розповідає нам ряд речей про ((файл)), таких як його розмір (властивість `size`) та його ((дата модифікації)) (властивість `mtime`). Тут нас цікавить питання, чи це ((каталог)) чи звичайний файл, про що нам повідомляє метод `isDirectory`.

{{index «функція readdir»}}

Ми використовуємо `readdir` для читання масиву файлів у ((каталозі)) і повернення його клієнту. Для звичайних файлів ми створюємо потік для читання за допомогою `createReadStream` і повертаємо його як тіло, разом з типом вмісту, який надає нам пакет `mime` для імені файлу.

{{index «Node.js», «приклад файлового сервера», «метод DELETE», «функція rmdir», «функція unlink»}}

Код для обробки запитів `DELETE` трохи простіший.

```{includeCode: «>code/file_server.mjs"}}
import {rmdir, unlink} from «node:fs/promises»;

methods.DELETE = async function(request) {
  let path = urlPath(request.url);
  let stats;
  try {
    stats = await stat(path);
  } catch (error) {
    if (error.code != «ENOENT») вивести помилку;
    else return {status: 204};
  }
  if (stats.isDirectory()) await rmdir(path);
  else wait unlink(path);
  return {status: 204};
};
```

{{index «204 (код статусу HTTP)», «body (HTTP)»}}

Коли ((HTTP)) ((відповідь)) не містить жодних даних, код статусу 204 («немає вмісту») може бути використаний для позначення цього. Оскільки у відповіді на видалення не потрібно передавати жодної інформації, окрім того, чи операція пройшла успішно, доцільно повернути її сюди.

{{index idempotence, «response to error»}}

Вам може бути цікаво, чому спроба видалити неіснуючий файл повертає код статусу успіху, а не помилку. Коли файл, який видаляється, не існує, можна сказати, що мета запиту вже досягнута. Стандарт ((HTTP)) заохочує нас робити запити _ідемпотентними_, що означає, що багаторазове виконання одного і того ж запиту призводить до того ж результату, що  і однократне виконання. У певному сенсі, якщо ви намагаєтеся видалити щось, що вже зникло, ефект, який ви намагалися створити, буде досягнутий - речі більше немає.

{{index «приклад файлового сервера», «Node.js», «метод PUT»}}

Це обробник для запитів `PUT`:

```{includeCode: «>code/file_server.mjs"}}.
імпортуйте {createWriteStream} з «node:fs»;

function pipeStream(from, to) {
  return new Promise((resolve, reject) => {
    from.on(«error», reject);
    to.on(«error», reject);
    to.on(«finish», resolve);
    from.pipe(to);
  });
}

methods.PUT = async function(request) {
  let path = urlPath(request.url);
  wait pipeStream(request, createWriteStream(path));
  return {status: 204};
};
```

{{перезапис індексу, «204 (код стану HTTP)», «подія помилки», «подія завершення», «функція createWriteStream», «метод pipe», stream}}

Цього разу нам не потрібно перевіряти, чи існує файл - якщо він існує, ми просто перезапишемо його. Ми знову використовуємо `pipe` для переміщення даних з потоку для читання у потік для запису, у цьому випадку із запиту у файл. Але оскільки `pipe` написано не для того, щоб повертати обіцянку, ми повинні написати обгортку, `pipeStream`, яка створює обіцянку на основі результату виклику `pipe`.

{{index «error event», «finish event»}}

Якщо під час відкриття файлу щось піде не так, `createWriteStream` все одно поверне потік, але цей потік згенерує подію `«error»`. Потік від запиту також може вийти з ладу - наприклад, якщо мережа впаде. Тому ми об'єднаємо події `error` обох потоків, щоб відхилити обіцянку. Коли `pipe` завершить роботу, він закриє вихідний потік, що спричинить подію `finish`. На цьому етапі ми можемо успішно виконати обіцянку (нічого не повертаючи).

{{index download, «file server example», «Node.js»}}

Повний скрипт для сервера доступний за адресою [_https://eloquentjavascript.net/code/file_server.mjs_](https://eloquentjavascript.net/code/file_server.mjs). Ви можете завантажити його і, встановивши залежності, запустити за допомогою Node, щоб запустити свій власний файловий сервер. І, звичайно, ви можете модифікувати і розширювати його для виконання вправ цієї глави або для експериментів.

{{index «body (HTTP)», «curl program», [HTTP, client], [method, HTTP]}}

Інструмент командного рядка `curl`, широко доступний на ((Unix))-подібних системах (таких як macOS і Linux), можна використовувати для створення HTTP-запитів. У наступному сеансі ми коротко протестуємо наш сервер. Параметр `-X` використовується для встановлення методу запиту, а `-d` використовується для включення тіла запиту.

```{lang: null}
$ curl http://localhost:8000/file.txt
Файл не знайдено
$ curl -X PUT -d CONTENT http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
CONTENT
$ curl -X DELETE http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
Файл не знайдено
```

Перший запит до `file.txt` завершується невдачею, оскільки файл ще не існує. Запит `PUT` створює файл, і ось, наступний запит успішно його отримує. Після видалення його запитом `DELETE` файл знову не знайдено.

## Підсумок

{{index «Node.js»}}

Node - це гарна, невелика система, яка дозволяє запускати JavaScript у небраузерному контексті. Спочатку вона була розроблена для мережевих завдань, щоб грати роль вузла в мережі, але вона підходить для всіх видів скриптових завдань. Якщо вам подобається писати JavaScript, автоматизація завдань за допомогою Node може вам підійти.

NPM надає пакунки для всього, що ви можете собі уявити (і для багатьох речей, про які ви, ймовірно, ніколи б не подумали), і дозволяє вам отримувати і встановлювати ці пакунки за допомогою програми `npm`. Node постачається з низкою вбудованих модулів, зокрема модулем `node:fs` для роботи з файловою системою та модулем `node:http` для запуску HTTP-серверів.

Весь ввід і вивід у Node виконується асинхронно, якщо тільки ви явно не використовуєте синхронний варіант функції, наприклад, `readFileSync`. Спочатку Node використовував зворотні виклики для асинхронної функціональності, але пакет `node:fs/promises` надає інтерфейс до файлової системи, заснований на обіцянках.

## Вправи

### Інструмент пошуку

{{index grep, «проблема пошуку», «інструмент пошуку (вправа)»}}

У системах ((Unix)) існує інструмент командного рядка `grep`, який можна використовувати для швидкого пошуку файлів за ((регулярним виразом)).

Напишіть скрипт Node, який можна запустити з ((командного рядка)) і який діє дещо подібно до `grep`. Він розглядає перший аргумент командного рядка як регулярний вираз, а всі інші аргументи - як файли для пошуку. Вона виводить назви усіх файлів, вміст яких відповідає регулярному виразу.

Коли це спрацює, розширьте його так, щоб коли одним з аргументів є ((каталог)), він шукав усі файли у цьому каталозі та його підкаталогах.

{{index [«асинхронне програмування», «у Node.js»], «синхронне програмування»}}

Використовуйте асинхронні або синхронні функції файлової системи на свій розсуд. Налаштування так, щоб запитувати декілька асинхронних дій одночасно, може дещо прискорити роботу, але не на багато, оскільки більшість файлових систем можуть читати лише один файл за раз.

{{hint

{{index «RegExp class», «інструмент пошуку (вправа)»}}

Ваш перший аргумент командного рядка, ((регулярний вираз)), можна знайти у `process.argv[2]`. Далі йдуть вхідні файли. Ви можете використовувати конструктор `RegExp` для переходу від рядка до об'єкта регулярного виразу.

{{index «функція readFileSync»}}

Зробити це синхронно, за допомогою `readFileSync`, простіше, але якщо використовувати `node:fs/promises` для отримання функцій, що повертають обіцянку, і написати функцію `async`, то код буде схожим.

{{index «stat function», «statSync function», «isDirectory method»}}

Щоб з'ясувати, чи є щось каталогом, можна знову ж таки скористатися функцією `stat` (або `statSync`) і методом `isDirectory` об'єкта stats.

{{index «readdir function», «readdirSync function»}}

Дослідження каталогу - це процес розгалуження. Ви можете зробити це або за допомогою рекурсивної функції, або зберігаючи масив напрацювань (файлів, які ще потрібно дослідити). Щоб знайти файли у каталозі, ви можете викликати `readdir` або `readdirSync`. Зверніть увагу на дивну велику літеру - імена функцій файлової системи Node засновано на стандартних функціях Unix, таких як `readdir`, які пишуться з малої літери, але тут додається `Sync` з великої літери.

Щоб перейти від назви файла, прочитаної за допомогою `readdir`, до повної назви шляху, вам слід поєднати її з назвою каталогу, додавши між ними `ep` з `node:path` або скориставшись функцією `join` з цього ж пакунка.

підказка}}

### Створення каталогу

{{index «приклад файлового сервера», «створення каталогу (вправа)», «функція rmdir»}}

Хоча метод `DELETE` у нашому файловому сервері може видаляти каталоги (за допомогою `rmdir`), наразі сервер не надає жодного способу _створити_ каталог ((каталог)).

{{index «метод MKCOL», «функція mkdir»}}

Додайте підтримку методу `MKCOL` («зробити колекцію»), який має створювати каталог за допомогою виклику `mkdir` з модуля `node:fs`. Метод `MKCOL` не є широко використовуваним HTTP-методом, але він існує для цієї ж мети у стандарті _((WebDAV))_, який визначає набір домовленостей на додаток до ((HTTP)), що робить його придатним для створення документів.

```{hidden: true, includeCode: «>code/file_server.mjs"}}
import {mkdir} from «node:fs/promises»;

methods.MKCOL = async function(request) {
  let path = urlPath(request.url);
  let stats;
  try {
    stats = await stat(path);
  } catch (error) {
    if (error.code != «ENOENT») throw error;
    await mkdir(path);
    return {status: 204};
  }
  if (stats.isDirectory()) return {status: 204};
  else return {status: 400, body: «Не каталог"};
};
```

{{hint

{{index «створення каталогу (вправа)», «приклад файлового сервера», «метод MKCOL», «функція mkdir», idempotency, «400 (код стану HTTP)»}}

Ви можете використати функцію, яка реалізує метод `DELETE`, як зразок для методу `MKCOL`. Якщо файл не знайдено, спробуйте створити каталог за допомогою `mkdir`. Якщо каталог за цим шляхом існує, ви можете повернути відповідь 204, що означає, що запити на створення каталогу є недієздатними. Якщо за цим шляхом існує файл, який не є каталогом, поверніть код помилки. Доречним буде код 400 («поганий запит»).

підказка}}

### Публічний простір у мережі

{{index «public space (exercise)», «file server example», «Content-Type header», website}}

Оскільки файловий сервер обслуговує будь-який тип файлів і навіть містить правильний заголовок `Content-Type`, ви можете використовувати його для обслуговування веб-сайту. Враховуючи, що цей сервер дозволяє будь-кому видаляти і замінювати файли, можна створити цікавий тип веб-сайту: такий, який може бути змінений, покращений і зруйнований будь-ким, хто знайде час, щоб зробити правильний HTTP-запит.

Напишіть базову ((HTML)) сторінку, яка включає простий файл JavaScript. Помістіть файли в каталог, який обслуговується файловим сервером, і відкрийте їх у своєму браузері.

Далі, в якості поглибленої вправи або навіть ((проект вихідного дня)), об'єднайте всі знання, отримані з цієї книги, щоб створити більш зручний інтерфейс для модифікації веб-сайту - "зсередини » веб-сайту.

Використовуйте HTML ((форму)) для редагування вмісту файлів, що складають веб-сайт, дозволяючи користувачеві оновлювати їх на сервері за допомогою HTTP-запитів, як описано в [Розділ ?](http).

Почніть з того, що зробіть редагованим лише один файл. Потім зробіть так, щоб користувач міг вибрати, який файл редагувати. Використовуйте той факт, що наш файловий сервер повертає списки файлів при читанні каталогу.

{{перезапис індексів}}

Не працюйте безпосередньо в коді, який відкриває файловий сервер, оскільки, якщо ви зробите помилку, то, швидше за все, пошкодите файли, які там знаходяться. Замість цього, зберігайте свою роботу поза загальнодоступним каталогом і копіюйте її туди під час тестування.

{{hint

{{index «приклад файлового сервера», «текстова область (HTML-тег)», «функція вибірки», «відносний шлях», «загальнодоступний простір (вправа)»}}

Ви можете створити елемент `<textarea>` для зберігання вмісту файлу, який редагується. Запит `GET`, використовуючи `fetch`, може отримати поточний вміст файлу. Ви можете використовувати відносні URL-адреси, такі як _index.html_, замість [_http://localhost:8000/index.html_](http://localhost:8000/index.html), щоб посилатися на файли на тому ж сервері, що і запущений скрипт.

{{index «форма (HTML-тег)», «подія відправлення», «метод PUT»}}

Потім, коли користувач натисне кнопку (можна використовувати елемент `<form>` і подію `«submit»`), зробіть запит `PUT` до тієї ж URL-адреси, з вмістом області `<textarea>` в якості тіла запиту, щоб зберегти файл.

{{index «select (HTML-тег)», «option (HTML-тег)», «change event»}}

Потім ви можете додати елемент `<select>`, який містить всі файли в топі (каталозі) сервера, додавши до URL-адреси `/` елементи `<option>`, що містять рядки, повернуті `GET`-запитом. Коли користувач вибирає інший файл (подія `«change»` на полі), скрипт повинен отримати і відобразити цей файл. При збереженні файлу використовуйте поточне ім'я файлу.

підказка}}
