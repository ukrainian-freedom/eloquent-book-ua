{{meta {load_files: [«code/journal.js», «code/chapter/04_data.js»], zip: «node/html"}}}}

# Структури даних: Об'єкти та масиви

{{quote {author: «Charles Babbage», title: «Passages from the Life of a Philosopher (1864)», chapter: true}}

Двічі мене запитували: «Скажіть, містере Беббідж, якщо ви введете в машину неправильні цифри, чи будуть на виході правильні відповіді?» [...] Я не в змозі зрозуміти, яка плутанина ідей може спровокувати таке запитання.

quote}}

{{index «Беббідж, Чарльз»}}

{{figure {url: «img/chapter_picture_4.jpg», alt: «Ілюстрація білки поруч з купою книг і парою окулярів. На задньому плані видно місяць і зорі.», “chapter”, “framed” }}}

{{index object, «структура даних»}}

Числа, булеві числа та рядки - це атоми, з яких будуються структури ((даних)). Однак, багато типів інформації потребують більше одного атома. Об'єкти_ дозволяють нам групувати значення, включно з іншими об'єктами, для побудови більш складних структур.

Програми, які ми створювали до цього часу, були обмежені тим, що оперували лише простими типами даних. Вивчивши основи структур даних у цій главі, ви будете знати достатньо, щоб почати писати корисні програми.

У главі розглядатимуться більш-менш реалістичні приклади програмування, які вводять поняття, що застосовуються до проблеми, яка розглядається. Код прикладу часто базуватиметься на функціях і зв'язуваннях, описаних у попередніх розділах книги.

{{if book

Онлайн-пісочниця («пісочниця») для книги ([https://eloquentjavascript.net/code_](https://eloquentjavascript.net/code)) дає змогу виконувати код у контексті певної глави. Якщо ви вирішите опрацювати приклади в іншому середовищі, обов'язково завантажте повний код цієї глави зі сторінки пісочниці.

if}}

## Білка-перевертень

{{index «weresquirrel example», lycanthropy}}

Час від часу, зазвичай між 20:00 та 22:00, ((Жак)) перетворюється на маленького пухнастого гризуна з густим хвостом.

З одного боку, Жак радий, що у нього немає класичної лікантропії. Перетворення на білку спричиняє менше проблем, ніж перетворення на вовка. Замість того, щоб турбуватися про те, що він випадково з'їсть сусіда (_це_ було б незручно), він боїться, що його з'їсть сусідський кіт. Після того, як він двічі прокидався на хиткій тонкій гілці в кроні дуба, голий і дезорієнтований, він почав замикати на ніч двері і вікна своєї кімнати і класти на підлогу кілька волоських горіхів, щоб зайняти себе чимось.

Але Жак волів би повністю позбутися свого стану. Нерегулярні випадки перетворень змушують його підозрювати, що вони можуть бути чимось спровоковані. Деякий час він вважав, що це відбувалося лише в ті дні, коли він перебував біля дубів. Однак уникання дубів не вирішило проблему.

{{індекс журналу}}

Перейшовши до більш наукового підходу, Жак почав вести щоденний журнал, в якому записує все, що він робив у той чи інший день, і чи змінював він форму. За допомогою цих даних він сподівається звузити коло умов, які спричиняють трансформації.

Перше, що йому потрібно - це структура даних для зберігання цієї інформації.

## Набори даних

{{index [«структура даних», колекція], [пам'ять, організація]}}

Щоб працювати з масивом цифрових даних, нам спочатку потрібно знайти спосіб представити їх у пам'яті нашої машини. Скажімо, наприклад, що ми хочемо представити ((колекцію)) чисел 2, 3, 5, 7 та 11.

{{індексний рядок}}

Ми могли б пофантазувати з рядками - зрештою, рядки можуть мати будь-яку довжину, тож ми можемо записати у них багато даних - і використати `«2 3 5 7 11»` як наше представлення. Але це незручно. Нам доведеться якось витягувати цифри і перетворювати їх назад у числа, щоб отримати до них доступ.

{{index [масив, твір], «[] (масив)»}}

На щастя, JavaScript надає тип даних спеціально для зберігання послідовностей значень. Він називається _масив_ і записується як список значень між ((квадратними дужками)), розділених комами.

```
нехай listOfNumbers = [2, 3, 5, 7, 11];
console.log(listOfNumbers[2]);
// → 5
console.log(listOfNumbers[0]);
// → 2
console.log(listOfNumbers[2 - 1]);
// → 3
```

{{index «[] (підрядковий індекс)», [масив, індексація]}}

У позначенні доступу до елементів всередині масиву також використовується ((квадратні дужки)). Пара квадратних дужок одразу після виразу з іншим виразом усередині них шукатиме елемент у лівому виразі, який відповідає _((індекс))_, заданому виразом у дужках.

{{id array_indexing}}
{{index «відлік з нуля»}}

Перший індекс масиву дорівнює нулю, а не одиниці, тому перший елемент отримується за допомогою `listOfNumbers[0]`. Нульовий відлік має давню традицію в технологіях і певним чином має великий сенс, але до нього потрібно звикнути. Подумайте про індекс як про кількість елементів, які слід пропустити, рахуючи від початку масиву.

{{id properties}}

## Властивості

{{index «математичний об'єкт», «функція Math.max», [«властивість довжини», «для рядка»], [об'єкт, властивість], «символ крапки», [властивість, доступ]}}

У попередніх розділах ми бачили декілька виразів на кшталт `myString.length` (для отримання довжини рядка) та `Math.max` (максимальна функція). Ці вирази отримують доступ до _властивості_ деякого значення. У першому випадку ми отримуємо доступ до властивості `length` значення у `myString`. У другому випадку ми отримуємо доступ до властивості `max` об'єкта `Math` (який є колекцією констант і функцій, пов'язаних з математикою).

{{index [властивість, доступ], null, undefined}}

Майже всі значення JavaScript мають властивості. Винятками є `null` та `undefined`. Якщо ви спробуєте отримати доступ до властивості для одного з цих не-значень, ви отримаєте помилку:

```{test: no}
null.length;
// → TypeError: null не має властивостей
```

{{indexsee «символ крапки», «символ крапки»}}
{{індекс «[] (підрядковий)», «символ крапки», «квадратні дужки», «обчислювана властивість», [властивість, доступ]}}

Два основних способи доступу до властивостей у JavaScript - це крапка та квадратні дужки. І `value.x`, і `value[x]` отримують доступ до властивості на `value` - але не обов'язково до тієї самої властивості. Різниця полягає у тому, як інтерпретується `x`. При використанні крапки, слово після крапки є буквальною назвою властивості. При використанні квадратних дужок вираз між дужками _обчислюється_, щоб отримати назву властивості. Тоді як `value.x` отримує властивість `value` з іменем «x», `value[x]` бере значення змінної з іменем `x` і використовує його, перетворене у рядок, як назву властивості.

Якщо ви знаєте, що властивість, яка вас цікавить, називається _color_, ви пишете `value.color`. Якщо ви хочете отримати властивість, названу за значенням, що міститься у прив'язці `i`, ви пишете `value[i]`. Назви властивостей є рядками. Це може бути будь-який рядок, але крапкова нотація працює лише з іменами, які виглядають як правильні імена прив'язок - починаються з літери або символу підкреслення і містять лише літери, цифри та символи підкреслення. Якщо ви хочете отримати доступ до властивості з іменем _2_ або _John Doe_, ви повинні використовувати квадратні дужки: `value[2]` або `value[«John Doe»]`.

Елементи у ((масиві)) зберігаються як властивості масиву, використовуючи числа як імена властивостей. Оскільки ви не можете використовувати крапкові позначення для чисел і зазвичай хочете використовувати прив'язку, яка утримує індекс, вам доведеться використовувати дужкові позначення, щоб дістатися до них.

{{index [«властивість довжини», «для масиву»], [масив, «довжина»]}}

Подібно до рядків, масиви мають властивість `length`, яка показує, скільки елементів має масив.

{{id methods}}

## Методи

{{index [функція, «як властивість»], метод, рядок}}

Значення рядків та масивів містять, окрім властивості `length`, ряд властивостей, які зберігають значення функцій.

```
нехай doh = «Doh»;
console.log(typeof doh.toUpperCase);
// → функція
console.log(doh.toUpperCase());
// → DOH
```

{{індекс «перетворення регістру», «метод toUpperCase», «метод toLowerCase»}}

Кожен рядок має властивість `toUpperCase`. При виклику вона повертає копію рядка, в якому всі літери було перетворено у верхній регістр. Існує також метод `toLowerCase`, який працює у зворотному напрямку.

{{index «this binding»}}

Цікаво, що хоча виклик `toUpperCase` не передає жодних аргументів, функція якимось чином має доступ до рядка `«Doh»`, значення, властивість якого ми викликали. Ви дізнаєтесь, як це працює у [Глава ?](об'єкт#методи_об'єкта).

Властивості, що містять функції, зазвичай називаються _методами_ значення, до якого вони належать, як у «`toUpperCase` є методом рядка».

{{id array_methods}}

У цьому прикладі продемонстровано два методи, які можна використовувати для маніпулювання масивами.

```
let sequence = [1, 2, 3];
sequence.push(4);
sequence.push(5);
console.log(sequence);
// → [1, 2, 3, 4, 5]
console.log(sequence.pop());
// → 5
console.log(sequence);
// → [1, 2, 3, 4]
```

{{index collection, array, «метод push», «метод pop»}}

Метод `push` додає значення в кінець масиву. Метод `pop` робить навпаки, видаляє останнє значення з масиву і повертає його.

{{index [«структура даних», стек]}}

Ці дещо безглузді назви є традиційними термінами для операцій над  стеком _((stack))_. Стек у програмуванні - це структура даних, яка дозволяє записувати в неї значення і витягувати їх у зворотному порядку, так що те, що було додано останнім, видаляється першим. Стеки дуже поширені у програмуванні - ви можете згадати функцію ((викликати стек)) з [попередньої глави](функції#стек), яка є прикладом тієї ж самої ідеї.

## Об'єкти

{{index journal, «weresquirrel example», array, record}}

Повернемося до weresquirrel. Набір щоденних записів журналу можна представити у вигляді масиву, але записи не складаються з одного числа або рядка - кожен запис повинен зберігати список дій і булеве значення, яке вказує, чи перетворився Жак на білку, чи ні. В ідеалі, ми хотіли б згрупувати ці дані в одне значення, а потім помістити ці згруповані значення у масив записів журналу.

{{індекс [синтаксис, об'єкт], [властивість, визначення], [дужки, об'єкт], «{} (об'єкт)»}}

Значення типу _((об'єкт))_ є довільними колекціями властивостей. Одним із способів створення об'єкта є використання фігурних дужок як виразу.

```
let day1 = {
  squirrel: false,
  events: [«робота», «торкнулася дерева», «піца», «біг»]
};
console.log(day1.squirrel);
// → false
console.log(day1.wolf);
// → undefined
day1.wolf = false;
console.log(day1.wolf);
// → false
```

{{index [цитування, «властивостей об'єкта»], «двокрапка»}}

Усередині фігурних дужок ви пишете список властивостей, розділених комами. Кожна властивість має назву, за якою слідує двокрапка і значення. Якщо об'єкт записано у декількох рядках, відступи, як показано у цьому прикладі, допомагають зробити його більш читабельним. Властивості, назви яких не є допустимими іменами прив'язок або допустимими числами, слід брати у лапки:

```
let descriptions = {
  work: «Пішов на роботу»,
  «торкнувся дерева": «Торкнувся дерева»
};
```

{{index [дужки, об'єкт]}}

Це означає, що фігурні дужки мають _два_ значення у JavaScript. На початку ((оператора)) вони починають ((блок)) операторів. У будь-якій іншій позиції вони описують об'єкт. На щастя, рідко буває корисно починати оператор з об'єкта в дужках, тому неоднозначність між цими двома значеннями не є великою проблемою. Єдиний випадок, коли вона виникає, це коли ви хочете повернути об'єкт зі скороченої стрілочної функції - ви не можете написати `n => {prop: n}`, оскільки дужки буде інтерпретовано як тіло функції. Замість цього вам слід взяти об'єкт у круглі дужки, щоб було зрозуміло, що він є виразом.

{{index undefined}}

Читання неіснуючої властивості призведе до отримання значення `undefined`.

{{індекс [властивість, присвоєння], мінливість, «= оператор»}}

Можна присвоїти значення виразу властивості за допомогою оператора `=`. Це замінить значення властивості, якщо воно вже існувало, або створить нову властивість на об'єкті, якщо воно не існувало.

{{індекс «щупальце (аналогія)», [властивість, «модель з»], [прив'язка, «модель з»]}}

Якщо коротко повернутися до нашої моделі щупальця ((зв'язування))s-властивостей, то зв'язування подібні. Вони _хоплять_ значення, але інші зв'язки та властивості можуть утримувати ті самі значення. Ви можете уявити об'єкти як восьминогів з довільною кількістю щупалець, на кожному з яких записано ім'я.

{{index «оператор видалення», [властивість, видалення]}}

Оператор `delete` відрізає щупальце від такого восьминога. Це унарний оператор, який при застосуванні до властивості об'єкта видаляє названу властивість з об'єкта. Це не дуже поширена дія, але вона можлива.

```
нехай anObject = {left: 1, right: 2};
console.log(anObject.left);
// → 1
видалити anObject.left;
console.log(anObject.left);
// → невизначено
console.log(«left» в anObject);
// → false
console.log(«right» in anObject);
// → true
```

{{індекс «оператор in», [властивість, «перевірка на»], об'єкт}}

Бінарний оператор `in`, застосовуючись до рядка та об'єкта, повідомляє, чи має цей об'єкт властивість з такою назвою. Різниця між встановленням властивості у значення `undefined` та її видаленням полягає у тому, що у першому випадку об'єкт все ще _має_ властивість (просто вона має не дуже цікаве значення), тоді як у другому випадку властивість більше не існує і `in` поверне `false`.

{{index «Object.keys function»}}

Щоб дізнатися, які властивості має об'єкт, можна скористатися функцією `Object.keys`. Передайте функції об'єкт, і вона поверне масив рядків - назви властивостей об'єкта:

```
console.log(Object.keys({x: 0, y: 0, z: 2}));
// → [«x», «y», «z»]
```

Існує функція `Object.assign`, яка копіює всі властивості з одного об'єкта в інший:

```
нехай objectA = {a: 1, b: 2};
Object.assign(objectA, {b: 3, c: 4});
console.log(objectA);
// → {a: 1, b: 3, c: 4}
```

{{індексний масив, колекція}}

Отже, масиви - це просто різновид об'єктів, що спеціалізуються на зберіганні послідовностей речей. Якщо ви обчислюєте `typeof []`, то отримуєте `«об'єкт»`. Ви можете візуалізувати масиви у вигляді довгих пласких восьминогів з усіма щупальцями, витягнутими в акуратний ряд і позначеними числами.

{{index journal, «weresquirrel example»}}

Журнал, який веде Жак, буде представлено у вигляді масиву об'єктів:

```{test: wrap}
let journal = [
  {events: [«робота», «торкнувся дерева», «піца»,
            «біг», “телевізор”],
   squirrel: false},
  {events: [«робота», «морозиво», «цвітна капуста»,
            «лазанья», “торкнувся дерева”, “почистив зуби”],
   squirrel: false},
  {events: [«вихідні», «катання на велосипеді», «перерва», «арахіс»,
            «пиво"],
   squirrel: true},
  /* І так далі... */
];
```

## Мутабельність

Незабаром ми перейдемо до власне програмування, але спочатку нам потрібно зрозуміти ще одну частину теорії.

{{індексна змінюваність, «побічний ефект», число, рядок, булевий, [об'єкт, змінюваність]}}

Ми бачили, що значення об'єктів можна змінювати. Типи значень, про які йшлося у попередніх розділах, такі як числа, рядки та булеві типи, є _((незмінними))_- значення цих типів неможливо змінити. Ви можете комбінувати їх і отримувати з них нові значення, але коли ви берете конкретне значення рядка, це значення завжди залишатиметься незмінним. Текст всередині нього не може бути змінений. Якщо у вас є рядок, який містить `«cat»`, інший код не зможе змінити символ у вашому рядку так, щоб він писався як `«rat»`.

Об'єкти працюють по-іншому. Ви _можете_ змінювати їхні властивості, що призводить до того, що одне значення об'єкта може мати різний вміст у різний час.

{{індекс [об'єкт, ідентичність], ідентичність, [пам'ять, організація], мінливість}}

Коли ми маємо два числа, 120 і 120, ми можемо вважати їх одним і тим самим числом, незалежно від того, чи відносяться вони до одних і тих самих фізичних бітів, чи ні. У випадку з об'єктами існує різниця між двома посиланнями на один і той самий об'єкт і двома різними об'єктами, які містять однакові властивості. Розглянемо наступний код:

```
let object1 = {значення: 10};
let object2 = object1;
let object3 = {значення: 10};

console.log(object1 == object2);
// → true
console.log(object1 == object3);
// → false

object1.value = 15;
console.log(object2.value);
// → 15
console.log(object3.value);
// → 10
```

{{index «tentacle (аналогія)», [binding, «model of»]}}

Зв'язки `об'єкт1` та `об'єкт2` схоплюють один і той  самий об'єкт, тому при зміні `об'єкта1` змінюється і значення `об'єкта2`. Кажуть, що вони мають однакову _ідентичність_. Зв'язка `об'єкт3` вказує на інший об'єкт, який спочатку містить ті ж властивості, що й `об'єкт1`, але живе окремим життям.

{{індекс «ключове слово const», «ключове слово let», [прив'язка, «як стан»]}}

Зв'язки також можуть бути змінними або постійними, але це не впливає на поведінку їхніх значень. Навіть якщо значення чисел не змінюються, ви можете використовувати прив'язку `let`, щоб відстежувати зміну числа, змінюючи значення, на яке вказує прив'язка. Аналогічно, хоча прив'язка `const` до об'єкта сама по собі не може бути змінена і продовжуватиме вказувати на той самий об'єкт, _вміст_ цього об'єкта може змінитися.

```{test: no}
const score = {visitors: 0, home: 0};
// Це нормально
score.visitors = 1;
// Так не можна
score = {visitors: 1, home: 1};
```

{{index «== operator», [comparison, «of objects»], «deep comparison»}}

Коли ви порівнюєте об'єкти за допомогою оператора `==` у JavaScript, він порівнює їх за тотожністю: він видасть значення `true` лише у тому випадку, якщо обидва об'єкти мають однакове значення. Порівняння різних об'єктів поверне значення `false`, навіть якщо вони мають ідентичні властивості. У JavaScript немає вбудованої операції «глибокого» порівняння, яка порівнює об'єкти за вмістом, але її можна написати самостійно (це одна з [вправ](data#вправа_глибоке_порівняння) в кінці цього розділу).

## Журнал лікантропа

{{index «weresquirrel example», lycanthropy, «addEntry function»}}

Жак запускає свій інтерпретатор JavaScript і налаштовує середовище, необхідне для ведення свого ((журналу)):

```{includeCode: true}
let journal = [];

function addEntry(events, squirrel) {
  journal.push({events, squirrel});
}
```

{{індекс [дужки, об'єкт], «{} (об'єкт)», [властивість, визначення]}}

Зверніть увагу, що доданий до журналу об'єкт виглядає дещо дивно. Замість оголошення властивостей на кшталт `events: events`, він просто дає назву властивості: `events`. Це скорочення, яке означає те саме - якщо після імені властивості у дужках не вказано значення, його значення береться з однойменного зв'язування.

Щовечора о 22:00, а іноді й наступного ранку, спустившись з верхньої полиці книжкової шафи, Жак записує день:

```
addEntry([«робота», «торкнувся дерева», «піца», «біг»,
          «телевізор"], false);
addEntry([«робота», «морозиво», «цвітна капуста», «лазанья»,
          «торкнувся ялинки», “почистив зуби”], false);
addEntry([«вихідні», «їзда на велосипеді», «перерва», «арахіс»,
          «пиво"], true);
```

Після того, як у нього буде достатньо точок даних, він має намір використати статистику, щоб з'ясувати, які з цих подій можуть бути пов'язані з білками.

{{Індексна кореляція}}

Кореляція - це міра ((залежності)) між статистичними змінними. Статистична змінна - це не зовсім те саме, що програмна змінна. У статистиці ви зазвичай маєте набір _вимірювань_, і кожна змінна вимірюється для кожного вимірювання. Кореляція між змінними зазвичай виражається значенням, яке знаходиться в діапазоні від -1 до 1. Нульова кореляція означає, що змінні не пов'язані між собою. Кореляція, що дорівнює 1, вказує на те, що вони ідеально пов'язані - якщо ви знаєте одну змінну, ви також знаєте й іншу. Від'ємне значення 1 також означає, що змінні ідеально пов'язані, але є протилежними - коли одна з них істинна, інша хибна.

{{індекс «фі-коефіцієнт»}}

Для обчислення міри кореляції між двома булевими змінними можна використати _фі-коефіцієнт_ (_ϕ_). Це формула, на вхід якої подається ((таблиця частот)), що містить кількість разів, коли спостерігалися різні комбінації змінних. Виходом формули є число від -1 до 1, яке описує кореляцію.

Ми могли б взяти подію поїдання ((піци)) і помістити її в таку таблицю частот, де кожне число вказує на кількість разів, коли ця комбінація зустрічалася в наших вимірах.

{{figure {url: «img/pizza-squirrel.svg», alt: «Таблиця два на два, де по горизонталі відкладено змінну піца, а по вертикалі - змінну білка. Кожна клітинка показує, скільки разів зустрічалася ця комбінація. У 76 випадках не трапилося жодної з них. У 9 випадках правдивою була лише піца. У 4 випадках - тільки білка. І в одному випадку з'явилися обидва варіанти.», width: “7cm”}}}.

Якщо ми назвемо цю таблицю _n_, ми можемо обчислити _ϕ_ за наступною формулою:

{{if html

<div> <table style=«border-collapse: collapse; margin-left: 1em;»><tr> <td style=«vertical-align: middle»><em>ϕ</em> =</td> <td style=«padding-left: .5em»> <div style="border-bottom: 1px solid black; padding: 0 7px;«><em>n</em><sub>11</sub><em>n</em><sub>00</sub> - <em>n</em><sub>10</sub><em>n</em><sub>01</sub></div> <div style=»padding: 0 7px;«>√<span style=»border-top: 1px solid black; position: relative; top: 2px;«><span style=»position: relative; top: -4px"><em>n</em><sub>1-</sub><em>n</em><sub>0-</sub><em>n</em><sub>-1</sub><em>n</em><sub>-0</sub></span> </span></div></div> </td> </tr></table> </div> </div></table

if}}

{{if tex

[\begin{equation}\varphi = \frac{n_{11}n_{00}-n_{10}n_{01}}{\sqrt{n_{1\bullet}n_{0\bullet}n_{\bullet1}n_{\bullet0}}}\end{equation}]{latex}

if}}

(Якщо в цей момент ви відкладаєте книгу, щоб зосередитися на жахливому спогаді про урок математики в 10-му класі - зачекайте! Я не маю наміру мучити вас нескінченними сторінками загадкових позначень - поки що це лише одна формула. І навіть з нею все, що ми робимо, це перетворюємо її на JavaScript).

Запис [_n_~01~]{if html}[[$n_{01}$]{latex}]{if tex} вказує на кількість вимірів, де перша змінна (squirrelness) дорівнює false (0), а друга змінна (pizza) - true (1). У таблиці піци [_n_~01~]{if html}[[$n_{01}$]{latex}]{if tex} дорівнює 9.

Значення [_n_~1-~]{if html}[[$n_{1\bullet}$]{latex}]{if tex} відноситься до суми всіх вимірів, де перша змінна дорівнює true, що у прикладі таблиці дорівнює 5. Аналогічно, [_n_~-0~]{if html}[[$n_{\bullet0}$]{latex}]{if tex} позначає суму вимірів, де друга змінна є хибною.

{{індексна кореляція, «фі-коефіцієнт»}}

Отже, для столу з піцою частина над лінією поділу (дільник) буде 1×76-4×9 = 40, а частина під нею (дільник) буде квадратним коренем з 5×85×10×80, або [√340,000]{if html}[[$\sqrt{340,000}$]{latex}]{if tex}. Виходить _ϕ_ ≈ 0.069, що дуже мало. Вживання їжі ((піци)), схоже, не впливає на перетворення.

## Обчислення кореляції

{{index [array, «as table»], [nesting, «of arrays»]}}

Ми можемо представити два на два ((таблицю)) у JavaScript масивом з чотирьох елементів (`[76, 9, 4, 1]`). Ми також можемо використовувати інші представлення, такі як масив, що містить два двоелементних масиви (`[[76, 9], [4, 1]]`) або об'єкт з іменами властивостей типу `«11»` і `«01»`, але плаский масив є простим і робить вирази, які отримують доступ до таблиці, приємно короткими. Ми будемо інтерпретувати індекси масиву як two-((біт)) ((двійкове число))s, де крайня ліва (старша) цифра відноситься до змінної squirrel, а крайня права (молодша) цифра відноситься до змінної event. Наприклад, двійкове число `10` означає випадок, коли Жак перетворився на білку, але подія (скажімо, «піца») не відбулася. Це сталося чотири рази. А оскільки двійкове число `10` дорівнює 2 у десятковій системі числення, ми будемо зберігати це число під індексом 2 масиву.

{{index «phi коефіцієнт», «phi функція»}}

{{id phi_function}}

Це функція, яка обчислює коефіцієнт _ϕ_ з такого масиву:

```{includeCode: strip_log, test: clip}
function phi(table) {
  return (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt((table[2] + table[3]) *
              (table[0] + table[1]) *
              (table[1] + table[3]) *
              (table[0] + table[2]));
}

console.log(phi([76, 9, 4, 1]));
// → 0.068599434
```

{{index «square root», «Math.sqrt function»}}

Це прямий переклад формули _ϕ_ на JavaScript. `Math.sqrt` - це функція квадратного кореня, що надається об'єктом `Math` у стандартному середовищі JavaScript. Ми повинні додати два поля з таблиці, щоб отримати поля типу [n~1-~]{if html}[[$n_{1\bullet}$]{latex}]{if tex}, оскільки суми рядків або стовпців не зберігаються безпосередньо в нашій структурі даних.

{{index «JOURNAL dataset»}}

Жак веде свій щоденник протягом трьох місяців. Результуючий ((набір даних)) доступний у [пісочниці кодування](https://eloquentjavascript.net/code#4) для цієї глави [[https://eloquentjavascript.net/code#4_](https://eloquentjavascript.net/code#4))]{if book}, де він зберігається у прив'язці `JOURNAL`, а також у завантажуваному [файлі](https://eloquentjavascript.net/code/journal.js).

{{index «tableFor function»}}

Щоб витягти з журналу таблицю два на два ((таблицю)) для певної події, ми повинні перебрати всі записи і підрахувати, скільки разів ця подія зустрічається відносно білкових перетворень:

```{includeCode: strip_log}
function tableFor(event, journal) {
  let table = [0, 0, 0, 0, 0];
  for (let i = 0; i < journal.length; i++) {
    let entry = journal[i], index = 0;
    if (entry.events.includes(event)) index += 1;
    if (entry.squirrel) index += 2;
    table[index] += 1;
  }
  повернути таблицю;
}

console.log(tableFor(«pizza», JOURNAL));
// → [76, 9, 4, 1]
```

{{index [масив, пошук], «includes метод»}}

Масиви мають метод `includes`, який перевіряє, чи існує задане значення в масиві. Функція використовує цей метод, щоб визначити, чи є назва події, яка її цікавить, у списку подій на певний день.

{{index [масив, індексація]}}

Тіло циклу в `tableFor` з'ясовує, до якої комірки в таблиці потрапляє кожен запис журналу, перевіряючи, чи містить цей запис конкретну подію, яка його цікавить, і чи відбувається ця подія разом з інцидентом з білкою. Потім цикл додає одиницю до відповідної клітинки в таблиці.

Тепер у нас є інструменти, необхідні для обчислення індивідуальних ((кореляцій)). Єдиний крок, що залишився - знайти кореляцію для кожного типу подій, що були записані, і подивитися, чи не виділяється щось особливе.

{{id for_of_loop}}

## Цикли з масивами

{{index «for loop», loop, [array, iteration]}}

У функції `tableFor` є такий цикл:

```
for (let i = 0; i < JOURNAL.length; i++) {
  let entry = JOURNAL[i];
  // Зробити щось з entry
}
```

Цей тип циклу є поширеним у класичному JavaScript - перебір масивів по одному елементу за раз є чимось, що часто зустрічається, і для цього вам доведеться запускати лічильник довжини масиву і вибирати кожен елемент по черзі.

У сучасному JavaScript є простіший спосіб написання таких циклів:

```
for (let entry of JOURNAL) {
  console.log(`${entry.events.length} events.`);
}
```

{{індекс «for/of циклу»}}

Коли цикл `for` використовує слово `of` після визначення змінної, він буде перебирати елементи значення, вказаного після `of`. Це працює не тільки для масивів, але й для рядків та деяких інших структур даних. Ми обговоримо _як_ це працює у [Розділ ?](об'єкт).

{{id аналіз}}

## Остаточний аналіз

{{index journal, «weresquirrel example», «journalEvents function»}}

Нам потрібно обчислити кореляцію для кожного типу подій, які трапляються у наборі даних. Для цього нам спочатку потрібно _знайти_ кожен тип подій.

{{index «includes method», «push method»}}

```{includeCode: «strip_log"}} ```{includeCode: “strip_log”}
function journalEvents(journal) {
  let events = [];
  for (let entry of journal) {
    for (let event of entry.events) {
      if (!events.includes(event)) {
        events.push(event);
      }
    }
  }
  повертає події;
}

console.log(journalEvents(JOURNAL));
// → [«морква», «вправи», «вихідні», «хліб», ...]
```

Додаючи до масиву `events` будь-які назви подій, яких там ще немає, функція збирає всі типи подій.

Використовуючи цю функцію, ми можемо побачити всі ((кореляції))и:

```{test: no}
for (let event of journalEvents(JOURNAL)) {
  console.log(event + «:», phi(tableFor(event, JOURNAL));
}
// → carrot: 0.0140970969
// → exercise: 0.0685994341
// → weekend:  0.1371988681
// → хліб: -0.0757554019
// → пудинг: -0.0648203724
// І так далі...
```

Більшість кореляцій, схоже, близькі до нуля. Поїдання моркви, хліба чи пудингу, очевидно, не викликає білкоподібної лікантропії. Трансформації , здається, відбуваються дещо частіше на вихідних. Давайте відфільтруємо результати, щоб показати лише кореляції, більші за 0.1 або менші за -0.1:

```{test: no, startCode: true}
for (let event of journalEvents(JOURNAL)) {
  let correlation = phi(tableFor(event, JOURNAL));
  if (correlation > 0.1 || correlation < -0.1) {
    console.log(event + «:», correlation);
  }
}
// → вихідні:        0.1371988681
// → почищені зуби: -0.3805211953
// → цукерки: 0.1296407447
// → робота: -0.1371988681
// → спагеті: 0.2425356250
// → читання:        0.1106828054
// → арахіс: 0.5902679812
```

Ага! Є два фактори з ((кореляція)), які явно сильніші за інші. Вживання ((арахісу)) має сильний позитивний вплив на шанс перетворитися на білку, тоді як чищення зубів має значний негативний вплив.

Цікаво. Давай спробуємо.

```
for (let entry of JOURNAL) {
  if (entry.events.includes(«peanuts») &&
     !entry.events.includes(«почищені зуби»)) { } }
    entry.events.push(«peanuts teeth»);
  }
}
console.log(phi(tableFor(«peanut teeth», JOURNAL)));
// → 1
```

Це сильний результат. Явище відбувається саме тоді, коли Жак їсть ((арахіс)) і не чистить зуби. Якби він не був таким недбайливим щодо гігієни зубів, він би навіть не помітив своєї недуги.

Усвідомивши це, Жак припиняє їсти арахіс і виявляє, що його перетворення зупинилися.

{{index «weresquirrel example»}}

Але минає лише кілька місяців, і він помічає, що чогось не вистачає в цьому цілком людському способі життя. Без своїх здичавілих пригод Жак навряд чи відчуває себе живим. Він вирішує, що краще бути диким звіром на повну ставку. Побудувавши в лісі гарний будиночок на дереві, обладнавши його дозатором для арахісового масла та десятирічним запасом арахісового масла, він востаннє змінює форму і починає жити коротким та енергійним життям білки.

## Подальша теорія масивів

{{index [масив, методи], [метод, масив]}}

Перш ніж закінчити розділ, я хочу познайомити вас з деякими іншими поняттями, пов'язаними з об'єктами. Я почну з деяких загальновживаних методів роботи з масивами.

{{index «метод push», «метод pop», «метод shift», «метод unshift»}}

Раніше у цій главі ми розглядали методи `push` і `pop`, які додають і видаляють елементи в кінці масиву [раніше] (data#array_methods). Відповідні методи для додавання та видалення елементів на початку масиву називаються `unshift` та `shift`.

```
let todoList = [];
function remember(task) {
  todoList.push(task);
}
function getTask() {
  return todoList.shift();
}
function rememberUrgently(task) {
  todoList.unshift(task);
}
```

{{index «приклад керування завданнями»}}

Ця програма керує чергою завдань. Ви додаєте завдання в кінець черги викликом `remember(«groceries»)`, а коли ви готові щось зробити, викликаєте `getTask()`, щоб отримати (і видалити) перший елемент з черги. Функція `rememberUrgently` також додає завдання, але додає його на початок, а не в кінець черги.

{{index [масив, пошук], «indexOf method», «lastIndexOf method»}}

Для пошуку певного значення в масивах передбачено метод `indexOf`. Метод здійснює пошук у масиві від початку до кінця і повертає індекс, за яким було знайдено шукане значення, або -1, якщо його не було знайдено. Для пошуку з кінця, а не з початку, існує аналогічний метод, який називається `lastIndexOf`:

```
console.log([1, 2, 3, 2, 1].indexOf(2));
// → 1
console.log([1, 2, 3, 2, 1].lastIndexOf(2));
// → 3
```

І `indexOf`, і `lastIndexOf` приймають необов'язковий другий аргумент, який вказує, де починати пошук.

{{index «метод зрізу», [масив, індексування]}}

Іншим фундаментальним методом роботи з масивами є `slice`, який отримує початковий та кінцевий індекси і повертає масив, що містить лише елементи між ними. Початковий індекс є інклюзивним, а кінцевий - ексклюзивним.

```
console.log([0, 1, 2, 3, 4].slice(2, 4));
// → [2, 3]
console.log([0, 1, 2, 3, 4].slice(2));
// → [2, 3, 4]
```

{{index [рядок, індексація]}}

Якщо кінцевий індекс не вказано, ``slice` візьме всі елементи після початкового індексу. Ви також можете опустити початковий індекс, щоб скопіювати весь масив.

{{індексна конкатенація, «метод concat»}}

Метод `concat` можна використовувати для додавання масивів разом для створення нового масиву, подібно до того, як це робить оператор `+` для рядків.

У наступному прикладі показано як `concat`, так і `lice` у дії. Він отримує масив та індекс і повертає новий масив, який є копією вихідного масиву з вилученим елементом за вказаним індексом:

```
функція remove(масив, індекс) {
  return array.slice(0, index)
    .concat(array.slice(index + 1));
}
console.log(remove([«a», «b», «c», «d», «e»], 2));
// → [«a», «b», «c», «d», «e»]
```

Якщо передати `concat` аргумент, який не є масивом, це значення буде додано до нового масиву так, як якщо б це був одноелементний масив.

## Рядки та їх властивості

{{index [рядок, властивості]}}

Ми можемо читати властивості типу `length` та `toUpperCase` зі значень рядків. Але якщо ми спробуємо додати нову властивість, вона не буде додана.

```
нехай kim = «Кім»;
kim.age = 88;
console.log(kim.age);
// → undefined
```

Значення типу string, number та Boolean не є об'єктами, і хоча мова не скаржиться, якщо ви намагаєтеся встановити для них нові властивості, насправді вона не зберігає ці властивості. Як згадувалося раніше, такі значення є незмінними і не можуть бути змінені.

{{index [рядок, методи], «метод зрізу», «індекс методу», [рядок, пошук]}}

Але ці типи мають вбудовані властивості. Кожне значення рядка має ряд методів. Дуже корисними з них є `lice` та `indexOf`, які нагадують однойменні методи роботи з масивами:

```
console.log(«coconuts».slice(4, 7));
// → горіх
console.log(«coconut».indexOf(«u»));
// → 5
```

Однією з відмінностей є те, що `indexOf` рядка може шукати рядок, що містить більше одного символу, тоді як відповідний метод масиву шукає лише один елемент:

```
console.log(«one two three».indexOf(«ee»));
// → 11
```

{{index [пробіли, обрізання], «метод обрізання»}}

Метод `trim` видаляє пробіли (пробіли, нові рядки, табуляції та подібні символи) з початку та кінця рядка:

```
console.log(» okay \n ».trim());
// → okay
```

{{id padStart}}

Функція `zeroPad` з [попереднього розділу](функції) також існує у вигляді методу. Вона називається `padStart` і приймає бажану довжину та символ пробілу як аргументи:

```
console.log(String(6).padStart(3, «0»));
// → 006
```

{{id split}}

{{index «метод розбиття»}}

Ви можете розбивати рядок при кожному входженні іншого рядка за допомогою ``split`` і знову приєднувати його за допомогою ``join``:

```
let sentence = «Секретарські пташки спеціалізуються на тупотінні»;
let words = sentence.split(» »);
console.log(words);
// → [«Секретарські пташки», «спеціалізуються», «на», «тупотінні»].
console.log(words.join(». »));
// → Секретарські пташки. спеціалізуються. на. тупотінні
```

{{index «repeat method»}}

Рядок можна повторити за допомогою методу `repeat`, який створює новий рядок, що містить декілька копій початкового рядка, склеєних між собою:

```
console.log(«LA».repeat(3));
// → LALALA
```

{{index [«властивість довжини», «для рядка»], [рядок, індексація]}}

Ми вже бачили властивість `length` типу string. Доступ до окремих символів у рядку схожий на доступ до елементів масиву (з ускладненням, яке ми обговоримо у [Глава ?](вищий_порядок#кодові_одиниці)).

```
let string = «abc»;
console.log(string.length);
// → 3
console.log(string[1]);
// → b
```

{{id rest_parameters}}

## Решта параметрів

{{index «Math.max функція», «символ крапки», «max приклад», spread, [array, «of rest arguments»]}}

Для функції може бути корисно приймати будь-яку кількість ((аргументів)). Наприклад, `Math.max` обчислює максимальне значення _всіх_ аргументів, які їй надано. Щоб записати таку функцію, ви ставите три крапки перед останнім ((параметром)) функції, ось так:

```{includeCode: strip_log}
function max(...numbers) {
  let result = -Infinity;
  for (let number of numbers) {
    if (number > result) result = number;
  }
  return result;
}
console.log(max(4, 1, 9, -2));
// → 9
```

Коли викликається така функція, _((решта параметрів))_ прив'язується до масиву, що містить усі подальші аргументи. Якщо перед нею є інші параметри, їхні значення не входять до цього масиву. Коли, як у `max`, це єдиний параметр, він міститиме всі аргументи.

{{index [функція, програма]}}

Ви можете використовувати подібний запис з трьома крапками для _виклику_ функції з масивом аргументів.

```
нехай числа = [5, 1, 7];
console.log(max(...numbers));
// → 7
```

Це «((розгортання)» масиву у виклик функції, передаючи його елементи як окремі аргументи. Такий масив можна включати разом з іншими аргументами, як у `max(9, ...numbers, 2)`.

{{індекс «[] (масив)»}}

Записи масивів у квадратних дужках аналогічно дозволяють оператору з трьома крапками поширювати інший масив у новий масив:

```
нехай words = [«never», «fully»];
console.log([«will», ...words, «understand»]);
// → [«will», «never», «fully», «understand»].
```

{{index «{} (об'єкт)»}}

Це працює навіть в об'єктах з фігурними дужками, де додаються всі властивості з іншого об'єкта. Якщо властивість додається декілька разів, перемагає останнє додане значення:

```
нехай координати = {x: 10, y: 0};
console.log({...coordinates, y: 5, z: 1});
// → {x: 10, y: 5, z: 1}
```

## Об'єкт Math

{{індекс «Math object», «Math.min function», «Math.max function», «Math.sqrt function», мінімум, максимум, «квадратний корінь»}}

Як ми вже бачили, `Math` - це набір утиліт, пов'язаних з числами, таких як `Math.max` (максимум), `Math.min` (мінімум) та `Math.sqrt` (квадратний корінь).

{{index простір імен, [об'єкт, властивість]}}

{{id namespace_pollution}}

Об'єкт `Math` використовується як контейнер для групування пов'язаної функціональності. Існує лише один об'єкт `Math`, і він майже ніколи не використовується як значення. Скоріше, він забезпечує _простір імен_, щоб усі ці функції та значення не були глобальними прив'язками.

{{index [прив'язка, іменування]}}

Занадто велика кількість глобальних прив'язок «забруднює» простір імен. Чим більше імен, тим більша ймовірність того, що ви випадково перезапишете значення якогось існуючого зв'язування. Наприклад, цілком ймовірно, що ви захочете назвати щось `max` в одній з ваших програм. Оскільки вбудована в JavaScript функція `max` надійно схована всередині об'єкта `Math`, вам не потрібно турбуватися про її перезапис.

{{index «let keyword», «const keyword»}}

Багато мов зупинять вас або принаймні попередять, коли ви визначаєте прив'язку з іменем, яке вже зайнято. JavaScript робить це для прив'язок, оголошених за допомогою `let` або `const`, але, навпаки, не для стандартних прив'язок або прив'язок, оголошених за допомогою `var` або `function`.

{{index «Math.cos function», «Math.sin function», «Math.tan function», «Math.acos function», «Math.asin function», «Math.atan function», «Math.PI constant», косинус, синус, тангенс, «PI constant», пі}}

Повернемося до об'єкта `Math`. Якщо вам потрібно виконати ((тригонометрію)), об'єкт `Math` може допомогти. Він містить функції `cos` (косинус), `sin` (синус) і `tan` (тангенс), а також обернені до них функції `acos`, `asin` і `atan` відповідно. Число π (пі) - або, принаймні, найближче наближення, яке вписується в JavaScript-число - доступне як `Math.PI`. Існує стара традиція програмування - писати імена ((константних)) значень великими літерами.

```{test: no}
function randomPointOnCircle(radius) {
  let angle = Math.random() * 2 * Math.PI;
  return {x: radius * Math.cos(angle),
          y: радіус * Math.sin(angle)};
}
console.log(randomPointOnCircle(2));
// → {x: 0.3667, y: 1.966}
```

Якщо ви не знайомі з синусами і косинусами, не хвилюйтеся. Я поясню їх, коли вони будуть використані у [Главі ?](dom#sin_cos).

{{index «Math.random function», «random number»}}

У попередньому прикладі було використано `Math.random`. Це функція, яка повертає нове псевдовипадкове число від 0 (включно) до 1 (виключено) при кожному виклику:

```{test: no}
console.log(Math.random());
// → 0.36993729369714856
console.log(Math.random());
// → 0.727367032552138
console.log(Math.random());
// → 0.40180766698904335
```

{{index «pseudorandom number», «random number»}}

Хоча комп'ютери є детермінованими машинами - вони завжди реагують однаково на однакові вхідні дані - існує можливість змусити їх видавати числа, які виглядають випадковими. Для цього машина зберігає деяке приховане значення, і щоразу, коли ви запитуєте нове випадкове число, вона виконує складні обчислення над цим прихованим значенням, щоб створити нове значення. Вона зберігає нове значення і повертає деяке число, отримане з нього. Таким чином, він може створювати нові, важко передбачувані числа, які  виглядають випадковими.

{{округлення індексу, «функція Math.floor»}}

Якщо ми хочемо отримати ціле випадкове число замість дробового, ми можемо використати функцію `Math.floor` (яка округляє до найближчого цілого числа) до результату функції `Math.random`:

```{test: no}
console.log(Math.floor(Math.random() * 10));
// → 2
```

Множення випадкового числа на 10 дає нам число більше або рівне 0 і менше 10. Оскільки `Math.floor` округлює у меншу сторону, цей вираз з однаковою ймовірністю дасть будь-яке число від 0 до 9.

{{індекс «функція Math.ceil», «функція Math.round», «функція Math.abs», «абсолютне значення»}}

Існують також функції `Math.ceil` (для «стелі», яка округлює до цілого числа), `Math.round` (до найближчого цілого числа) та `Math.abs`, яка бере абсолютне значення числа, тобто від'ємні значення відкидаються, а додатні залишаються як є.

## Деструктуризація

{{index «phi function»}}

Повернімося на мить до функції `phi`.

```{test: wrap}
function phi(table) {
  return (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt((table[2] + table[3]) *
              (table[0] + table[1]) *
              (table[1] + table[3]) *
              (table[0] + table[2]));
}
```

{{index «destructuring binding», параметр}}

Однією з причин, чому цю функцію незручно читати, є те, що ми маємо прив'язку, яка вказує на наш масив, але ми воліли б мати прив'язки для _елементів_ масиву - тобто, `let n00 = table[0]` і так далі. На щастя, у JavaScript є лаконічний спосіб зробити це:

```
function phi([n00, n01, n10, n11]) {
  return (n11 * n00 - n10 * n01) /
    Math.sqrt((n10 + n11) * (n00 + n01) *
              (n01 + n11) * (n00 + n10));
}
```

{{індекс «ключове слово let», «ключове слово var», «ключове слово const», [зв'язування, деструктурування]}}

Це також працює для зв'язування, створеного за допомогою `let`, `var` або `const`. Якщо ви знаєте, що значення, яке ви зв'язуєте, є масивом, ви можете використовувати ((квадратні дужки)), щоб «зазирнути всередину» значення, зв'язавши його вміст.

{{індекс [об'єкт, властивість], [дужки, об'єкт]}}

Аналогічний трюк працює і для об'єктів, якщо замість квадратних дужок використовувати дужки.

```
let {name} = {name: «Faraji», age: 23};
console.log(name);
// → Faraji
```

{{index null, undefined}}

Зверніть увагу, що якщо ви спробуєте деструктурувати `null` або `undefined`, ви отримаєте помилку, так само як і при спробі прямого доступу до властивості цих значень.

## Необов'язковий доступ до властивості

{{index «необов'язковий ланцюжок», «символ крапки»}}

Якщо ви не впевнені, що дане значення створює об'єкт, але хочете прочитати властивість з нього, якщо створює, ви можете використати варіант крапкового запису: `об'єкт?.властивість`.

```
function city(object) {
  return object.address?.city;
}
console.log(city({адреса: {місто: «Торонто»}}));
// → Торонто
console.log(city({ім'я: «Віра»}));
// → undefined
```

Вираз `a?.b` означає те саме, що й `a.b`, якщо `a` не є нульовим або невизначеним. У протилежному випадку він обчислюється як `невизначений`. Це може бути зручно, коли, як у прикладі, ви не впевнені, що певна властивість існує, або коли змінна може мати невизначене значення.

Подібну нотацію можна використовувати з доступом у квадратних дужках, і навіть з викликами функцій, ставлячи `?.` перед дужками або дужками:

```
console.log(«string».notAMethod?.());
// → undefined
console.log({}.arrayProp?.[0]);
// → undefined
```

## JSON

{{індекс [масив, представлення], [об'єкт, представлення], «формат даних», [пам'ять, організація]}}

Оскільки властивості схоплюють значення, а не містять його, об'єкти та масиви зберігаються у пам'яті комп'ютера як послідовності бітів, що містять _((адресу))es_- місце у пам'яті - їхнього вмісту. Масив з іншим масивом всередині складається з (принаймні) однієї області пам'яті для внутрішнього масиву та іншої для зовнішнього масиву, що містить (серед іншого) число, яке представляє адресу внутрішнього масиву.

Якщо ви хочете зберегти дані у файлі для подальшого використання або відправити їх на інший комп'ютер по мережі, ви повинні якось перетворити ці плутанину адрес пам'яті в опис, який можна зберігати або надсилати. Можна було б передати всю пам'ять комп'ютера разом з адресою значення, яке вас цікавить, але це не найкращий підхід.

{{індекс див. «JavaScript Object Notation», JSON}}

{{index serialization, «World Wide Web»}}

Що ми можемо зробити, так це _серіалізувати_ дані. Це означає, що вони перетворюються на плаский опис. Популярний формат серіалізації називається _((JSON))_ (вимовляється як «Джейсон»), що означає JavaScript Object Notation. Він широко використовується як формат для зберігання даних і комунікації в Інтернеті, навіть з іншими мовами, крім JavaScript.

{{індекс [масив, нотація], [об'єкт, створення], [цитування, «в JSON»], коментар}}

JSON виглядає подібно до способу запису масивів та об'єктів у JavaScript, з деякими обмеженнями. Всі імена властивостей повинні бути оточені подвійними лапками, і дозволені тільки прості вирази даних - ніяких викликів функцій, прив'язок або будь-чого, що передбачає фактичні обчислення. Коментарі в JSON заборонені.

Запис у журналі може мати такий вигляд, якщо його подати у вигляді даних JSON:

```{lang: «json"}
{
  «squirrel": false,
  «events": [«work», «touched tree», «pizza», «running»]
}
```

{{index «JSON.stringify function», «JSON.parse function», серіалізація, десеріалізація, парсинг}}

JavaScript надає нам функції `JSON.stringify` і `JSON.parse` для перетворення даних у цей формат і з нього. Перша приймає значення JavaScript і повертає JSON-кодований рядок. Друга приймає такий рядок і перетворює його в закодоване значення:

```
let string = JSON.stringify({squirrel: false,
                             події: [«weekend»]});
console.log(string);
// → {«squirrel»:false, «events»:[«weekend»]}
console.log(JSON.parse(string).events);
// → [«weekend»]
```

## Підсумок

Об'єкти та масиви надають можливість групувати декілька значень в одне. Це дозволяє нам покласти купу пов'язаних між собою речей у сумку і бігати з цією сумкою, замість того, щоб обхоплювати кожну річ окремо і намагатися втримати її окремо.

Більшість значень в JavaScript мають властивості, за винятком `null` та `undefined`. Доступ до властивостей здійснюється за допомогою `value.prop` або `value[«prop»]`. Об'єкти, як правило, використовують імена для своїх властивостей і зберігають більш-менш фіксований їх набір. Масиви, з іншого боку, зазвичай містять різну кількість концептуально однакових значень і використовують числа (починаючи з 0) як імена своїх властивостей.

У масивах _існують_ деякі іменовані властивості, такі як `length` і ряд методів. Методи - це функції, які живуть у властивостях і (зазвичай) діють над значенням, властивістю якого вони є.

Ви можете циклічно перебирати масиви за допомогою спеціального виду циклу `for`: `for (нехай елемент масиву)`.

## Вправи

### Сума діапазону

{{index «підсумовування (вправа)»}}

У [вступі](intro) цієї книги згадується наступна вправа як гарний спосіб обчислення суми діапазону чисел:

```{test: no}
console.log(sum(range(1, 10)));
```

{{index «функція діапазону», «функція суми»}}

Напишіть функцію `range`, яка отримує два аргументи, `start` і `end`, і повертає масив, що містить усі числа від `start` до `end` включно.

Далі напишіть функцію `сума`, яка отримує масив чисел і повертає суму цих чисел. Запустіть програму на виконання і перевірте, чи дійсно вона повертає 55.

{{index «необов'язковий аргумент»}}

Як бонусне завдання, модифікуйте вашу функцію `range`, щоб вона приймала необов'язковий третій аргумент, який вказує на значення «кроку», що використовується при побудові масиву. Якщо крок не вказано, елементи будуть збільшуватися на одиницю, що відповідає старій поведінці. Виклик функції `range(1, 10, 2)` повинен повернути `[1, 3, 5, 7, 9]`. Переконайтеся, що це працює і з від'ємними значеннями кроку, щоб `range(5, 2, -1)` повертав `[5, 4, 3, 2]`.

{{якщо інтерактивно

```{test: no}
// Ваш код тут.

console.log(range(1, 10));
// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(range(5, 2, -1));
// → [5, 4, 3, 2]
console.log(sum(range(1, 10)));
// → 55
```

if}}

{{hint

{{index «підсумовування (вправа)», [масив, створення], «квадратні дужки»}}

Створення масиву найпростіше здійснити, спочатку ініціалізувавши прив'язку до `[]` (свіжого, порожнього масиву) і повторно викликавши його метод `push` для додавання значень. Не забудьте повернути масив в кінці функції.

{{index [масив, індексація], порівняння}}

Оскільки межа кінця є інклюзивною, вам потрібно використовувати оператор `<=`, а не `<`, щоб перевірити кінець циклу.

Параметр step може бути необов'язковим параметром, який за замовчуванням (за допомогою оператора `=`) дорівнює 1.

{{index «функція діапазону», «for loop»}}

Щоб функція `range` розуміла від'ємні значення кроку, можливо, найкраще написати два окремі цикли - один для підрахунку вгору і один для підрахунку вниз, оскільки порівняння, яке перевіряє, чи завершено цикл, має бути `>=`, а не `<=` при підрахунку вниз.

Можливо, також варто використовувати інший крок за замовчуванням, а саме -1, коли кінець діапазону менший за початок. Таким чином, `range(5, 2)` поверне щось значуще, а не застрягне у ((нескінченному циклі)). У значенні параметра за замовчуванням можна посилатися на попередні параметри.

підказка}}

### Реверсування масиву

{{index «реверсування (вправа)», «реверсний метод», [масив, методи]}}

Масиви мають метод `reverse`, який змінює масив, інвертуючи порядок появи його елементів. У цій вправі напишіть дві функції, `reverseArray` та `reverseArrayInPlace`. Перша, `reverseArray`, повинна приймати масив як аргумент і створювати _новий_ масив, який містить ті самі елементи у зворотному порядку. Другий, `reverseArrayInPlace`, повинен робити те саме, що і метод `reverse`: _модифікувати_ масив, заданий як аргумент, шляхом зміни місцями його елементів. Не можна використовувати стандартний метод `reverse`.

{{Ефективність індексу, «чиста функція», «побічний ефект»}}

Згадуючи нотатки про побічні ефекти та чисті функції у [попередній главі](functions#pure), який варіант, на вашу думку, може бути корисним у більшій кількості ситуацій? Який з них працює швидше?

{{якщо інтерактивний

```{test: no}
// Ваш код тут.

let myArray = [«A», «B», «C»];
console.log(reverseArray(myArray));
// → [«C», «B», «A»];
console.log(myArray);
// → [«A», «B», «C»];
let arrayValue = [1, 2, 3, 4, 5];
reverseArrayInPlace(arrayValue);
console.log(arrayValue);
// → [5, 4, 3, 2, 1]
```

if}}

{{hint

{{index «реверсування (вправа)»}}

Існує два очевидних способи реалізації `reverseArray`. Перший - просто переглянути вхідний масив спереду назад і використати метод `unshift` для нового масиву, щоб вставити кожен елемент на його початку. Другий спосіб - циклічно переглянути вхідний масив у зворотному напрямку і використати метод `push`. Обхід масиву у зворотному напрямку вимагає (дещо незручної) специфікації `for`, наприклад, `(let i = array.length - 1; i >= 0; i--)`.

{{index «slice method»}}

Повернути масив на місце складніше. Потрібно бути обережним, щоб не перезаписати елементи, які знадобляться пізніше. Використання `reverseArray` або копіювання масиву цілком (`array.slice()` є гарним способом копіювання масиву) працює, але є шахрайством.

Хитрість полягає у тому, щоб «поміняти місцями » перший і останній елементи, потім другий і передостанній, і так далі. Ви можете зробити це, пройшовши половину довжини масиву (використовуйте `Math.floor` для округлення вниз - вам не потрібно торкатися середнього елемента у масиві з непарною кількістю елементів) і помінявши елемент у позиції `i` на елемент у позиції `array.length - 1 - i`. Ви можете використати локальне прив'язування, щоб ненадовго затримати один з елементів, перезаписати його дзеркальним відображенням, а потім помістити значення з локального прив'язування на місце, де було дзеркальне відображення.

підказка}}

{{id list}}

### Список

{{index [«структура даних», список], «список (вправа)», «зв'язаний список», масив, колекція}}

Як загальні згустки значень, об'єкти можна використовувати для побудови різноманітних структур даних. Поширеною структурою даних є _список_ (не плутати з масивами). Список - це вкладений набір об'єктів, де перший об'єкт містить посилання на другий, другий на третій і так далі:

```{includeCode: true}
let list = {
  value: 1,
  rest: {
    value: 2,
    rest: {
      value: 3,
      rest: null
    }
  }
};
```

Отримані об'єкти утворюють ланцюжок, як показано на наступній схемі:

{{figure {url: «img/linked-list.svg», alt: «Діаграма, що показує структуру пам'яті зв'язаного списку. Є 3 комірки, кожна з яких має поле значення, що містить число, і поле «решта» зі стрілкою до решти списку. Стрілка першої комірки вказує на другу комірку, стрілка другої комірки - на останню комірку, а поле «решта» останньої комірки містить нуль.»,width: “8cm”}}}

{{index «structure sharing», [memory, structure sharing]}}

Приємною особливістю списків є те, що вони можуть ділитися частинами своєї структури. Наприклад, якщо я створюю два нових значення `{value: 0, rest: list}` і `{value: -1, rest: list}` (де `list` посилається на прив'язку, визначену раніше), вони обидва є незалежними списками, але мають спільну структуру, яка складається з останніх трьох елементів. Початковий список також залишається правильним списком з трьох елементів.

Напишіть функцію `arrayToList`, яка створює структуру списку, подібну до тієї, що показано на прикладі з аргументом `[1, 2, 3]`. Також напишіть функцію `listToArray`, яка створює масив зі списку. Додайте допоміжні функції `prepend`, яка отримує елемент і список і створює новий список, який додає елемент на початок вхідного списку, і `nth`, яка отримує список і число і повертає елемент на заданій позиції у списку (нуль означає перший елемент) або `undefined`, якщо такого елемента не існує.

{{Індексна рекурсія}}

Якщо ви цього ще не зробили, також напишіть рекурсивну версію `nth`.

{{якщо інтерактивний

```{test: no}
// Ваш код тут.

console.log(arrayToList([10, 20]));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(listToArray(arrayToList([10, 20, 30]));
// → [10, 20, 30]
console.log(prepend(10, prepend(20, null)));
// → {value: 10, rest: {value: 20, rest: null}}
console.log(nth(arrayToList([10, 20, 30]), 1));
// → 20
```

if}}

{{hint

{{index «list (exercise)», «linked list»}}

Побудова списку є простішою, коли це робиться від початку до кінця. Отже, `arrayToList` може ітераційно переглядати масив у зворотному напрямку (див. попередню вправу) і для кожного елемента додавати об'єкт до списку. Ви можете використати локальне прив'язування, щоб утримувати частину списку, яку було створено, і використовувати присвоювання на кшталт `list = {value: X, rest: list}` для додавання елемента.

{{index «for loop»}}

Для пробігу по списку (у `listToArray` та `nth`) можна використовувати специфікацію циклу `for` на кшталт цього:

```
for (let node = list; node; node = node.rest) {}
```

Бачите, як це працює? Кожну ітерацію циклу `node` вказує на поточний підсписок, а тіло може прочитати його властивість `value`, щоб отримати поточний елемент. В кінці ітерації `node` переходить до наступного підсписку. Коли цей підсписок дорівнює `null`, ми досягли кінця списку, і цикл завершено.

{Рекурсія індексів

Рекурсивна версія `nth` аналогічно переглядатиме дедалі меншу частину «хвоста» списку і водночас відраховуватиме індекс доти, доки він не досягне нуля, після чого зможе повернути властивість `value` вузла, на який вона дивиться. Щоб отримати нульовий елемент списку, ви просто берете властивість `value` його головного вузла. Щоб отримати елемент _N_ + 1, ви берете *N*-йелемент списку, який знаходиться у властивості `rest` цього списку.

підказка}}

{{id exercise_deep_compare}}

### Глибоке порівняння

{{index «deep comparison (exercise)», [comparison, deep], «deep comparison», «== operator»}}

Оператор `==` порівнює об'єкти за тотожністю, але іноді вам потрібно порівняти значення їхніх реальних властивостей.

Напишіть функцію `deepEqual`, яка отримує два значення і повертає `true` тільки якщо вони мають однакове значення або є об'єктами з однаковими властивостями, де значення властивостей рівні при порівнянні з рекурсивним викликом `deepEqual`.

{{index null, «=== оператор», «typeof оператор»}}

Щоб дізнатися, чи потрібно порівнювати значення безпосередньо (використовуючи для цього оператор `===`), чи порівнювати їхні властивості, ви можете скористатися оператором `typeof`. Якщо він видає `«об'єкт»` для обох значень, вам слід виконати глибоке порівняння. Але ви повинні взяти до уваги один дурний виняток: через історичну випадковість, `typeof null` також повертає `«об'єкт»`.

{{index «Функція Object.keys»}}

Функція `Object.keys` буде корисною, коли вам потрібно переглянути властивості об'єктів для їх порівняння.

{{if інтерактивний

```{test: no}
// Ваш код тут.

let obj = {тут: {is: «an"}, object: 2};
console.log(deepEqual(obj, obj));
// → true
console.log(deepEqual(obj, {here: 1, object: 2}));
// → false
console.log(deepEqual(obj, {here: {is: «an»}, object: 2}));
// → true
```

if}}

{{hint

{{index «глибоке порівняння (вправа)», [comparison, deep], «typeof operator», «=== operator»}}

Ваш тест на те, чи маєте ви справу з реальним об'єктом, буде виглядати приблизно так: `typeof x == «object» && x != null`. Будьте обережні і порівнюйте властивості лише тоді, коли _обидва_ аргументи є об'єктами. У всіх інших випадках можна просто одразу повернути результат застосування `===`.

{{index «Функція Object.keys»}}

Використовуйте `Object.keys` для перегляду властивостей. Вам потрібно перевірити, чи обидва об'єкти мають однаковий набір назв властивостей і чи ці властивості мають однакові значення. Один із способів зробити це - переконатися, що обидва об'єкти мають однакову кількість властивостей (довжини списків властивостей однакові). А потім, циклічно переглядаючи властивості одного з об'єктів для їх порівняння, завжди спочатку переконайтеся, що інший об'єкт дійсно має властивість з такою назвою. Якщо вони мають однакову кількість властивостей і всі властивості одного з них також існують в іншому, то вони мають однаковий набір назв властивостей.

{{index «return value»}}

Найкраще повертати правильне значення з функції, негайно повертаючи значення `false`, якщо знайдено невідповідність, і повертаючи значення `true` в кінці функції.

підказка}}
