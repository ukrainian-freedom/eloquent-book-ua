{{meta {docid: values}}}

# Значення, типи та оператори

{{quote {author: «Master Yuan-Ma», title: «Книга з програмування», chapter: true}}

Під поверхнею машини рухається програма. 

Без зусиль вона розширюється і стискається. У великій гармонії електрони розсіюються і перегруповуються. Форми на моніторі - лише брижі на воді. Суть залишається невидимою внизу.

quote}}

{{index «Yuan-Ma», «Книга з програмування»}}

{{figure {url: «img/chapter_picture_1.jpg», alt: «Ілюстрація моря темних і світлих точок (бітів) з островами в ньому», “chapter”, “framed” }}}

{{індекс «двійкові дані», дані, біт, пам'ять}}

У комп'ютерному світі існують лише дані. Ви можете читати дані, змінювати їх, створювати нові дані - але про те, що не є даними, не можна говорити. Всі ці дані зберігаються у вигляді довгих послідовностей бітів і, таким чином, є принципово однаковими.

{{index CD, сигнал}}

Біти - це будь-які двозначні величини, які зазвичай описуються як нулі та одиниці. У комп'ютері вони приймають такі форми, як високий або низький електричний заряд, сильний або слабкий сигнал, блискуча або тьмяна пляма на поверхні компакт-диска. Будь-який фрагмент дискретної інформації можна звести до послідовності нулів та одиниць і таким чином представити у вигляді бітів.

{{індекс «двійкове число», «десяткове число»}}

Наприклад, ми можемо подати число 13 у бітах. Це працює так само, як і десяткове число, але замість 10 різних ((цифр)) ми маємо лише 2, і вага кожної з них збільшується у 2 рази справа наліво. Ось біти, з яких складається число 13, а під ними вказано вагу цифр:

```{lang: null}
   0 0 0 0 1 1 0 1
 128 64 32 16 8 4 2 1
```

Це двійкове число 00001101. Його ненульові цифри означають 8, 4 і 1, і в сумі дають 13.

## Значення

{{індекс [пам'ять, організація], «сховище даних», «жорсткий диск»}}

Уявіть собі море бітів - їх цілий океан. Типовий сучасний комп'ютер має понад 100 мільярдів бітів у своєму енергонезалежному сховищі даних (робочій пам'яті). Енергонезалежне сховище (жорсткий диск або його еквівалент), як правило, має ще на кілька порядків більше.

Щоб мати можливість працювати з такою кількістю бітів, не гублячись, ми розбиваємо їх на фрагменти, які представляють частини інформації. У середовищі JavaScript ці фрагменти називаються _((значення))s_. Хоча всі значення складаються з бітів, вони відіграють різні ролі. Кожне значення має ((тип)), який визначає його роль. Деякі значення є числами, деякі - фрагментами тексту, деякі - функціями, і так далі.

{{index «garbage collection»}}

Щоб створити значення, вам потрібно просто викликати його ім'я. Це дуже зручно. Вам не потрібно збирати будівельний матеріал для ваших значень або платити за них. Ви просто викликаєте цінність, і _бум_, вона  у вас є. Звичайно, цінності не створюються з повітря. Кожну з них потрібно десь зберігати, і якщо ви хочете використовувати гігантську кількість цінностей одночасно, вам може не вистачити пам'яті комп'ютера. На щастя, це проблема лише тоді, коли вони потрібні вам усі одночасно. Як тільки ви більше не використовуєте значення, воно розсіюється, залишаючи після себе біти, які можна переробити як будівельний матеріал для наступного покоління значень.

Решта цієї глави знайомить з атомарними елементами JavaScript-програм, тобто простими типами значень і операторами, які можуть діяти над такими значеннями.

## Числа

{{індекс [синтаксис, число], число, [число, позначення]}}

Значення типу _число_ - це, як не дивно, числові значення. У програмі на JavaScript вони записуються наступним чином:

```
13
```

{{індекс «двійкове число»}}

Використання цього в програмі призведе до того, що в пам'яті комп'ютера з'явиться бітовий шаблон для числа 13.

{{index [число, представлення], біт}}

JavaScript використовує фіксовану кількість бітів, 64, для зберігання одного числового значення. Існує лише стільки шаблонів, скільки можна створити за допомогою 64 біт, що обмежує кількість різних чисел, які можна представити. За допомогою _N_ десяткових ((цифр))s можна представити 10^N^ чисел. Аналогічно, маючи 64 двійкові цифри, ви можете представити 2^64^ різних чисел, що становить близько 18 квінтильйонів (18 з 18 нулями після неї). Це дуже багато.

Раніше пам'ять комп'ютера була набагато меншою, і люди, як правило, використовували групи по 8 або 16 біт для представлення своїх чисел. Було легко випадково _((переповнити))_ такі маленькі числа - і в результаті отримати число, яке не вкладається у задану кількість бітів. Сьогодні навіть комп'ютери, що вміщаються у кишені, мають достатньо пам'яті, тому ви можете вільно використовувати 64-розрядні фрагменти, і турбуватися про переповнення потрібно лише тоді, коли маєте справу з дійсно астрономічними числами.

{{знак індексу, «число з плаваючою комою», «знаковий біт»}}

Однак не всі цілі числа, менші за 18 квінтильйонів, поміщаються в JavaScript-числа. Ці біти також зберігають від'ємні числа, тому один біт вказує на знак числа. Більшою проблемою є представлення нецілих чисел. Для цього деякі біти використовуються для зберігання позиції десяткової крапки. Максимальне ціле число, яке можна зберігати, знаходиться у діапазоні 9 квадрильйонів (15 нулів) - що все ще є приємно величезним.

{{індекс [число, позначення], «дробове число»}}

Дробові числа записуються за допомогою крапки:

```
9.81
```

{{індекс показника степеня, «науковий запис», [число, позначення]}}

Для дуже великих або дуже малих чисел ви також можете використовувати наукові позначення, додаючи _e_ (для _експонента_), а потім експоненту числа.

```
2.998e8
```

Це 2.998 × 10^8^ = 299 800 000.

{{індекс pi, [число, «точність»], «число з плаваючою комою»}}

Обчислення з цілими числами (також званими _((ціле))s_), меншими за вищезгадані 9 квадрильйонів, гарантовано завжди будуть точними. На жаль, обчислення з дробовими числами, як правило, не є такими. Так само, як число π (пі) не може бути точно виражене скінченною кількістю десяткових цифр, багато чисел втрачають певну точність, коли для їх зберігання доступно лише 64 біти. Це прикро, але це викликає практичні проблеми лише у певних ситуаціях. Важливо знати про це і ставитися до дробових чисел як до наближених, а не як до точних значень.

### Арифметика

{{індекс [синтаксис, оператор], оператор, «бінарний оператор», арифметика, додавання, множення}}

Основна робота з числами - це арифметика. Арифметичні операції, такі як додавання або множення, беруть два числових значення і створюють з них нове число. Ось як вони виглядають у JavaScript:

```{meta: «expr»}
100 + 4 * 11
```

{{індекс [оператор, додаток], зірочка, «символ плюс», «* оператор», «+ оператор»}}

Символи `+` та `*` називаються _операторами_. Перший означає додавання, а другий - множення. Якщо помістити оператор між двома значеннями, він буде застосований до цих значень і створить нове значення.

{{групування індексів, дужки, пріоритет}}

Чи означає цей приклад «Додати 4 і 100, а результат помножити на 11», або ж множення виконується перед додаванням? Як ви вже здогадалися, множення відбувається першим. Як і у математиці, ви можете змінити це, взявши додавання у круглі дужки.

```{meta: «expr»}
(100 + 4) * 11
```

{{індекс «дефіс», «коса риска», ділення, віднімання, мінус, «- оператор», «/ оператор»}}

Для віднімання існує оператор `-`. Ділення можна виконати за допомогою оператора `/`.

Коли оператори з'являються разом без круглих дужок, порядок їх застосування визначається _((пріоритетом))_ операторів. У прикладі показано, що множення відбувається перед додаванням. Оператор `/` має такий самий пріоритет, як і `*`. Аналогічно, `+` і `-` мають однаковий пріоритет. Коли декілька операторів з однаковим пріоритетом стоять поруч, як у виразі `1 - 2 + 1`, вони застосовуються зліва направо: `(1 - 2) + 1`.

Не хвилюйтеся надто сильно про ці правила пріоритетів. Якщо ви сумніваєтеся, просто додайте дужки.

{{індекс «оператор за модулем», «оператор ділення», «оператор остачі», «оператор %»}}

Існує ще один арифметичний оператор, який ви можете не одразу впізнати. Символ `%` використовується для позначення операції _залишок_. Вираз `X % Y` є остачею від ділення `X` на `Y`. Наприклад, `314 % 100` дає `14`, а `144 % 12` - `0`. Оператор залишку має такий самий пріоритет, як і оператори множення та ділення. Ви також часто можете бачити цей оператор, позначений як _modulo_.

### Спеціальні числа

{{index [число, «спеціальні значення»], нескінченність}}

У JavaScript є три спеціальні значення, які вважаються числами, але не поводяться як звичайні числа. Перші два - `Infinity` та `Infinity`, які представляють додатну та від'ємну нескінченності. «Нескінченність - 1» - це все ще “Нескінченність”, і так далі. Однак не покладайтеся на обчислення на основі нескінченності. Вони не є математично обґрунтованими і швидко призведуть до наступного спеціального числа: `NaN`.

{{індекс NaN, «не число», «ділення на нуль»}}

`NaN` означає «не є числом», навіть якщо воно _є_ значенням типу числа. Ви отримаєте такий результат, коли, наприклад, спробуєте обчислити `0 / 0` (нуль поділити на нуль), `Нескінченність - Нескінченність` або будь-яку іншу числову операцію, яка не дасть осмисленого результату.

## Рядки

{{indexsee «grave accent», backtick}}

{{індекс [синтаксис, рядок], текст, символ, [рядок, позначення], «символ в одинарних лапках», «символ в подвійних лапках», «лапки», зворотна кома}}

Наступним базовим типом даних є _((рядок))_. Рядки використовуються для представлення тексту. Вони записуються шляхом взяття їх вмісту у лапки.

```
«Внизу на морі
«Лежати на океані»
«Плавати по океану
```

Ви можете використовувати одинарні лапки, подвійні лапки або зворотні лапки для позначення рядків, якщо лапки на початку та в кінці рядка збігаються.

{{index «переведення рядка», «символ нового рядка»}}

Між лапками можна помістити майже все, що завгодно, щоб JavaScript перетворив це на рядкове значення. Але з кількома символами складніше. Ви можете собі уявити, як важко помістити лапки між лапками, оскільки вони будуть виглядати як кінець рядка. _Нові рядки_ (символи, які ви отримуєте при натисканні [enter]{ім'я_клавіші}) можна включати лише тоді, коли рядок взято у лапки з зворотними лапками (`` `` ``).

{{index [екранування, «у рядках»], [«символ зворотної косої риски», «у рядках»]}}

Щоб зробити можливим включення таких символів у рядок, використовується наступна нотація: зворотна коса риска (`\`) всередині цитованого тексту вказує на те, що символ, який стоїть після неї, має особливе значення. Це називається _обтіканням_ символу. Лапки, яким передує зворотна коса риска, не завершують рядок, а є його частиною. Якщо після зворотної косої риски стоїть символ `n`, він інтерпретується як новий рядок. Аналогічно, символ `t` після зворотної косої риски означає символ табуляції. Візьмемо наступний рядок:

```
«Це перший рядок\nА це другий»
```

Це власне текст у цьому рядку:

```{lang: null}
Це перший рядок
А це другий
```

Звичайно, бувають ситуації, коли ви хочете, щоб зворотна коса риска у рядку була просто зворотною рискою, а не спеціальним кодом. Якщо дві зворотні косі риски йдуть одна за одною, вони згортаються разом, і в результуючому значенні рядка залишиться лише одна. Так можна записати рядок «_Символ нового рядка записується як `»`\n`«`._»:

```
«Символ нового рядка записується як \«\\n\».
```

{{id unicode}}

{{індекс [рядок, подання], Unicode, символ}}

Рядки також потрібно моделювати як послідовність бітів, щоб вони могли існувати у комп'ютері. Спосіб, у який JavaScript робить це, базується на стандарті _((Unicode))_. Цей стандарт присвоює номер практично кожному символу, який вам коли-небудь знадобиться, включаючи символи грецької, арабської, японської, вірменської і так далі мов. Якщо у нас є номер для кожного символу, то рядок можна описати послідовністю чисел. Саме це і робить JavaScript.

{{index «UTF-16», emoji}}

Однак є одне ускладнення: JavaScript використовує 16 біт на елемент рядка, що дозволяє описати до 2^16^ різних символів. Однак Unicode визначає більше символів - приблизно вдвічі більше, на даний момент. Тому деякі символи, наприклад, багато емодзі, займають дві «позиції символів» у рядках JavaScript. Ми повернемося до цього у [Розділі ?](вищий_порядок#одиниці_коду).

{{індекс «+ оператор», конкатенація}}

Рядки не можна ділити, множити або віднімати. До них  можна застосовувати оператор `+`, але не для додавання, а для _конкатенації_- склеювання двох рядків. Наступний рядок створить рядок `«concatenate»`:

```{meta: «expr»}
«con» + “cat” + “e” + »nate»
```

Рядкові значення мають ряд пов'язаних функцій (_методів_), які можна використовувати для виконання інших операцій над ними. Я розповім про них докладніше у [Розділі ?](data#methods).

{{Інтерполяція індексу, зворотна кома}}

Рядки, написані в одинарних або подвійних лапках, поводяться майже однаково - різниця полягає лише у тому, який тип лапок вам потрібно використовувати для екранування всередині них. Рядки, взяті у лапки, які зазвичай називають _((шаблонні літерали))_, можуть виконувати ще кілька трюків. Окрім того, що вони можуть переносити рядки, вони також можуть вбудовувати інші значення.

```{meta: «expr»}
«половина від 100 дорівнює ${100 / 2}
```

Коли ви пишете щось всередині `${}` у шаблонному літералі, його результат буде обчислено, перетворено у рядок і включено у цю позицію. У цьому прикладі буде виведено рядок `«половина від 100 дорівнює 50»`.

## Унарні оператори

{{індекс оператора, «тип оператора», тип}}

Не всі оператори є символами. Деякі з них записуються як слова. Одним з прикладів є оператор `typeof`, який створює рядкове значення, що називає тип значення, яке ви йому надаєте.

```
console.log(typeof 4.5)
// → число
console.log(typeof «x»)
// → рядок
```

{{index «console.log», output, «JavaScript console»}}

{{id «console.log»}}

Ми будемо використовувати `console.log` у прикладі коду, щоб вказати, що ми хочемо побачити результат обчислення чогось. (Детальніше про це у [наступному розділі](структура_програми)).

{{заперечення індексу, «- оператор», «бінарний оператор», «унарний оператор»}}

Інші оператори, показані у цій главі, оперують з двома значеннями, але `typeof` приймає лише одне. Оператори, які використовують два значення, називаються _двійковими_ операторами, а ті, що приймають одне, називаються _унарними_ операторами. Оператор мінус (`-`) можна використовувати і як бінарний, і як унарний оператор.

```
console.log(- (10 - 2))
// → -8
```

## Булеві значення

{{індекс Boolean, оператор, true, false, біт}}

Часто буває корисно мати значення, яке розрізняє лише дві можливості, наприклад, «так» і «ні» або «увімкнено» і «вимкнено». Для цього у JavaScript існує тип _Boolean_, який має лише два значення, true та false, записані у вигляді цих слів.

### Порівняння

{{Порівняння індексів}}

Ось один із способів отримання булевих значень:

```
console.log(3 > 2)
// → true
console.log(3 < 2)
// → false
```

{{індекс [порівняння, «чисел»], «оператор >», «оператор <», «більше», «менше»}}

Знаки `>` і `<` є традиційними символами для позначення «більше» і «менше» відповідно. Вони є бінарними операторами. Їх застосування призводить до отримання булевого значення, яке вказує, чи є вони істинними у даному випадку.

У такий самий спосіб можна порівнювати рядки.

```
console.log(«Aardvark» < «Zoroaster»)
// → true
```

{{index [comparison, «of strings»]}}

Спосіб впорядкування рядків приблизно алфавітний, але не зовсім такий, як ви очікуєте побачити у словнику: великі літери завжди «менші» за малі, тому `«Z» < «a»`, і неалфавітні символи (!, -, і так далі) також враховуються при впорядкуванні. При порівнянні рядків JavaScript переглядає символи зліва направо, порівнюючи коди ((Unicode)) один за одним.

{{рівність індексів, «>= оператор», «<= оператор», «== оператор», «!= оператор»}}

Інші подібні оператори: `>=` (більше або дорівнює), `<=` (менше або дорівнює), `==` (дорівнює) і `!=` (не дорівнює).

```
console.log(«Garnet» != «Ruby»)
// → true
console.log(«Перлина» == «Аметист»)
// → false
```

{{index [comparison, «of NaN»], NaN}}

У JavaScript існує лише одне значення, яке не дорівнює самому собі, і це `NaN` («не число»).

```
console.log(NaN == NaN)
// → false
```

`NaN` має позначати результат безглуздого обчислення, і як такий, він не дорівнює результату будь-яких _інших_ безглуздих обчислень.

### Логічні оператори

{{індекс міркувань, «логічні оператори»}}

Існують також деякі операції, які можна застосовувати до самих булевих значень. JavaScript підтримує три логічні оператори: _і_, _або_ та _не_. Їх можна використовувати для «міркувань» над булевими значеннями.

{{індекс «оператор &&», «логічне і»}}

Оператор `&&` представляє логічне _та_. Це бінарний оператор, і його результат є істинним лише тоді, коли обидва значення, надані йому, є істинними.

```
console.log(true && false)
// → false
console.log(true && true)
// → true
```

{{індекс «оператор ||», «логічне або»}}

Оператор `||` позначає логічне _або_. Він видає значення true, якщо будь-яке із заданих йому значень є істинним.

```
console.log(false || true)
// → true
console.log(false || false)
// → false
```

{{заперечення індексу, оператор «!»}}

Оператор_Not_ записується у вигляді знаку оклику (`!`). Це унарний оператор, який перевертає задане йому значення - `!true` дає `false`, а `!false` дає `true`.

{{Пріоритет індексу}}

При змішуванні цих булевих операторів з арифметичними та іншими операторами не завжди очевидно, коли потрібні дужки. На практиці зазвичай достатньо знати, що з операторів, які ми розглядали, найнижчий пріоритет має `||`, далі йде `&&`, потім оператори порівняння (`>`, `==` і т.д.), а потім решта. Такий порядок обрано для того, щоб у типових виразах, подібних до наведеного нижче, було якомога менше круглих дужок:

```{meta: «expr»}
1 + 1 == 2 && 10 * 10 > 50
```

{{індекс «умовне виконання», «тернарний оператор», «?: оператор», «умовний оператор», «двокрапка», «знак питання»}}

Останній логічний оператор, який ми розглянемо, не унарний, не бінарний, а _тернарний_, який оперує трьома значеннями. Він записується зі знаком питання та двокрапкою, ось так:

```
console.log(true ? 1 : 2);
// → 1
console.log(false ? 1 : 2);
// → 2
```

Цей оператор називається _умовний_ оператор (або іноді просто _тернарний оператор_, оскільки це єдиний такий оператор у мові). Оператор використовує значення зліва від знаку питання, щоб вирішити, яке з двох інших значень «вибрати». Якщо ви напишете `a ? b : c`, результатом буде `b`, якщо `a` істинно, і `c` в іншому випадку.

## Порожні значення

{{index undefined, null}}

Існує два спеціальних значення, записаних як `null` та `undefined`, які використовуються для позначення відсутності _значущого_ значення. Вони самі є значеннями, але не несуть ніякої інформації.

Багато операцій у мові, які не дають осмисленого значення, дають `undefined` просто тому, що вони повинні давати _якесь_ значення.

Різниця у значенні між `undefined` та `null` є випадковістю дизайну JavaScript, і здебільшого вона не має значення. У випадках, коли вам дійсно доводиться мати справу з цими значеннями, я рекомендую розглядати їх як взаємозамінні.

## Автоматичне перетворення типів

{{index NaN, «type coercion»}}

У [вступі](intro) я згадував, що JavaScript намагається прийняти майже будь-яку програму, яку ви йому даєте, навіть програми, які роблять дивні речі. Це добре демонструють наступні вирази:

```
console.log(8 * null)
// → 0
console.log(«5» - 1)
// → 4
console.log(«5» + 1)
// → 51
console.log(«5» * 2)
// → NaN
console.log(false == 0)
// → true
```

{{індекс «+ оператор», арифметика, «* оператор», «- оператор»}}

Коли оператор застосовується до «неправильного» типу значення, JavaScript спокійно перетворить це значення до потрібного йому типу, використовуючи набір правил, які часто не є тим, чого ви хочете або очікуєте. Це називається _((примусовий тип))_. У першому виразі `null` стає `0`, а `5` у другому виразі стає `5` (з рядка на число). Однак у третьому виразі `+` намагається виконати конкатенацію рядків перед додаванням чисел, тому `1` перетворюється на `«1»` (з числа на рядок).

{{index «примус типу», [число, «перетворення до»]}}

Коли щось, що не відображається у число очевидним чином (наприклад, `«five»` або `undefined`), перетворюється у число, ви отримуєте значення `NaN`. Подальші арифметичні операції над `NaN` продовжують давати `NaN`, тому якщо ви отримуєте таке значення у несподіваному місці, шукайте випадкові перетворення типів.

{{index null, undefined, [comparison, «of undefined values»], «== operator»}}

При порівнянні значень одного типу за допомогою оператора `==` результат легко передбачити: ви отримаєте true, якщо обидва значення однакові, за винятком випадку `NaN`. Але коли типи відрізняються, JavaScript використовує складний і заплутаний набір правил, щоб визначити, що робити. У більшості випадків він просто намагається перетворити одне зі значень до типу іншого значення. Однак, коли з обох боків оператора зустрічається `null` або `undefined`, він видає значення true, тільки якщо обидві сторони мають значення `null` або `undefined`.

```
console.log(null == undefined);
// → true
console.log(null == 0);
// → false
```

Така поведінка часто буває корисною. Якщо ви хочете перевірити, чи значення має дійсне значення замість `null` або `undefined`, ви можете порівняти його з `null` за допомогою оператора `==` або `!=`.

{{індекс «примус типу», [Boolean, «перетворення до»], «оператор ===», «!== оператор», порівняння}}

Що робити, якщо ви хочете перевірити, чи посилається щось на точне значення `false`? Вирази на кшталт `0 == false` та `«» == false` також є істинними завдяки автоматичному перетворенню типів. Якщо ви  не хочете, щоб відбувалося жодне перетворення типів, є два додаткових оператори: `===` та `!==`. Перший перевіряє, чи одне значення _точно_ дорівнює іншому, а другий - чи не дорівнює. Таким чином, `«» === false` є хибним, як і очікувалося.

Я рекомендую використовувати трисимвольні оператори порівняння обережно, щоб запобігти несподіваним перетворенням типів, які можуть підстерігати вас. Але коли ви впевнені, що типи з обох сторін будуть однаковими, немає жодних проблем з використанням коротших операторів.

### Замикання логічних операторів

{{індекс «примус типу», [Boolean, «перетворення до»], оператор}}

Логічні оператори `&&` та `||` по-особливому обробляють значення різних типів. Вони перетворять значення у лівій частині до булевого типу, щоб вирішити, що робити далі, але залежно від оператора та результату перетворення, вони повернуть або _оригінальне_ ліве значення, або праве значення.

{{індекс «|| оператор»}}

Наприклад, оператор `||` повертатиме значення ліворуч, якщо це значення можна перетворити на істину, і повертатиме значення праворуч в іншому випадку. Це має очікуваний ефект, коли значення є булевими, і робить щось аналогічне для значень інших типів.

```
console.log(null || «user»)
// → user
console.log(«Agnes» || «user»)
// → Agnes
```

{{index «значення за замовчуванням»}}

Ми можемо використовувати цю функціональність як спосіб повернутися до значення за замовчуванням. Якщо у вас є значення, яке може бути порожнім, ви можете поставити `||` після нього зі значенням заміни. Якщо початкове значення може бути перетворено на false, ви отримаєте заміну замість нього. Правила перетворення рядків і чисел у булеві значення стверджують, що `0`, `NaN` і порожній рядок (`«»`) вважаються хибними, тоді як усі інші значення вважаються істинними. Це означає, що `0 || -1` дає `-1`, а `"» || «!?»` дає `«!?»`.

{{index «?? operator», null, undefined}}

Оператор `??` схожий на `||`, але повертає значення праворуч, тільки якщо значення ліворуч є `null` або `undefined`, а не будь-яке інше значення, яке може бути перетворено у `false`. Часто це краще, ніж поведінка `||`.

```
console.log(0 || 100);
// → 100
console.log(0 ?? 100);
// → 0
console.log(null ?? 100);
// → 100
```

{{індекс «&& оператор»}}

Оператор `&&` працює аналогічно, але навпаки. Якщо значення зліва від нього є чимось, що перетворюється на false, він повертає це значення, інакше він повертає значення справа від нього.

Ще однією важливою властивістю цих двох операторів є те, що частина праворуч від них обчислюється тільки тоді, коли це необхідно. У випадку `true || X`, незалежно від того, що таке `X` - навіть якщо це частина програми, яка робить щось _жахливе_- результат буде істинним, а `X` ніколи не обчислюється. Те саме стосується `false && X`, який є хибним і ігнорує `X`. Це називається _((оцінка короткого замикання))_.

{{індекс «тернарний оператор», «?: оператор», «умовний оператор»}}

Умовний оператор працює аналогічно. З другого і третього значень обчислюється тільки те, яке вибрано.

## Підсумок

У цій главі ми розглянули чотири типи значень JavaScript: числа, рядки, булеві функції та невизначені значення. Такі значення створюються шляхом введення їх імені (`true`, `null`) або значення (`13`, `«abc»`).

Ви можете комбінувати і перетворювати значення за допомогою операторів. Ми бачили бінарні оператори для арифметики (`+`, `-`, `*`, `/` і `%`), конкатенації рядків (`+`), порівняння (`==`, `!=`, `===`, `!==`, `<`, `>`, `<=`, `>=`) і логіки (`&&`, `||`, `?? `), а також кілька унарних операторів (`-` для заперечення числа, `!` для логічного заперечення і `typeof` для знаходження типу значення) і тернарний оператор (`?:`) для вибору одного з двох значень на основі третього значення.

Це дає вам достатньо інформації для використання JavaScript як кишенькового калькулятора, але не більше. У [наступному розділі](структура_програми) ми почнемо об'єднувати ці вирази у базові програми.
