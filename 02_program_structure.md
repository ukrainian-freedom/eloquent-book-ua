# Структура програми

{{quote {author: «_why», title: «Why's (Poignant) Guide to Ruby», chapter: true}}

І моє серце світиться яскраво-червоним під моєю плівчастою, напівпрозорою шкірою, і їм доводиться вводити 10 кубічних сантиметрів JavaScript, щоб змусити мене повернутися. (Я добре реагую на токсини в крові.) Чувак, ця штука виб'є персики прямо з твоїх зябер!

quote}}

{{index why, «Гострий путівник»}}

{{figure {url: «img/chapter_picture_2.jpg», alt: «Ілюстрація із зображенням кількох щупалець, що тримають шахові фігури», chapter: framed}}}

У цій главі ми почнемо робити те, що насправді можна назвати _програмуванням_. Ми розширимо наше володіння мовою JavaScript за межі іменників та фрагментів речень, які ми бачили до цього часу, до рівня, коли ми зможемо виражати осмислену прозу.

## Вирази та оператори

{{індекс граматики, [синтаксис, вираз], [код, «структура»], граматика, [JavaScript, синтаксис]}}

У [Розділі ?](значення) ми створювали значення і застосовували до них оператори для отримання нових значень. Створення таких значень є основною суттю будь-якої програми на JavaScript. Але для того, щоб бути корисною, ця основа повинна бути обрамлена у більш широку структуру. Це те, що ми розглянемо у цій главі.

{{індекс «буквальний вираз», [дужки, вираз]}}

Фрагмент коду, який створює значення, називається _((вираз))_. Кожне значення, записане буквально (наприклад, `22` або `«психоаналіз»`), є виразом. Вираз у круглих дужках також є виразом, як і ((бінарний оператор)), застосований до двох виразів або ((унарний оператор)), застосований до одного.

{{index [вкладеність, «виразів»], «людська мова»}}

Це показує частину краси інтерфейсу, заснованого на мові. Вирази можуть містити інші вирази подібно до того, як у людській мові вкладені підрядні речення - підрядне речення може містити власні підрядні речення, і так далі. Це дозволяє створювати вирази, які описують як завгодно складні обчислення.

{{індексний оператор, крапка з комою, програма}}

Якщо вираз відповідає фрагменту речення, то  оператор JavaScript відповідає повному реченню. Програма - це список операторів.

{{індекс [синтаксис, оператор]}}

Найпростіший вид операторів - це вираз з крапкою з комою після нього. Це і є програма:

```
1;
!false;
```

Однак це марна програма. ((вираз)) може задовольнятися тим, що просто виводить значення, яке потім може бути використане кодом, що його супроводжує. Однак ((оператор)) стоїть сам по собі, тому, якщо він не впливає на світ, він марний. Він може виводити щось на екран, як у випадку з `console.log`, або змінювати стан машини таким чином, що це вплине на оператори, які йдуть після нього. Такі зміни називаються _((побічний ефект))s_. Оператори у попередньому прикладі просто видають значення `1` і `true`, а потім одразу ж їх викидають. Це не залишає жодного враження на світ. Коли ви запускаєте цю програму, нічого помітного не відбувається.

{{index «стиль програмування», «автоматична вставка крапки з комою», крапка з комою}}

У деяких випадках JavaScript дозволяє опускати крапку з комою в кінці оператора. В інших випадках крапка з комою має бути обов'язково, інакше наступний ((рядок)) буде розглядатися як частина того ж самого оператора. Правила щодо того, коли крапку з комою можна безпечно опускати, є дещо складними і схильними до помилок. Тому у цій книжці кожне твердження, яке потребує крапки з комою, завжди буде з нею. Я рекомендую вам робити так само, принаймні до того часу, поки ви не дізнаєтесь більше про тонкощі пропущених крапок з комою.

## Зв'язування

{{indexsee змінна, прив'язка}}
{{індекс [синтаксис, оператор], [зв'язування, визначення], «побічний ефект», [пам'ять, організація], [стан, у зв'язуванні]}}

Як програма зберігає внутрішній стан? Як вона запам'ятовує дані? Ми бачили, як створювати нові значення зі старих, але при цьому старі значення не змінюються, а нове значення має бути використане негайно, інакше воно знову зникне. Для захоплення та утримання значень JavaScript надає річ, яка називається _зв'язка_, або _змінна_.

```
let caught = 5 * 5;
```

{{index «let ключове слово»}}

Це дає нам другий вид ((інструкції)). Спеціальне слово (_((ключове слово))_) `let` вказує на те, що це речення буде визначати зв'язування. За ним слідує ім'я зв'язування і, якщо ми хочемо одразу надати йому значення, оператор `=` та вираз.

У прикладі створюється прив'язка з назвою `caught` і використовується для захоплення числа, яке отримується при множенні 5 на 5.

Після визначення зв'язування його ім'я можна використовувати як ((вираз)). Значення такого виразу - це значення, яке наразі має прив'язка. Ось приклад:

```
нехай ten = 10;
console.log(ten * ten);
// → 100
```

{{індекс «= оператор», присвоєння, [прив'язка, присвоєння]}}

Коли прив'язка вказує на значення, це не означає, що вона прив'язана до цього значення назавжди. Оператор `=` можна будь-коли використати для існуючих прив'язок, щоб від'єднати їх від поточного значення і зробити так, щоб вони вказували на нове значення:

```
let mood = «light»;
console.log(mood);
// → light
mood = «dark»;
console.log(mood);
// → темний
```

{{index [прив'язка, «модель»], «щупальце (аналогія)»}}

Ви повинні уявляти собі прив'язки як щупальця, а не як коробки. Вони не _містять_ значення, вони їх _хоплять_ - два зв'язування можуть посилатися на те саме значення. Програма може отримати доступ лише до тих значень, на які вона все ще має посилання. Коли вам потрібно щось запам'ятати, ви або відрощуєте щупальце, щоб утримати це, або приєднуєте до нього одне з ваших існуючих щупалець.

Погляньмо на інший приклад. Щоб запам'ятати кількість доларів, яку вам винен Луїджі, ви створюєте прив'язку. Коли він поверне вам 35 доларів, ви надасте цьому зв'язуванню нове значення.

```
нехай luigisDebt = 140;
luigisDebt = luigisDebt - 35;
console.log(luigisDebt);
// → 105
```

{{index undefined}}

Коли ви визначаєте прив'язку, не вказуючи її значення, щупальцю немає за що вхопитися, тому воно закінчується у повітрі. Якщо ви запитаєте значення порожнього зв'язування, ви отримаєте значення `undefined`.

{{index «ключове слово let»}}

Один оператор `let` може визначати декілька прив'язок. Визначення повинні бути розділені комами:

```
let one = 1, two = 2;
console.log(one + two);
// → 3
```

Слова `var` і `const` також можна використовувати для створення прив'язок, подібно до `let`.

```
var name = «Ayda»;
const greeting = «Hello »;
console.log(greeting + name);
// → Привіт, Айдо
```

{{index «var keyword»}}

Перше з них, `var` (скорочення від «змінна») - це спосіб оголошення прив'язок у JavaScript до 2015 року, коли `let` ще не існувало. Я повернуся до того, чим саме він відрізняється від `let` у [наступному розділі] (функції). А поки що запам'ятайте, що вона здебільшого робить те саме, але в цій книзі ми будемо рідко її використовувати, оскільки в деяких ситуаціях вона поводиться дивно.

{{index «ключове слово const», naming}}

Слово `const` розшифровується як _((константа))_. Воно визначає константну прив'язку, яка вказує на одне і те ж значення протягом усього часу існування. Це корисно для прив'язок, які просто дають ім'я значенню, щоб ви могли легко посилатися на нього пізніше.

## Імена прив'язок

{{індекс «символ підкреслення», «знак долара», [зв'язування, імена]}}

Імена прив'язок можуть бути будь-якою послідовністю з однієї або декількох літер. Цифри можуть бути частиною назви прив'язки - наприклад, `catch22` є допустимою назвою, - але назва не повинна починатися з цифри. Ім'я зв'язування може містити знаки долара (`$`) або підкреслення (`_`), але не інші розділові знаки або спеціальні символи.

{{index [синтаксис, ідентифікатор], «implements (зарезервоване слово)», «interface (зарезервоване слово)», «package (зарезервоване слово)», «private (зарезервоване слово)», «protected (зарезервоване слово)», «public (зарезервоване слово)», «static (зарезервоване слово)», «void оператор», «yield (зарезервоване слово)», «enum (зарезервоване слово)», «зарезервоване слово», «зарезервоване слово», «зарезервоване слово», «зв'язування», «імена]}}

Слова зі спеціальним значенням, такі як `let`, є _((ключовим словом))s_, і їх не можна використовувати як імена зв'язування. Існує також ряд слів, які є «зарезервованими для використання» у ((майбутніх)) версіях JavaScript, які також не можна використовувати як імена зв'язування. Повний список ключових і зарезервованих слів досить довгий:

```{lang: «null"}}
break case catch class const continue debugger default
delete do else enum export extends false finally for
функція if реалізує інтерфейс import в екземплярі let
new package private protected public return static super
switch this throw true try typeof var void while with yield
```

{{індекс [синтаксис, помилка]}}

Не турбуйтеся про запам'ятовування цього списку. Якщо при створенні зв'язування виникає неочікувана синтаксична помилка, перевірте, чи не намагаєтесь ви визначити зарезервоване слово.

## Оточення

{{index «standard environment», [браузер, середовище]}}

Сукупність прив'язок та їхніх значень, що існують у певний момент часу, називається _((оточення))_. Коли програма запускається, це оточення не є порожнім. Воно завжди містить прив'язки, які є частиною мови ((стандартні)), і здебільшого воно також містить прив'язки, які надають способи взаємодії з навколишньою системою. Наприклад, у браузері є функції для взаємодії з поточно завантаженим веб-сайтом та для читання ((миша)) і ((клавіатура)) вводу.

## Функції

{{indexsee «застосування (функцій)», [функція, застосування]}}
{{indexsee «виклик (функцій)», [функція, програма]}}
{{indexsee «виклик (функцій)», [функція, додаток]}}
{{індекс виведення, функція, [функція, програма], [браузер, середовище]}}

Багато значень, що надаються у середовищі за замовчуванням, мають тип _((функція))_. Функція - це частина програми, загорнута у значення. Такі значення можна _застосовувати_ для запуску обгорнутої програми. Наприклад, у середовищі браузера зв'язка `prompt` містить функцію, яка показує невелике вікно ((діалогове вікно)) із запитом на введення даних користувачем. Вона використовується таким чином:

```
prompt(«Введіть пароль»);
```

{{figure {url: «img/prompt.png», alt: «Діалогове вікно з запитом «введіть пароль»», width: “8cm”}}} {{figure {url: “gif”, alt: “alt”, width: “8cm”}}}

{{параметр індексу, [функція, додаток], [дужки, аргументи]}}

Виконання функції називається _викликом_, _викликом_ або _застосуванням_ її. Ви можете викликати функцію, поставивши дужки після виразу, який створює значення функції. Зазвичай ви безпосередньо використовуєте ім'я прив'язки, яка містить функцію. Значення між дужками передаються програмі всередині функції. У прикладі функція `prompt` використовує рядок, який ми надали їй як текст для показу у діалоговому вікні. Значення, що передаються функціям, називаються _((аргумент))s_. Різні функції можуть потребувати різної кількості або різних типів аргументів.

Функція `prompt` мало використовується у сучасному веб-програмуванні, головним чином тому, що ви не можете контролювати вигляд отриманого діалогового вікна, але вона може бути корисною у іграшкових програмах та експериментах.

## Функція console.log

{{index «JavaScript console», «tools of developer», «Node.js», «console.log», output, [browser, environment]}}

У прикладах я використовував `console.log` для виведення значень. Більшість систем JavaScript (включаючи всі сучасні веб-браузери та Node.js) надають функцію `console.log`, яка виводить свої аргументи на _деякий_ пристрій виводу тексту. У браузерах вивід потрапляє у ((консоль JavaScript)). Ця частина інтерфейсу браузера за замовчуванням прихована, але більшість браузерів відкривають її, коли ви натискаєте F12 або, на комп'ютері Mac, [команда]{ім'я користувача}-[опція]{ім'я користувача}-I. Якщо це не спрацювало, знайдіть у меню пункт з назвою Інструменти розробника або подібною.

{{якщо інтерактивний

Під час запуску прикладів (або вашого власного коду) на сторінках цієї книги виведення `console.log` буде показано після прикладу, а не в консолі JavaScript браузера.

```
нехай x = 30;
console.log(«значення x дорівнює», x);
// → значення x дорівнює 30
```

if}}

{{індекс [об'єкт, властивість], [властивість, доступ]}}

Хоча імена зв'язування не можуть містити ((символ крапки))s, `console.log` має такий символ. Це тому, що `console.log` - не просте прив'язування, а вираз, який отримує властивість `log` зі значення, що зберігається у прив'язці `console`. Ми з'ясуємо, що саме це означає, у [Глава ?](дані#властивості).

{{id return_values}}
## Значення, що повертаються

{{index [порівняння, «чисел»], «значення, що повертається», «функція Math.max», maximum}}

Показ діалогового вікна або запис тексту на екран є _((побічним ефектом))_. Багато функцій є корисними завдяки побічним ефектам, які вони створюють. Функції також можуть створювати значення, у цьому випадку їм не обов'язково мати побічний ефект, щоб бути корисними. Наприклад, функція `Math.max` приймає будь-яку кількість числових аргументів і повертає найбільше.

```
console.log(Math.max(2, 4));
// → 4
```

{{index [функція, додаток], minimum, «Math.min функція»}}

Коли функція виводить значення, кажуть, що вона _повертає_ це значення. Усе, що повертає значення, є ((виразом)) у JavaScript, а це означає, що виклики функцій можна використовувати у складі більших виразів. У наступному коді виклик функції `Math.min`, яка є протилежною до `Math.max`, використовується як частина виразу зі знаком плюс:

```
console.log(Math.min(2, 4) + 100);
// → 102
```

[Глава ?](функції) пояснює, як писати власні функції.

## Потік керування

{{index «порядок виконання», program, «потік управління»}}

Якщо ваша програма містить більше одного ((оператора)), оператори виконуються так, ніби це історія, зверху донизу. Наприклад, наступна програма містить два оператори. Перший запитує у користувача число, а другий, який виконується після першого, показує ((квадрат)) цього числа:

```
нехай theNumber = Number(prompt(«Виберіть число»));
console.log("Ваше число є квадратним коренем з » +
            theNumber * theNumber);
```

{{index [число, «перетворення до»], «примус типу», «Числова функція», «Рядкова функція», «Булева функція», [Булева, «перетворення до»]}}

Функція `Number` перетворює значення на число. Нам потрібне це перетворення, оскільки результатом функції `prompt` є рядкове значення, а нам потрібне число. Існують аналогічні функції `String` і `Boolean`, які перетворюють значення у ці типи.

Ось досить тривіальне схематичне зображення прямолінійного потоку управління:

{{figure {url: «img/controlflow-straight.svg», alt: «Діаграма з прямою стрілкою», width: “4cm”}}}

## Умовне виконання

{{index Boolean, [«control flow», conditional]}}

Не всі програми є прямими дорогами. Наприклад, нам може знадобитися створити розгалужену дорогу, де програма обирає потрібне відгалуження залежно від ситуації, що склалася. Це називається _((умовне виконання))_.

{{figure {url: «img/controlflow-if.svg», alt: «Діаграма стрілки, яка розділяється навпіл, а потім знову з'єднується»,width: “4cm”}}}}

{{index [синтаксис, оператор], «Числова функція», «ключове слово if»}}

Умовне виконання створюється за допомогою ключового слова `if` у JavaScript. У найпростішому випадку ми хочемо, щоб деякий код виконувався тоді і тільки тоді, коли виконується певна умова. Наприклад, ми можемо захотіти показати квадрат вхідних даних, тільки якщо вхідні дані дійсно є числом:

```{test: wrap}
нехай theNumber = Number(prompt(«Виберіть число»));
if (!Number.isNaN(theNumber)) {
  console.log("Ваше число є квадратним коренем з » +
              theNumber * theNumber);
}
```

З цією модифікацією, якщо ви введете «папуга», виведення не буде показано.

{{індекс [дужки, оператор]}}

Ключове слово `if` виконує або пропускає оператор залежно від значення булевого виразу. Вирішальний вираз записується після ключового слова у круглих дужках, за яким слідує оператор, що виконується.

{{індекс «Функція Number.isNaN»}}

Функція `Number.isNaN` - це стандартна функція JavaScript, яка повертає значення `true`, тільки якщо її аргумент має значення `NaN`. Функція `Number` повертає значення `NaN`, коли ви передаєте їй рядок, який не є дійсним числом. Таким чином, умова перекладається як «якщо `число` не є числом, виконати це».

{{групування індексів, «{} (блок)», [дужки, «блок»]}}

У цьому прикладі оператор після `if` взято у фігурні дужки (`{` і `}`). Дужки можна використовувати для об'єднання будь-якої кількості операторів в один оператор, який називається _((блок))_. У цьому випадку їх можна було б і не використовувати, оскільки вони утримують лише один оператор, але щоб не думати про те, чи потрібні вони, більшість програмістів JavaScript використовують їх у кожному подібному обгорнутому операторі. У цій книзі ми здебільшого дотримуватимемося цієї конвенції, за винятком окремих однорядкових операторів.

```
if (1 + 1 == 2) console.log(«It's true»);
// → It's true
```

{{індекс «ключове слово else»}}

Часто вам потрібен не лише код, який виконується, коли умова є істинною, але й код, який обробляє інший випадок. Цей альтернативний шлях показано другою стрілкою на діаграмі. Ви можете використовувати ключове слово `else` разом з `if` для створення двох окремих, альтернативних шляхів виконання:

```{test: wrap}
нехай theNumber = Number(prompt(«Виберіть число»));
if (!Number.isNaN(theNumber)) {
  console.log("Ваше число є квадратним коренем з » +
              theNumber * theNumber);
} else {
  console.log(«Привіт. Чому ви не дали мені число?»);
}
```

{{index [«ключове слово if», chaining]}}

Якщо у вас є більше двох шляхів на вибір, ви можете «з'єднати» декілька пар `if`/`else` разом. Ось приклад:

```
нехай num = Number(prompt(«Виберіть число»));

if (num < 10) {
  console.log(«Small»);
} else if (num < 100) {
  console.log(«Medium»);
} else {
  console.log(«Large»);
}
```

Спочатку програма перевірить, чи `num` менше 10. Якщо так, то вона вибирає цю гілку, показує `«Small»` і завершує роботу. Якщо ні, то вона переходить у гілку `else`, яка містить друге `if`. Якщо друга умова (`< 100`) виконується, це означає, що число не менше 10, але менше 100, і показується `«Medium»`. Якщо ні, то вибирається друга і остання гілка `else`.

Схема цієї програми виглядає приблизно так

{{figure {url: «img/controlflow-nested-if.svg», alt: «Діаграма, що показує стрілку, яка розщеплюється надвоє, а потім знову розщеплюється, доки всі гілки не з'єднаються знову», width: “4cm”}}}}

{{id циклів}}
## цикли while та do

Розглянемо програму, яка виводить усі ((парні числа)) від 0 до 12. Один із способів написати її наступним чином:

```
console.log(0);
console.log(2);
console.log(4);
console.log(6);
console.log(8);
console.log(10);
console.log(12);
```

{{index [«control flow», loop]}}

Це працює, але ідея написання програми полягає в тому, щоб змусити працювати щось _менше_, а не більше. Якби нам були потрібні всі парні числа, менші за 1,000, такий підхід був би непрацездатним. Нам потрібен спосіб запустити фрагмент коду кілька разів. Така форма потоку керування називається _((цикл))_.

{{figure {url: «img/controlflow-loop.svg», alt: «Діаграма, що показує стрілку до точки, яка має циклічну стрілку, що повертається до самої себе, та іншу стрілку, що йде далі», width: “4cm”}}}}

{{index [синтаксис, оператор], «змінна-лічильник»}}

Циклічний потік керування дозволяє нам повернутися до певної точки програми, де ми були раніше, і повторити її з нашим поточним станом програми. Якщо ми поєднаємо це з прив'язкою, яка рахує, ми зможемо зробити щось на зразок цього:

```
нехай number = 0
while (number <= 12) {
  console.log(number);
  number = number + 2;
}
// → 0
// → 2
// ... і так далі
```

{{індекс «цикл while», Boolean, [дужки, оператор]}}

Оператор ((інструкція)), що починається з ключового слова `while`, створює цикл. За словом `while` слідує ((вираз)) у круглих дужках, а потім оператор, подібно до `if`. Цикл продовжує вводити цей оператор до тих пір, поки вираз не отримає значення, яке при перетворенні на булеве буде рівне `істина`.

{{індекс [стан, у зв'язуванні], [зв'язування, як стан]}}

Зв'язування `числа` демонструє спосіб, у який ((зв'язування)) може відстежувати хід виконання програми. Кожного разу, коли цикл повторюється, `number` отримує значення, яке на 2 більше за його попереднє значення. На початку кожного повторення воно порівнюється з числом 12, щоб вирішити, чи завершено роботу програми.

{{розкладання індексів}}

Як приклад, який дійсно робить щось корисне, ми можемо написати програму, яка обчислює і показує значення 2^10^ (2 у 10-му степені). Ми використовуємо два зв'язування: одне для відстеження нашого результату, а інше для підрахунку того, як часто ми множили цей результат на 2. Цикл перевіряє, чи досягло друге зв'язування значення 10, і якщо ні, то оновлює обидва зв'язування.

```
let result = 1;
let counter = 0
while (counter < 10) {
  result = result * 2;
  counter = counter + 1;
}
console.log(result);
// → 1024
```

Лічильник також міг би починатися з `1` і перевіряти на `<= 10`, але з причин, які стануть очевидними у [Глава ?](data#array_indexing), варто звикнути рахувати з 0.

{{index «** оператор»}}

Зверніть увагу, що у JavaScript також є оператор піднесення до степеня (`2 ** 10`), який можна було б використати для обчислення цього у реальному коді - але це б зіпсувало приклад.

{{index «тіло циклу», «do loop», [«потік керування», loop]}}

Цикл `do` - це структура управління, подібна до циклу `while`. Відмінність полягає лише в тому, що цикл `do` завжди виконує своє тіло принаймні один раз, і він починає перевіряти, чи повинен він зупинитися, лише після цього першого виконання. Щоб відобразити це, тест з'являється після тіла циклу:

```
нехай ваше ім'я;
do {`` yourName = prompt(«Хто ви?»)
  yourName = prompt(«Хто ви?»);
} while (!yourName);
console.log("Hello » + yourName);
```

{{index [Boolean, «перетворення в»], «! оператор»}}

Ця програма змусить вас ввести ім'я. Вона запитуватиме знову і знову, доки не отримає щось, що не є порожнім рядком. Застосування оператора `!` перетворить значення до булевого типу перед запереченням, і всі рядки, крім `«»`, перетворяться до значення `істина`. Це означає, що цикл продовжуватиметься доти, доки ви не введете непорожнє ім'я.

## Код відступів

{{index [код, «структура»], [пробіли, відступ], «стиль програмування»}}

У прикладах я додавав пробіли перед операторами, які є частиною якогось більшого оператора. Ці пробіли не є обов'язковими - комп'ютер сприйме програму і без них. Насправді, навіть розриви ((рядок)) у програмах не є обов'язковими. Ви можете написати програму у вигляді одного довгого рядка, якщо вам так хочеться.

Роль цих ((відступів)) всередині ((блоків)) полягає в тому, щоб зробити структуру коду помітною для читачів-людей. У коді, де нові блоки відкриваються всередині інших блоків, може бути важко зрозуміти, де закінчується один блок і починається інший. При правильному відступі візуальна форма програми відповідає формі блоків всередині неї. Мені подобається використовувати два пробіли для кожного відкритого блоку, але смаки різняться - хтось використовує чотири пробіли, а хтось - ((символ табуляції))s. Важливо те, що кожен новий блок додає однакову кількість пробілів.

```
if (false != true) {
  console.log(«Це має сенс.»);
  if (1 < 2) {
    console.log(«Тут немає нічого дивного.»);
  }
}
```

Більшість програм ((редакторів)) коду [(у тому числі й у цій книзі)]{якщо вони інтерактивні} допоможуть, автоматично відступаючи нові рядки на потрібну величину.

## для циклів

{{індекс [синтаксис, оператор], «цикл», «змінна-лічильник»}}

Багато циклів працюють за шаблоном, показаним у прикладах з `while`. Спочатку створюється прив'язка «лічильник», щоб відстежувати хід виконання циклу. Потім йде цикл `while`, зазвичай з тестовим виразом, який перевіряє, чи лічильник досяг свого кінцевого значення. В кінці тіла циклу лічильник оновлюється для відстеження прогресу.

{{index «for loop», loop}}

Оскільки цей патерн є дуже поширеним, JavaScript та подібні мови надають дещо коротшу і більш повну форму - цикл `for`:

```
for (let number = 0; number <= 12; number = number + 2) {
  console.log(number);
}
// → 0
// → 2
// ... і так далі
```

{{index [«потік керування», loop], state}}

Ця програма повністю еквівалентна [попередньому](структура_програми#цикли) прикладу з виведенням парних чисел. Єдина зміна полягає у тому, що всі ((оператори)), які стосуються «стану» циклу, згруповано після `for`.

{{індекс [зв'язування, як стан], [дужки, оператор]}}

Дужки після ключового слова `for` повинні містити дві крапки з комою. Частина перед першою крапкою з комою _ініціалізує_ цикл, зазвичай шляхом визначення прив'язки. Друга частина - це ((вираз)), який _перевіряє_, чи потрібно продовжувати цикл. Заключна частина _оновлює_ стан циклу після кожної ітерації. У більшості випадків це коротше і зрозуміліше, ніж конструкція `while`.

{{розкладання індексу}}

Це код, який обчислює 2^10^ з використанням `for` замість `while`:

```{test: wrap}
let result = 1;
for (let counter = 0; counter < 10; counter = counter + 1) {
  result = result * 2;
}
console.log(result);
// → 1024
```

## Вихід з циклу

{{index [loop, «завершення»], «ключове слово break»}}

Якщо умова циклу видає значення `false` - це не єдиний спосіб завершення циклу. Оператор `break` має ефект негайного виходу з охоплюючого циклу. Його використання продемонстровано у наступній програмі, яка знаходить перше число, яке одночасно більше або дорівнює 20 і ділиться на 7:

```
for (let current = 20; ; current = current + 1) {
  if (current % 7 == 0) {
    console.log(current);
    break;
  }
}
// → 21
```

{{index «оператор остачі», «оператор %»}}

Використання оператора остачі (`%`) - це простий спосіб перевірити, чи ділиться число на інше число. Якщо так, то остача від їх ділення дорівнює нулю.

{{індекс «цикл for»}}

У конструкції `for` у прикладі немає частини, яка перевіряє кінець циклу. Це означає, що цикл ніколи не зупиниться, доки не буде виконано інструкцію `break` всередині.

Якщо ви видалите інструкцію `break` або випадково напишете кінцеву умову, яка завжди видає значення `true`, ваша програма застрягне у _((нескінченному циклі))_. Програма, що застрягла у нескінченному циклі, ніколи не завершить виконання, що зазвичай є поганим явищем.

{{якщо інтерактивний

Якщо ви створите нескінченний цикл в одному з прикладів на цих сторінках, вам зазвичай буде запропоновано зупинити скрипт через кілька секунд. Якщо це не вдасться зробити, вам доведеться закрити вкладку, у якій ви працюєте, щоб відновити роботу.

if}}

{{index «ключове слово continue»}}

Ключове слово `continue` подібне до `break` у тому, що воно впливає на хід виконання циклу. Коли в тілі циклу зустрічається `continue`, керування вискакує з тіла і продовжується з наступної ітерації циклу.

## Оновлення прив'язок лаконічно

{{присвоєння індексу, «+= оператор», «-= оператор», «/= оператор», «*= оператор», [стан, у прив'язці], «побічний ефект»}}

Особливо під час зациклення, програмі часто потрібно «оновити» зв'язування, щоб утримувати значення, засноване на попередньому значенні цього зв'язування.

```{test: no}
counter = counter + 1;
```

JavaScript надає для цього швидкий спосіб:

```{test: no}
counter += 1;
```

Подібні комбінації працюють і для багатьох інших операторів, наприклад, `result *= 2` для подвоєння `результату` або `counter -= 1` для зворотного відліку.

Це дозволяє нам ще більше скоротити наш приклад з підрахунком:

```
for (let number = 0; number <= 12; number += 2) {
  console.log(number);
}
```

{{індекс «оператор ++», «оператор --»}}

Для `counter += 1` та `counter -= 1` існують ще коротші еквіваленти: `counter++` та `counter--`.

## Диспетчеризація за значенням з допомогою switch

{{index [синтаксис, оператор], «умовне виконання», dispatch, [«ключове слово if», ланцюжок]}}

Нерідко код може виглядати так:

```{test: no}
if (x == «value1») action1();
else if (x == «value2») action2();
else if (x == «value3») action3();
else defaultAction();
```

{{index «символ двокрапки», «ключове слово switch»}}

Існує конструкція switch, яка призначена для більш прямого вираження такої «відправки». На жаль, синтаксис, який JavaScript використовує для цього (який він успадкував від мови програмування C/Java), дещо незручний - ланцюжок операторів `if` може виглядати краще. Ось приклад:

```
switch (prompt(«Яка погода?»)) {
  case «rainy»:
    console.log(«Не забудьте взяти парасольку.»);
    break;
  case «sunny»:
    console.log(«Одягайтесь легко.»);
  case «хмарно»:
    console.log(«Вийдіть на вулицю.»);
    break;
  за замовчуванням:
    console.log(«Невідомий тип погоди!»);
    break;
}
```

{{index fallthrough, «ключове слово break», «ключове слово case», «ключове слово default»}}

Ви можете помістити будь-яку кількість міток `case` всередині блоку, що відкривається ключем `witch`. Програма почне виконання з мітки, яка відповідає значенню, заданому ключу `witch`, або зі значенням `за замовчуванням`, якщо відповідного значення не знайдено. Програма продовжить виконання, навіть на інших мітках, доки не досягне оператора `break`. У деяких випадках, наприклад, у випадку `«sunny»` у прикладі, це може бути використано для розподілу коду між варіантами (рекомендується виходити на вулицю як у сонячну, так і у похмуру погоду). Однак будьте обережні - легко забути про такий «розрив», що призведе до того, що програма виконає код, який ви не хочете, щоб виконувався.

## Капіталізація

{{капіталізація індексів, [зв'язування, іменування], [пробіли, синтаксис]}}

Назви прив'язок можуть не містити пробілів, проте часто корисно використовувати кілька слів, щоб чітко описати, що являє собою прив'язка. Ось основні варіанти написання назви прив'язки з кількох слів:

```{lang: null}
fuzzylittleturtle
fuzzy_little_turtle
FuzzyLittleTurtle
fuzzyLittleTurtle
```

{{index «camel case», «стиль програмування», «символ підкреслення»}}

Перший стиль може бути важким для читання. Мені більше подобається вигляд підкреслень, хоча цей стиль трохи болючий для набору тексту. ((Стандартні)) функції JavaScript і більшість програмістів JavaScript дотримуються останнього стилю - вони пишуть з великої літери кожне слово, окрім першого. До таких дрібниць неважко звикнути, а код зі змішаними стилями іменування може бути незручним для читання, тому ми дотримуємося цього ((конвенції)).

{{індекс «Числова функція», конструктор}}

У деяких випадках, наприклад, у функції `Number`, перша літера зв'язування також пишеться з великої літери. Це зроблено для того, щоб позначити цю функцію як конструктор. Про те, що таке конструктор, стане зрозуміло у [Розділі ?](об'єкт#конструктори). Наразі, головне, щоб вас не турбувала ця очевидна відсутність ((узгодженості)).

## Коментарі

{{індекс читабельності}}

Часто сирий код не передає всієї інформації, яку ви хочете, щоб програма передавала читачам, або передає її у такий зашифрований спосіб, що люди можуть її не зрозуміти. Інколи ви можете просто захотіти включити деякі пов'язані з цим думки як частину вашої програми. Саме для цього призначено _((коментар))s_.

{{index «символ косої риски», «рядок коментаря»}}

Коментар - це фрагмент тексту, який є частиною програми, але повністю ігнорується комп'ютером. У JavaScript є два способи написання коментарів. Для написання однорядкового коментаря можна використати два символи косої риски (`//`), а після них - текст коментаря:

```{test: no}
let accountBalance = calculateBalance(account);
// Це зелена улоговина, де співає річка
accountBalance.adjust();
// Шалено ловить у траві білі клаптики.
let report = new Report();
// Де сонце на гордій горі дзвенить:
addToReport(accountBalance, report);
// Це маленька долина, що піниться, як світло в склянці.
```

{{index «block comment»}}

Коментар `//` переноситься тільки в кінець рядка. Фрагмент тексту між `/*` і `*/` буде проігноровано повністю, незалежно від того, чи містить він розриви рядків. Це корисно для додавання блоків інформації про файл або частину програми:

```
/*
  Вперше я знайшов цей номер, надряпаний на звороті старого
  блокнота. Відтоді він часто траплявся мені, з'являючись у
  телефонних номерах і серійних номерах товарів, які я
  купував. Очевидно, я йому подобаюся, тому я вирішив його зберегти.
*/
const myNumber = 11213;
```

## Підсумок

Тепер ви знаєте, що програма будується з операторів, які іноді містять більше операторів. Оператори, як правило, містять вирази, які в свою чергу можуть бути побудовані з менших виразів.

Розміщуючи оператори один за одним, ви отримуєте програму, яка виконується зверху донизу. Ви можете вносити збурення у потік керування за допомогою умовних операторів (`if`, `else` і `witch`) та операторів циклу (`while`, `do` і `for`).

Прив'язки можна використовувати для зберігання фрагментів даних під певним ім'ям, і вони корисні для відстеження стану вашої програми. Оточення - це набір визначених прив'язок. Системи JavaScript завжди додають до вашого оточення ряд корисних стандартних прив'язок.

Функції - це спеціальні значення, які інкапсулюють частину програми. Ви можете викликати їх, написавши `ім'я функції(аргумент1, аргумент2)`. Такий виклик функції є виразом і може створювати значення.

## Вправи

{{індекс вправ}}

Якщо ви не знаєте, як перевірити розв'язки вправ, зверніться до [вступу](intro).

Кожна вправа починається з опису задачі. Прочитайте цей опис і спробуйте розв'язати вправу. Якщо у вас виникнуть проблеми, зверніться до підказок [після вправи]{якщо інтерактивна}[у [кінці книги](підказки)]{якщо книжкова}. Ви можете знайти повні рішення вправ онлайн на [https://eloquentjavascript.net/code_](https://eloquentjavascript.net/code#2). Якщо ви хочете навчитися чомусь із вправ, я рекомендую переглядати розв'язки лише після того, як ви розв'язали вправу, або принаймні після того, як ви досить довго і наполегливо її розв'язували, щоб у вас злегка заболіла голова.

### Замикання трикутника в цикл

{{index «трикутник (вправа)»}}

Напишіть ((цикл)), який робить сім викликів `console.log` для виведення наступного трикутника:

```{lang: null}
#
##
###
####
#####
######
#######
```

{{index [рядок, довжина]}}

Можливо, вам буде корисно знати, що ви можете дізнатися довжину рядка, додавши після нього `.length`.

```
нехай abc = «abc»;
console.log(abc.length);
// → 3
```

{{якщо інтерактивно

Більшість вправ містять фрагмент коду, який ви можете змінити, щоб розв'язати вправу. Пам'ятайте, що ви можете клацати на блоках коду для їх редагування.

```
// Ваш код тут.
```
if}}

{{hint

{{index «трикутник (вправа)»}}

Ви можете почати з програми, яка виводить числа від 1 до 7, яку ви можете отримати, зробивши кілька змін у прикладі [виведення парних чисел](структура_програми#цикли), наведеному раніше у цій главі, де було введено цикл `for`.

Тепер розглянемо еквівалентність між числами і рядками хеш-символів. Ви можете перейти від 1 до 2, додавши 1 (`+= 1`). Ви можете перейти від `«#»` до `«##»`, додавши символ (`+= «#»`). Таким чином, ваш розв'язок може бути близьким до програми, яка друкує числа.

підказка}}

### FizzBuzz

{{index «FizzBuzz (вправа)», loop, «умовне виконання»}}

Напишіть програму, яка використовує `console.log` для виведення усіх чисел від 1 до 100, за двома винятками. Для чисел, що діляться на 3, замість числа виводити `«Fizz»`, а для чисел, що діляться на 5 (а не на 3), виводити `«Buzz»`.

Коли ви переконаєтесь, що це працює, модифікуйте програму так, щоб вона виводила «FizzBuzz» для чисел, які діляться і на 3, і на 5 (і все ще виводила «Fizz» або «Buzz» для чисел, які діляться лише на одне з цих чисел).

(Насправді це питання на співбесіді, яке, як стверджується, відсіває значний відсоток кандидатів на посаду програміста. Тож якщо ви його розв'язали, ваша вартість на ринку праці щойно зросла).

{{якщо інтерактивне
```
// Ваш код тут.
```
if}}

{{hint

{{індекс «FizzBuzz (вправа)», «оператор залишку», «оператор %»}}

Перебір чисел - це, очевидно, робота в циклі, а вибір того, що виводити, - це питання умовного виконання. Запам'ятайте прийом використання оператора остачі (`%`) для перевірки того, чи ділиться число на інше число (чи має остачу, рівну нулю).

У першій версії для кожного числа є три можливих результати, тому вам доведеться створити ланцюжок `if`/`else if`/`else`.

{{індекс «|| оператор», [«ключове слово if», ланцюжок]}}

У другій версії програми є просте і розумне рішення. Просте рішення полягає у додаванні ще однієї умовної «гілки» для точної перевірки заданої умови. Для розумного розв'язку створіть рядок, що містить слово або слова, які потрібно вивести, і виведіть або це слово, або число, якщо такого слова немає, можливо, добре використовуючи оператор `||`.

підказка}}

### Шахівниця

{{index «шахівниця (вправа)», loop, [вкладеність, «з циклів»], «символ нового рядка»}}

Напишіть програму, яка створює рядок, що представляє шахову дошку 8×8, використовуючи символи переходу на новий рядок для розділення рядків. У кожній позиції сітки знаходиться або пропуск, або символ «#». Символи повинні утворювати шахову дошку.

Передача цього рядка до `console.log` має вивести щось на кшталт цього:

```{lang: null}
 # # # #
# # # # 
 # # # #
# # # # 
 # # # #
# # # # 
 # # # #
# # # # 
```

Коли у вас є програма, яка генерує цей шаблон, визначте прив'язку ``size = 8`` і змініть програму так, щоб вона працювала для будь-якого ``size``, виводячи сітку заданої ширини і висоти.

{{якщо інтерактивний
```
// Ваш код тут.
```
if}}

{{hint

{{index «шахівниця (вправа)»}}

Ви можете побудувати рядок, почавши з порожнього (`«»`) і повторюючи додавання символів. Символ нового рядка записується `«\n»`.

{{index [вкладеність, «цикли»], [дужки, «блок»]}}

Для роботи з двома ((вимірами)) вам знадобиться ((цикл)) всередині циклу. Покладіть фігурні дужки навколо тіл обох циклів, щоб було легко бачити, де вони починаються і закінчуються. Намагайтеся робити правильні відступи між цими тілами. Порядок розташування петель повинен відповідати порядку, в якому ми створюємо рядок (рядок за рядком, зліва направо, зверху вниз). Таким чином, зовнішній цикл обробляє рядки, а внутрішній - символи у рядку.

{{індекс «змінна-лічильник», «оператор залишку», «оператор %»}}

Вам знадобляться дві прив'язки, щоб відстежувати прогрес. Щоб знати, чи потрібно ставити пробіл або хеш-знак у певній позиції, ви можете перевірити, чи сума двох лічильників парна (`% 2`).

Завершення рядка додаванням символу нового рядка повинно відбуватися після того, як рядок було побудовано, тому робіть це після внутрішнього циклу, але всередині зовнішнього циклу.

підказка}}
