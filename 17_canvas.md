{{meta {load_files: [«code/chapter/16_game.js», «code/levels.js», «code/_stop_keys.js», «code/chapter/17_canvas.js»], zip: «html include=[\«img/player.png\», \«img/sprites.png\»]"}}}}.

# Малювання на полотні

{{quote {автор: «M.C. Escher», title: 

Малюнок - це обман.
quote}}

{{index «Escher, M.C.»}}

{{figure {url: «img/chapter_picture_17.jpg», alt: «Ілюстрація, що показує руку робота промислового вигляду, яка малює місто на аркуші паперу», »chapter: «Обрамлення"}}}

{{index CSS, «transform (CSS)», [DOM, graphics]}}

Браузери надають нам декілька способів відображення ((графіки)). Найпростіший спосіб - це використання стилів для позиціонування і кольору звичайних елементів DOM. Це може завести нас досить далеко, як показала гра у [попередньому розділі](гра). Додавши частково прозоре тло ((зображення)) до вузлів, ми можемо зробити так, щоб вони виглядали саме так, як ми хочемо. Можна навіть обертати або нахиляти вузли за допомогою стилю `transform`.

Але ми будемо використовувати DOM для того, для чого він не був спочатку призначений. Деякі завдання, такі як малювання ((лінії)) між довільними точками, вкрай незручно виконувати за допомогою звичайних HTML-елементів.

{{index SVG, «img (HTML-тег)»}}

Існує дві альтернативи. Перша заснована на DOM, але використовує _Масштабовану векторну графіку_ (SVG), а не HTML. Подумайте про SVG як про діалект ((документ))-розмітки, який фокусується на ((форма)), а не на тексті. Ви можете вбудувати SVG-документ безпосередньо у HTML-документ або включити його за допомогою тегу `<img>`.

{{очищення індексів, [DOM-графіка], [інтерфейс, полотно]}}

Другий варіант називається _((полотно))_. Полотно - це один DOM-елемент, який інкапсулює ((зображення)). Він надає програмний інтерфейс для малювання ((фігур)) у просторі, зайнятому вузлом. Основна відмінність між полотном і SVG-зображенням полягає в тому, що в SVG зберігається оригінальний опис фігур, так що їх можна переміщати або змінювати розмір у будь-який час. Полотно, з іншого боку, перетворює фігури на ((пікселі)) (кольорові точки на растрі), як тільки вони намальовані, і не пам'ятає, що ці пікселі представляють. Єдиний спосіб перемістити фігуру на полотні - це очистити полотно (або частину полотна навколо фігури) і перемалювати його з фігурою в новому положенні.

## SVG

У цій книзі ми не розглядатимемо ((SVG)) детально, але я коротко поясню, як він працює. Наприкінці розділу](canvas#graphics_tradeoffs) я повернуся до компромісів, які ви повинні враховувати, вирішуючи, який механізм ((малювання)) підходить для конкретної програми.

Це HTML-документ з простим SVG-зображенням ((малюнком)) у ньому:

```{lang: html, sandbox: «svg»}
<p>Звичайний HTML тут.</p>
<svg xmlns=«http://www.w3.org/2000/svg»>
  <circle r=«50» cx=«50» cy=«50» fill=«red»/>
  <rect x=«120» y=«5» width=«90» height="90»
        
</svg>
```

{{index «circle (SVG-тег)», «rect (SVG-тег)», «простір імен XML», XML, «атрибут xmlns»}}

Атрибут `xmlns` змінює елемент (та його дочірні елементи) на інший  простір імен _XML_. Цей простір імен, ідентифікований за допомогою ((URL)), визначає діалект, яким ми зараз розмовляємо. Теги `<circle>` і `<rect>`, які не існують у HTML, мають значення у SVG - вони малюють фігури, використовуючи стиль і положення, визначені їхніми атрибутами.

{{if book

Документ відображається таким чином:

{{figure {url: «img/svg-demo.png», alt: «Знімок екрана із зображенням SVG, вбудованим у HTML-документ», width: “4.5cm”}}}}

if}}

{{index [DOM, графіка]}}

Ці теги створюють елементи DOM, так само як і теги HTML, з якими можуть взаємодіяти скрипти. Наприклад, це змінює елемент `<circle>` на ((колір))ed блакитний:

```{sandbox: «svg»}
let circle = document.querySelector(«circle»);
circle.setAttribute(«fill», «cyan»);
```

## Елемент canvas

{{index [canvas, size], «canvas (HTML-тег)»}}

Полотно ((графіку)) можна намалювати на елементі `<canvas>`. Ви можете надати такому елементу атрибути `width` та `height`, щоб визначити його розмір у ((пікселях))s.

Нове полотно є порожнім, тобто воно повністю ((прозоре)) і тому у документі відображається як порожній простір.

{{index «2d (контекст полотна)», «webgl (контекст полотна)», OpenGL, [полотно, контекст], dimensions, [інтерфейс, полотно]}}

Тег `<canvas>` призначено для забезпечення різних стилів ((малювання)). Щоб отримати доступ до реального інтерфейсу малювання, спочатку потрібно створити _((контекст))_, об'єкт, методи якого надають інтерфейс малювання. Наразі існує три широко підтримувані стилі малювання: ``2d`` для двовимірної графіки, ``webgl`` для тривимірної графіки через інтерфейс OpenGL та ``webgpu``, більш сучасна та гнучка альтернатива WebGL.

{{індексний рендеринг, графіка, ефективність}}

У цій книзі ми не будемо обговорювати WebGL або WebGPU - ми обмежимося двома вимірами. Але якщо вас цікавить тривимірна графіка, я рекомендую вам звернути увагу на WebGPU. Він надає прямий інтерфейс до графічного обладнання і дозволяє ефективно рендерити навіть складні сцени за допомогою JavaScript.

{{index «getContext method», [canvas, context]}}

Ви створюєте ((контекст)) за допомогою методу `getContext` на DOM-елементі `<canvas>`.

```{lang: html}
<p>Перед canvas.</p>
<canvas width=«120» height=«60»></canvas
<p>Після canvas.</p>
<скрипт
  let canvas = document.querySelector(«canvas»);
  let context = canvas.getContext(«2d»);
  context.fillStyle = «red»;
  context.fillRect(10, 10, 100, 50);
</script>
```

Після створення об'єкта контексту приклад малює червоний ((прямокутник)) шириною 100 ((пікселів)) і висотою 50 пікселів, верхній лівий кут якого має координати (10, 10).

{{if book

{{figure {url: «img/canvas_fill.png», alt: «Знімок полотна з прямокутником на ньому», width: “2.5cm”}}}}

if}}

{{індекс SVG, координати}}

Як і в HTML (і SVG), система координат, яку використовує полотно, ставить (0, 0) у верхній лівий кут, а додатна y-((вісь)) йде вниз звідти. Це означає, що (10, 10) знаходиться на 10 пікселів нижче і правіше верхнього лівого кута.

{{id fill_stroke}}

## Лінії та поверхні

{{index заливка, обведення, малювання, SVG}}

В інтерфейсі ((полотно)) фігуру можна _заповнити_, тобто надати її області певний колір або візерунок, або ж її можна _обвести_, тобто намалювати ((лінію)) вздовж її краю. SVG використовує ту ж саму термінологію.

{{index «метод fillRect», «метод strokeRect»}}

Метод `fillRect` зафарбовує ((прямокутник)). Він бере спочатку x- та y-((координати)) верхнього лівого кута прямокутника, потім його ширину, а потім висоту. Подібний метод, який називається `strokeRect`, малює ((контур)) прямокутника.

{{index [state, «of canvas»]}}

Жоден з методів не приймає додаткових параметрів. Колір заливки, товщина штриха тощо визначаються не аргументом методу, як можна було б очікувати, а властивостями контекстного об'єкта.

{{індекс заливки, «властивість fillStyle»}}

Властивість `fillStyle` контролює спосіб заповнення фігур. Вона може бути встановлена як рядок, що визначає ((колір)), використовуючи позначення кольорів, які використовуються у ((CSS)).

{{index stroking, «line width», «strokeStyle property», «lineWidth property», canvas}}

Властивість `strokeStyle` працює аналогічно, але визначає колір, який використовується для штрихованої лінії. Ширина цієї лінії визначається властивістю `lineWidth`, яка може містити будь-яке додатне число.

```{lang: html}
<canvas></canvas>
<script>
  нехай cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.strokeStyle = «blue»;
  cx.strokeRect(5, 5, 50, 50)
  cx.lineWidth = 5
  cx.strokeRect(135, 5, 50, 50);
</script> </span> </span> </span> </span> </span
```

{{if book

Цей код малює два синіх квадрати, використовуючи товстішу лінію для другого.

{{figure {url: «img/canvas_stroke.png», alt: «Знімок екрана з двома обведеними квадратами», width: “5cm”}}}}

if}}

{{index «значення за замовчуванням», [canvas, size]}}

Якщо не вказано атрибутів `width` або `height`, як у прикладі, елемент полотна отримує ширину за замовчуванням 300 пікселів і висоту 150 пікселів.

## Шляхи

{{index [path, canvas], [interface, design], [canvas, path]}}

Контур - це послідовність ((line))s. Інтерфейс 2D полотна має особливий підхід до опису такого шляху. Це робиться повністю через ((побічний ефект))s. Шляхи не є значеннями, які можна зберігати та передавати. Замість цього, якщо ви хочете щось зробити зі шляхом, ви робите послідовність викликів методів, щоб описати його форму.

```{lang: html}
<canvas></canvas>
<script>
  нехай cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.beginPath();
  for (let y = 10; y < 100; y += 10) {
    cx.moveTo(10, y);
    cx.lineTo(90, y);
  }
  cx.stroke();
</script>
```

{{index canvas, «stroke method», «lineTo method», «moveTo method», shape}}

У цьому прикладі створюється контур з декількох горизонтальних ((line)) сегментів, а потім зафарбовується за допомогою методу `stroke`. Кожен сегмент, створений за допомогою методу `lineTo`, починається з _поточної_ позиції контуру. Ця позиція зазвичай є кінцем останнього сегмента, якщо не було викликано `moveTo`. У цьому випадку наступний сегмент починається з позиції, переданої методу `moveTo`.

{{if book

Шлях, описаний у попередній програмі, має такий вигляд:

{{figure {url: «img/canvas_path.png», alt: «Знімок екрана з кількома вертикальними лініями», width: “2.1cm”}}}}

if}}

{{index [шлях, полотно], заливка, [шлях, закриття], «метод заливки»}}

При заповненні контуру (методом `fill`) кожна ((фігура)) заповнюється окремо. Контур може містити декілька фігур - кожен рух `moveTo` запускає нову фігуру. Але перед заповненням контур має бути _закритим_ (тобто його початок і кінець мають бути в одному положенні). Якщо контур ще не замкнуто, то від його кінця до початку додається лінія, і фігура, що міститься у завершеному контурі, зафарбовується.

```{lang: html}
<canvas></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.beginPath();
  cx.moveTo(50, 10);
  cx.lineTo(10, 70);
  cx.lineTo(90, 70);
  cx.fill();
</script>
```

Цей приклад малює зафарбований трикутник. Зверніть увагу, що лише дві сторони трикутника намальовано явно. Третя, від правого нижнього кута до верхнього, мається на увазі, і її не буде, якщо ви погладите контур.

{{if book

{{figure {url: «img/canvas_triangle.png», alt: «Знімок екрана із зафарбованим контуром», width: “2.2cm”}}}}

if}}

{{індекс «метод обведення», «метод закриття шляху», [шлях, закриття], полотно}}

Ви також можете використати метод `closePath` для явного закриття контуру, додавши фактичний ((лінійний)) відрізок назад до початку контуру. Цей відрізок _малюється_ при обведенні контуру.

## Криві

{{індекс [контур, полотно], полотно, малюнок}}

Контур також може містити ((криву))d ((лінію))s. На жаль, вони трохи складніші для малювання.

{{index «quadraticCurveTo метод»}}

Метод `quadraticCurveTo` малює криву до заданої точки. Щоб визначити кривизну лінії, методу задається ((контрольна точка)), а також точка призначення. Уявіть, що ця контрольна точка «притягує» лінію, надаючи їй кривизну. Лінія не буде проходити через контрольну точку, але її напрямок у початковій і кінцевій точках буде таким, що пряма у цьому напрямку буде вказувати на контрольну точку. Наступний приклад ілюструє це:

```{lang: html}
<canvas></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.beginPath();
  cx.moveTo(10, 90);
  // control=(60, 10) goal=(90, 90)
  cx.quadraticCurveTo(60, 10, 90, 90);
  cx.lineTo(60, 10);
  cx.closePath();
  cx.stroke();
</script>
```

{{if book

Виводить шлях, який виглядає наступним чином:

{{figure {url: «img/canvas_quadraticcurve.png», alt: «Знімок квадратичної кривої», width: “2.3cm”}}}}

if}}

{{index «метод обведення»}}

Ми малюємо ((квадратичну криву)) зліва направо з контрольною точкою (60, 10), а потім малюємо два ((лінію)) відрізки, що проходять через цю контрольну точку і повертаються до початку лінії. Результат дещо нагадує емблему _((Star Trek))_. Ви можете бачити ефект контрольної точки: лінії, що виходять з нижніх кутів, починають рухатися у напрямку контрольної точки, а потім ((крива)) до своєї мети.

{{index canvas, «bezierCurveTo method»}}

Метод `bezierCurveTo` малює подібну криву. Замість однієї ((контрольної точки)), цей метод має дві - по одній для кожної з кінцевих точок ((лінії)). Ось подібний ескіз для ілюстрації поведінки такої кривої:

```{lang: html}
<canvas></canvas>
<script>
  нехай cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.beginPath();
  cx.moveTo(10, 90);
  // control1=(10, 10) control2=(90, 10) goal=(50, 90)
  cx.bezierCurveTo(10, 10, 90, 10, 50, 90);
  cx.lineTo(90, 10);
  cx.lineTo(10, 10);
  cx.closePath();
  cx.stroke();
</script>
```

Дві контрольні точки задають напрямок на обох кінцях кривої. Чим далі вони відстоять від відповідної точки, тим більше крива буде «випуклою» у цьому напрямку.

{{if book

{{figure {url: «img/canvas_beziercurve.png», alt: «Скріншот кривої Безьє», width: “2.2cm”}}}}

if}}

{{index «trial and error»}}

З такими ((кривими)) може бути важко працювати - не завжди зрозуміло, як знайти ((контрольні точки)), які забезпечують ((форму)), яку ви шукаєте. Іноді їх можна обчислити, а іноді вам доведеться шукати відповідне значення методом спроб і помилок.

{{index «метод дуги», arc}}

Метод `дуги` - це спосіб побудови лінії, яка криволінійно проходить по краю кола. Він бере пару ((координат)) для центру дуги, радіус, а потім початковий і кінцевий кути.

{{index pi, «Math.PI константа»}}

Останні два параметри дозволяють намалювати лише частину кола. ((кут))s вимірюється у ((радіанах))s, а не у ((градусах))s. Це означає, що повне ((коло)) має кут 2π, або `2 * Math.PI`, що дорівнює приблизно 6.28. Кут починається з точки праворуч від центру кола і відраховується за годинниковою стрілкою. Ви можете використовувати початок 0 і кінець більший за 2π (скажімо, 7), щоб намалювати повне коло.

```{lang: html}
<canvas></canvas>
<script>
  нехай cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.beginPath();
  // center=(50, 50) radius=40 angle=0 to 7
  cx.arc(50, 50, 40, 0, 7);
  // center=(150, 50) radius=40 angle=0 to ½π
  cx.arc(150, 50, 40, 0, 0.5 * Math.PI);
  cx.stroke();
</script>
```

{{index «moveTo метод», «arc метод», [шлях, « canvas»]}}

Отримана картинка містить ((лінія)) справа від повного кола (перший виклик `arc`) і справа від чверті-((коло)) (другий виклик).

{{if book

{{figure {url: «img/canvas_circle.png», alt: «Скріншот кола», width: “4.9cm”}}}}

if}}

Як і інші методи малювання шляхів, лінія, намальована за допомогою `arc`, з'єднується з попереднім відрізком шляху. Щоб уникнути цього, можна викликати `moveTo` або почати новий шлях.

{{id pie_chart}}

## Малювання кругової діаграми

{{index «pie chart example»}}

Уявіть, що ви щойно влаштувалися на ((роботу)) в компанію EconomiCorp, Inc. Ваше перше завдання - побудувати кругову діаграму результатів опитування клієнтів.

Зв'язка `results` містить масив об'єктів, які представляють відповіді на опитування.

```{sandbox: «pie», includeCode: true}
const results = [
  {name: «Satisfied», count: 1043, color: «lightblue»},
  {name: «Neutral», count: 563, color: «lightgreen»},
  {name: «Незадоволені», count: 510, color: «pink»},
  {name: «Без коментарів», count: 175, color: «silver»}]; {name: «No comment», count: 175, color: «silver»}
];
```

{{index «pie chart example»}}

Щоб побудувати кругову діаграму, ми намалюємо декілька шматочків пирога, кожен з яких складається з ((дуга)) і пари ((лінія)) до центру цієї дуги. Ми можемо обчислити ((кут)), який займає кожна дуга, поділивши повне коло (2π) на загальну кількість відповідей, а потім помноживши це число (кут на відповідь) на кількість людей, які обрали певний варіант.

```{lang: html, sandbox: «pie»}
<canvas width=«200» height=«200»></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  let total = results
    .reduce((sum, {count}) => sum + count, 0);
  // Починаємо зверху
  let currentAngle = -0.5 * Math.PI;
  for (let result of results) {
    let sliceAngle = (result.count / total) * 2 * Math.PI;
    cx.beginPath();
    // center=100,100, radius=100
    // від поточного кута, за годинниковою стрілкою на кут зрізу
    cx.arc(100, 100, 100,
           currentAngle, currentAngle + sliceAngle);
    currentAngle += sliceAngle;
    cx.lineTo(100, 100);
    cx.fillStyle = result.color;
    cx.fill();
  }
</script> </script> </script> </script> </script> </script> <
```

{{if book

Це створить наступну діаграму:

{{figure {url: «img/canvas_pie_chart.png», alt: «Знімок екрана із зображенням кругової діаграми», width: “5cm”}}}}

if}}

Але діаграма, яка не говорить нам, що означають зрізи, не дуже корисна. Нам потрібен спосіб намалювати текст на ((полотно)).

## Текст

{{індекс обведення, заповнення, «властивість fillStyle», «метод fillText», «метод strokeText»}}

Контекст малювання 2D полотна надає методи `fillText` та `strokeText`. Останній може бути корисним для обведення літер, але зазвичай вам потрібен метод `fillText`. Він заповнить контур заданого ((тексту)) поточним `fillStyle`.

```{lang: html}
<canvas></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.font = «28px Georgia»;
  cx.fillStyle = «fuchsia»
  cx.fillText(«Я теж вмію малювати текст!», 10, 50);
</script>
```

За допомогою властивості `font` можна вказати розмір, стиль і ((шрифт)) тексту. У цьому прикладі задано лише розмір шрифту та його назву. Також можна додати `italic` або `bold` на початку рядка для вибору стилю.

{{index «метод fillText», «метод strokeText», «властивість textAlign», «властивість textBaseline»}}

Останні два аргументи методів `fillText` і `strokeText` визначають позицію, у якій буде намальовано шрифт. За замовчуванням вони вказують позицію початку алфавітної базової лінії тексту, яка є лінією, на якій «стоять» літери, не враховуючи висячих частин у літерах, таких як _j_ або _p_. Ви можете змінити положення по горизонталі, встановивши властивість `textAlign` у значення `end` або `center`, а положення по вертикалі - у значення `textBaseline` у значення `top`, `middle` або `down`.

{{index «pie chart example»}}

Ми повернемося до нашої кругової діаграми та проблеми ((підпису))вання зрізів у [вправах](canvas#вправа_кругова_діаграма) наприкінці розділу.

## Зображення

{{index «векторна графіка», «растрова графіка»}}

У комп'ютерній графіці часто розрізняють _векторну_ графіку та _растрову_ графіку. Перша - це те, чим ми займалися дотепер у цій главі - визначенням зображення за допомогою логічного опису ((фігури)). З іншого боку, растрова графіка не описує власне фігури, а працює з даними ((піксель)) (растрами кольорових точок).

{{index «load event», «event handling», «img (HTML tag)», «drawImage method»}}

Метод `drawImage` дозволяє нам намалювати дані ((пікселі)) на ((полотно)). Ці піксельні дані можуть походити з елемента `<img>` або з іншого полотна. У наступному прикладі створюється окремий елемент `<img>` і до нього завантажується файл зображення. Але метод не може одразу почати малювати з цього зображення, оскільки браузер ще не встиг його завантажити. Щоб вирішити цю проблему, ми реєструємо обробник події ``load`` і виконуємо малювання після того, як зображення буде завантажено.

```{lang: html}
<canvas></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  let img = document.createElement(«img»);
  img.src = «img/hat.png»;
  img.addEventListener(«load», () => {})
    for (let x = 10; x < 200; x += 30) {
      cx.drawImage(img, x, 10);
    }
  });
</script> </script> </script> </script> </script> </script> </script
```

{{index «drawImage method», scaling}}

За замовчуванням, `drawImage` намалює зображення у його початковому розмірі. Ви також можете передати йому два додаткові аргументи, щоб вказати ширину і висоту намальованого зображення, якщо вони відрізняються від вихідного зображення.

Якщо команді `drawImage` надано _дев'ять_ аргументів, вона може бути використана для малювання лише фрагмента зображення. Другий-п'ятий аргументи вказують на прямокутник (x, y, ширину та висоту) у вихідному зображенні, який слід скопіювати, а шостий-дев'ятий - на прямокутник (на полотні), куди його слід скопіювати.

{{index «player», «pixel art»}}

Це може бути використано для пакування декількох _((спрайтів))s_ (елементів зображення) в один файл зображення і подальшого малювання лише тієї частини, яка вам потрібна. Наприклад, ця картинка містить ігрового персонажа у декількох ((pose))s:

{{figure {url: «img/player_big.png», alt: «Піксельний арт із зображенням персонажа комп'ютерної гри у 10 різних позах. Перші 8 утворюють його біжучий анімаційний цикл, на 9-й персонаж стоїть на місці, а на 10-й - стрибає.», width: “6cm”}}}}

{{index [animation, «platform game»]}}

Чергуючи позу, яку ми малюємо, ми можемо показати анімацію, яка виглядає як персонаж, що ходить.

{{index «fillRect method», «clearRect method», clearing}}

Для анімації ((зображення)) на ((полотні)) корисним є метод `clearRect`. Він схожий на `fillRect`, але замість того, щоб зафарбовувати прямокутник, він робить його ((прозорим)), видаляючи попередньо намальовані пікселі.

{{index «setInterval function», «img (HTML-тег)»}}

Ми знаємо, що кожен _((спрайт))_, кожне підзображення, має ширину 24 ((пікселі))с і висоту 30 пікселів. Наступний код завантажує зображення, а потім встановлює інтервал (повторюваний таймер) для малювання наступного ((кадру)):

```{lang: html}
<canvas></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  let img = document.createElement(«img»);
  img.src = «img/player.png»;
  нехай spriteW = 24, spriteH = 30;
  img.addEventListener(«load», () => {
    let cycle = 0;
    setInterval(() => {
      cx.clearRect(0, 0, spriteW, spriteH);
      cx.drawImage(img,
                   // вихідний прямокутник
                   cycle * spriteW, 0, spriteW, spriteH,
                   // прямокутник-приймач
                   0, 0, spriteW, spriteH);
      cycle = (cycle + 1) % 8;
    }, 120);
  });
</script>
```

{{index «оператор залишку», «оператор %», [animation, «platform game»]}}

Зв'язка `cycle` відстежує нашу позицію в анімації. Для кожного ((кадру)) вона збільшується, а потім обрізається назад до діапазону від 0 до 7 за допомогою оператора залишку. Потім ця прив'язка використовується для обчислення x-координати, яку має спрайт для поточної позиції на зображенні.

## Перетворення

{{перетворення індексів, дзеркальне відображення}}

{{indexsee перевертання, дзеркальне відображення}}

А якщо ми хочемо, щоб наш персонаж ходив ліворуч, а не праворуч? Звісно, можна намалювати інший набір спрайтів. Але ми також можемо наказати ((canvas)) намалювати картину навпаки.

{{index «scale method», масштабування}}

Виклик методу `scale` призведе до масштабування всього намальованого після нього. Цей метод приймає два параметри, один для встановлення горизонтального масштабу, інший для встановлення вертикального масштабу.

```{lang: html}
<canvas></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  cx.scale(3, .5);
  cx.beginPath();
  cx.arc(50, 50, 40, 0, 7);
  cx.lineWidth = 3;
  cx.stroke();
</script>
```

{{if book

Через виклик `scale` коло малюється втричі ширшим і вдвічі меншим за висотою.

{{figure {url: «img/canvas_scale.png», alt: «Знімок масштабованого кола», width: “6.6cm”}}}}

if}}

{{Дзеркальне відображення індексів}}

Масштабування призведе до розтягування або стискання всього намальованого зображення, включно з ((шириною лінії)), відповідно до вказаних параметрів. Масштабування на від'ємну величину переверне зображення. Перевертання відбувається навколо точки (0, 0), а це означає, що напрямок системи координат також зміниться. Якщо застосовано горизонтальне масштабування -1, фігура, намальована у позиції _x_ 100, опиниться у позиції, яка раніше була позицією -100.

{{index «drawImage method»}}

Щоб розвернути малюнок, ми не можемо просто додати `cx.scale(-1, 1)` перед викликом `drawImage`. Це призведе до переміщення нашого зображення за межі ((полотна)), де його не буде видно. Ми можемо скоригувати ((координати)), передані `drawImage`, щоб компенсувати це, намалювавши зображення у позиції _x_ -50 замість 0. Іншим рішенням, яке не вимагає від коду, що виконує малювання, знати про зміну масштабу, є коригування ((вісь)), навколо якої відбувається масштабування.

{{індекс «метод обертання», «метод перетворення», трансформація}}

Існує декілька інших методів, окрім `scale`, які впливають на систему координат для ((полотно)). Ви можете обертати намальовані фігури за допомогою методу `rotate` і переміщувати їх за допомогою методу `translate`. Цікавим і заплутаним є те, що ці перетворення «стекуються», тобто кожне з них відбувається відносно попередніх.

{{index «rotate method», «translate method»}}

Якщо ми двічі переведемо на 10 горизонтальних пікселів, то все буде перемальовано на 20 пікселів правіше. Якщо ми спочатку перемістимо центр системи координат у точку (50, 50), а потім повернемо на 20 ((градусів))с (приблизно 0.1π ((радіан))с), то цей поворот відбудеться _навколо_ точки (50, 50).

{{figure {url: «img/transform.svg», alt: «Діаграма, що показує результат стекових перетворень. Перша діаграма перекладається, а потім обертається, що призводить до нормального перекладу і обертання навколо цілі перекладу. Друга діаграма спочатку обертається, а потім перекладається, що призводить до обертання навколо початку координат і нахилу напрямку перекладу в результаті цього обертання.», width: “9cm”}}}

{{індексні координати}}

Але якщо ми  спочатку повернемо на 20 градусів, а  потім переведемо на (50, 50), то переведення відбудеться у повернутій системі координат і, таким чином, дасть іншу орієнтацію. Порядок застосування перетворень має значення.

{{індексна вісь, дзеркальне відображення}}

Щоб перевернути зображення навколо вертикальної лінії у заданій позиції _x_, ми можемо зробити наступне:

```{includeCode: true}}
function flipHorizontally(context, around) {
  context.translate(around, 0);
  context.scale(-1, 1);
  context.translate(-around, 0);
}
```

{{index «метод flipHorizontally»}}

Ми переміщуємо вісь y ((вісь)) туди, де ми хочемо бачити наше ((дзеркало)), застосовуємо віддзеркалення, і, нарешті, повертаємо вісь y на її належне місце у віддзеркаленому всесвіті. Наступний малюнок пояснює, як це працює:

{{figure {url: «img/mirror.svg», alt: «Діаграма, що показує ефект трансляції та дзеркального відображення трикутника», width: “8cm”}}}

{{index «translate method», «scale method», transformation, canvas}}

Тут показано системи координат до і після дзеркального відображення через центральну лінію. Трикутники пронумеровано для ілюстрації кожного кроку. Якщо ми малюємо трикутник у додатній позиції _x_, він за замовчуванням буде у місці, де знаходиться трикутник 1. Виклик `flipHorizontally` спочатку робить переклад праворуч, що приводить нас до трикутника 2. Потім він масштабується, перевертаючи трикутник у позицію 3. Це не те місце, де він мав би бути, якби він був дзеркально відображений у даному рядку. Другий виклик `translate` виправляє це - він «скасовує» початкове переведення і змушує трикутник 4 з'явитися саме там, де він має бути.

Тепер ми можемо намалювати дзеркальний символ у позиції (100, 0), перевернувши світ навколо вертикального центру символу.

```{lang: html}
<canvas></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  let img = document.createElement(«img»);
  img.src = «img/player.png»;
  нехай spriteW = 24, spriteH = 30;
  img.addEventListener(«load», () => {
    flipHorizontally(cx, 100 + spriteW / 2);
    cx.drawImage(img, 0, 0, spriteW, spriteH,
                 100, 0, spriteW, spriteH);
  });
</script>
```

## Зберігання та очищення перетворень

{{index «side effect», canvas, transformation}}

Трансформації зберігаються. Все інше, що ми намалюємо після ((малювання)) цього дзеркального персонажа, також буде дзеркальним. Це може бути незручно.

Можна зберегти поточну трансформацію, виконати деяке малювання і трансформацію, а потім відновити стару трансформацію. Зазвичай це правильний спосіб для функції, яка потребує тимчасового перетворення системи координат. Спочатку ми зберігаємо будь-яке перетворення, яке використовував код, що викликав функцію. Потім функція робить свою справу, додаючи нові перетворення до поточного перетворення. Нарешті, ми повертаємося до перетворення, з якого почали.

{{index «метод збереження», «метод відновлення», [state, «of canvas»]}}

Методи ``зберегти`` і ``відновити`` у 2D контексті ((полотно)) виконують це ((трансформація)) керування. Вони концептуально зберігають стек станів трансформації. Коли ви викликаєте `save`, поточний стан заноситься до стеку, а коли ви викликаєте `restore`, стан на вершині стеку знімається і використовується як поточна трансформація контексту. Ви також можете викликати `resetTransform` для повного скидання перетворення.

{{index «branching recursion», «fractal example», recursion}}

Функція `branch` у наступному прикладі ілюструє, що можна зробити за допомогою функції, яка змінює перетворення, а потім викликає функцію (у цьому випадку саму себе), яка продовжує малювання із заданим перетворенням.

Ця функція малює деревоподібну фігуру, малюючи лінію, переміщуючи центр системи координат на кінець лінії і двічі викликаючи саму себе - спочатку з поворотом вліво, а потім з поворотом вправо. Кожен виклик зменшує довжину намальованої гілки, і рекурсія зупиняється, коли довжина падає нижче 8.

```{lang: html}
<canvas width=«600» height=«300»></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  function branch(length, angle, scale) {
    cx.fillRect(0, 0, 1, length);
    if (length < 8) return;
    cx.save();
    cx.translate(0, length);
    cx.rotate(-angle);
    branch(length * scale, angle, scale);
    cx.rotate(2 * кут);
    branch(length * scale, angle, scale);
    cx.restore();
  }
  cx.translate(300, 0);
  branch(60, 0.5, 0.8);
</script>
```

{{if book

Результат - простий фрактал.

{{figure {url: «img/canvas_tree.png», alt: «Скріншот фрактала», width: “5cm”}}}}

if}}

{{index «метод збереження», «метод відновлення», canvas, «метод обертання»}}

Якби не було викликів `save` і `restore`, другий рекурсивний виклик `branch` закінчився б позицією і поворотом, створеними першим викликом. Він був би пов'язаний не з поточною гілкою, а з внутрішньою, крайньою правою гілкою, намальованою першим викликом. Отримана фігура також може бути цікавою, але це точно не дерево.

{{id canvasdisplay}}

## Повернутися до гри

{{index «drawImage method»}}

Тепер ми знаємо достатньо про малювання ((полотно)), щоб почати роботу над системою ((дисплей)) на основі ((полотно)) для ((гра)) з [попередньої глави](гра). Новий дисплей більше не буде показувати лише кольорові квадратики. Замість цього ми будемо використовувати `drawImage` для малювання зображень, які представляють елементи гри.

{{index «CanvasDisplay class», «DOMDisplay class», [interface, object]}}

Ми визначаємо ще один тип об'єкта відображення з назвою `CanvasDisplay`, який підтримує той самий інтерфейс, що і `DOMDisplay` з [Chapter ?](game#domdisplay)-а саме, методи `синхронізувати стан` та `очистити`.

{{index [state, «in objects»]}}

Цей об'єкт зберігає трохи більше інформації, ніж `DOMDisplay`. Замість того, щоб використовувати позицію прокрутки свого DOM-елемента, він відстежує власну ((viewport)), яка показує нам, на яку частину рівня ми зараз дивимося. Нарешті, він зберігає властивість `flipPlayer`, щоб навіть коли гравець стоїть на місці, він залишався обличчям у тому напрямку, в якому він рухався востаннє.

```{sandbox: «game», includeCode: true}
class CanvasDisplay {
  constructor(parent, level) {
    this.canvas = document.createElement(«canvas»);
    this.canvas.width = Math.min(600, level.width * scale)
    this.canvas.height = Math.min(450, level.height * scale);
    parent.appendChild(this.canvas);
    this.cx = this.canvas.getContext(«2d»);

    this.flipPlayer = false;

    this.viewport = {
      left: 0,
      top: 0,
      width: this.canvas.width / scale,
      height: this.canvas.height / scale
    };
  }

  clear() {
    this.canvas.remove();
  }
}
```

Метод ``синхронізації`` спочатку обчислює новий видовий екран, а потім малює ігрову сцену у відповідній позиції.

```{sandbox: «game», includeCode: true}
CanvasDisplay.prototype.syncState = function(state) {
  this.updateViewport(state);
  this.clearDisplay(state.status)
  this.drawBackground(state.level)
  this.drawActors(state.actors);
};
```

{{index scrolling, clearing}}

На відміну від `DOMDisplay`, цьому стилю відображення _не_ потрібно перемальовувати тло при кожному оновленні. Оскільки фігури на полотні - це лише ((пікселі)), після того, як ми їх намалювали, немає жодного способу їх перемістити (або вилучити). Єдиний спосіб оновити відображення полотна - це очистити його і перемалювати сцену. Можливо, ми також прокручували, що вимагає зміни положення тла.

{{index «CanvasDisplay class»}}

Метод `updateViewport` подібний до методу `scrollPlayerIntoView` у `DOMDisplay`. Він перевіряє, чи не знаходиться плеєр надто близько до краю екрана, і переміщує ((viewport)), якщо це так.

```{sandbox: «game», includeCode: true}
CanvasDisplay.prototype.updateViewport = function(state) {
  let view = this.viewport, margin = view.width / 3;
  let player = state.player;
  let center = player.pos.plus(player.size.times(0.5));

  if (center.x < view.left + margin) {
    view.left = Math.max(center.x - margin, 0);
  } else if (center.x > view.left + view.width - margin) {
    view.left = Math.min(center.x + margin - view.width,
                         state.level.width - view.width);
  }
  if (center.y < view.top + margin) {
    view.top = Math.max(center.y - margin, 0);
  } else if (center.y > view.top + view.height - margin) { { view.top
    view.top = Math.min(center.y + margin - view.height,
                        state.level.height - view.height);
  }
};
```

{{межа індексу, «функція Math.max», «функція Math.min», відсікання}}

Виклики функцій `Math.max` та `Math.min` гарантують, що у вікні перегляду не буде показано простір за межами рівня. Функція `Math.max(x, 0)` гарантує, що отримане число не буде меншим за нуль. Аналогічно, `Math.min` гарантує, що значення не буде меншим за задану межу.

При ((очищенні)) дисплея ми будемо використовувати дещо інший ((колір)) в залежності від того, чи виграно гру (яскравіший), чи програно (темніший).

```{sandbox: «game», includeCode: true}
CanvasDisplay.prototype.clearDisplay = function(status) {
  if (status == «won») {
    this.cx.fillStyle = «rgb(68, 191, 255)»;
  } else if (status == «lost») {
    this.cx.fillStyle = «rgb(44, 136, 214)»;
  } else {
    this.cx.fillStyle = «rgb(52, 166, 251)»;
  }
  this.cx.fillRect(0, 0,
                   this.canvas.width, this.canvas.height);
};
```

{{index «Math.floor function», «Math.ceil function», округлення}}

Щоб намалювати фон, ми пробігаємось по плитках, які видно у поточному вікні перегляду, використовуючи той самий трюк, що й у методі `touches` з [попереднього розділу](game#touches).

```{sandbox: «game», includeCode: true}
let otherSprites = document.createElement(«img»);
otherSprites.src = «img/sprites.png»;

CanvasDisplay.prototype.drawBackground = function(level) {
  let {left, top, width, height} = this.viewport;
  let xStart = Math.floor(left)
  let xEnd = Math.ceil(left + width)
  let yStart = Math.floor(top)
  let yEnd = Math.ceil(top + height);

  for (let y = yStart; y < yEnd; y++) {
    for (let x = xStart; x < xEnd; x++) {
      let tile = level.rows[y][x];
      if (tile == «empty») continue
      let screenX = (x - left) * scale;
      let screenY = (y - top) * scale;
      let tileX = tile == «lava» ? scale : 0;
      this.cx.drawImage(otherSprites,
                        tileX, 0, scale, scale,
                        screenX, screenY, scale, scale);
    }
  }
};
```

{{index «drawImage method», sprite, tile}}

Тайли, які не є порожніми, малюються за допомогою `drawImage`. Зображення `otherSprites` містить зображення, що використовуються для інших елементів, окрім гравця. Воно містить, зліва направо, тайл стіни, тайл лави та спрайт монети.

{{figure {url: «img/sprites_big.png», alt: «Піксельна ілюстрація з трьома спрайтами: шматок стіни, складений з маленьких білих камінців, квадрат помаранчевої лави та кругла монета.», width: “1.4cm”}}}

{{Масштабування індексу}}

Плитки тла мають розмір 20 на 20 пікселів, оскільки ми будемо використовувати той самий масштаб, що і у `DOMDisplay`. Таким чином, зсув для плиток лави дорівнює 20 (значення прив'язки `scale`), а для стін - 0.

{{index drawing, «load event», «drawImage method»}}

Ми не будемо чекати на завантаження зображення спрайту. Виклик `drawImage` із зображенням, яке ще не було завантажено, просто нічого не дасть. Таким чином, ми можемо не намалювати гру належним чином протягом перших кількох ((кадрів))с, поки зображення ще завантажується, але це не є серйозною проблемою. Оскільки ми постійно оновлюємо екран, правильна сцена з'явиться одразу після завершення завантаження.

{{index «player», [animation, «platform game»], drawing}}

Для представлення гравця буде використано символ ((walking)), показаний раніше. Код, який його малює, повинен вибрати правильний спрайт і напрямок руху на основі поточного руху гравця. Перші вісім спрайтів містять анімацію ходьби. Коли гравець рухається по поверху, ми циклічно перемикаємо їх на основі поточного часу. Ми хочемо змінювати кадри кожні 60 мілісекунд, тому спочатку ((time)) ділиться на 60. Коли гравець стоїть на місці, ми малюємо дев'ятий спрайт. Під час стрибків, які розпізнаються за тим, що вертикальна швидкість не дорівнює нулю, ми використовуємо десятий, крайній правий спрайт.

{{index «flipHorizontally function», «CanvasDisplay class»}}

Оскільки ((спрайт))и трохи ширші за об'єкт гравця - 24 замість 16 пікселів, щоб залишити місце для ніг та рук - метод має відрегулювати координату x та ширину на задану величину (`playerXOverlap`).

```{sandbox: «game», includeCode: true}
нехай playerSprites = document.createElement(«img»);
playerSprites.src = «img/player.png»;
const playerXOverlap = 4;

CanvasDisplay.prototype.drawPlayer = function(player, x, y,
                                              width, height){
  width += playerXOverlap * 2;
  x -= playerXOverlap;
  if (player.speed.x != 0) {
    this.flipPlayer = player.speed.x < 0;
  }

  нехай tile = 8;
  if (player.speed.y != 0) {
    tile = 9;
  } else if (player.speed.x != 0) { tile = 9; }
    tile = Math.floor(Date.now() / 60) % 8;
  }

  this.cx.save();
  if (this.flipPlayer) {
    flipHorizontally(this.cx, x + width / 2);
  }
  нехай tileX = tile * width;
  this.cx.drawImage(playerSprites, tileX, 0, width, height,
                                   x, y, width, height);
  this.cx.restore();
};
```

Метод `drawPlayer` викликається методом `drawActors`, який відповідає за малювання всіх акторів у грі.

```{sandbox: «game», includeCode: true}
CanvasDisplay.prototype.drawActors = function(actors) {
  for (let actor of actors) {
    let width = actor.size.x * scale;
    let height = actor.size.y * scale
    let x = (actor.pos.x - this.viewport.left) * scale;
    let y = (actor.pos.y - this.viewport.top) * scale;
    if (actor.type == «player») {
      this.drawPlayer(actor, x, y, width, height);
    } else {
      let tileX = (actor.type == «coin» ? 2 : 1) * scale;
      this.cx.drawImage(otherSprites,
                        tileX, 0, width, height,
                        x, y, width, height);
    }
  }
};
```

Коли ((малюнок)) малює щось, що не є ((гравцем)), ми дивимося на його тип, щоб знайти зміщення правильного спрайту. Тайл ((лава)) знаходиться на зміщенні 20, а спрайт ((монета)) - на 40 (вдвічі більшому за `масштаб`).

{{index viewport}}

При обчисленні позиції актора ми маємо відняти позицію видового екрана, оскільки (0, 0) на нашому ((canvas)) відповідає лівому верхньому куту видового екрана, а не лівому верхньому куту рівня. Ми також могли б використати для цього `translate`. Обидва способи працюють.

{{якщо інтерактивний

Цей документ підключає новий дисплей до `runGame`:

```{lang: html, sandbox: game, focus: yes, startCode: true}
<body>
  <script>
    runGame(GAME_LEVELS, CanvasDisplay);
  </script> </script> </span> </span> </span> </span
</body></body
```

if}}

{{if book

{{індекс [гра, скріншот], [гра, «з полотном»]}}

На цьому нову систему ((відображення)) завершено. Результуюча гра виглядає приблизно так:

{{figure {url: «img/canvas_game.png», alt: «Скріншот гри, як показано на полотні», width: “8cm”}}}}

if}}

{{id graphics_tradeoffs}}

## Вибір графічного інтерфейсу

Коли вам потрібно згенерувати графіку у браузері, ви можете вибрати між звичайним HTML, ((SVG)) та ((canvas)). Не існує єдиного _найкращого_ підходу, який працює у всіх ситуаціях. Кожен варіант має сильні та слабкі сторони.

{{index «text wrapping»}}

Перевагою простого HTML є його простота. Він також добре інтегрується з ((text)). І SVG, і полотно дозволяють малювати текст, але вони не допоможуть вам розташувати цей текст або обернути його, якщо він займає більше одного рядка. В HTML-зображення набагато простіше включати блоки тексту.

{{індексне масштабування, SVG}}

SVG можна використовувати для створення ((чітких)) ((графічних)) зображень, які добре виглядають на будь-якому рівні масштабування. На відміну від HTML, вона призначена для малювання і тому краще підходить для цієї мети.

{{індекс [DOM, графіка], SVG, «обробка подій», [«структура даних», дерево]}}

І SVG, і HTML створюють структуру даних (DOM), яка представляє ваше зображення. Це дає можливість змінювати елементи після того, як вони намальовані. Якщо вам потрібно неодноразово змінювати маленьку частину великого ((зображення)) у відповідь на дії користувача або як частину ((анімації)), робити це на полотні може бути невиправдано дорого. DOM також дозволяє нам реєструвати обробники подій миші на кожному елементі зображення (навіть на фігурах, намальованих за допомогою SVG). З полотном цього зробити не можна.

{Продуктивність, оптимізація, «трасування променів»}}

Але підхід ((canvas)), орієнтований на ((pixel)), може бути перевагою при малюванні величезної кількості крихітних елементів. Той факт, що він не створює структуру даних, а лише багаторазово малює на тій самій піксельній поверхні, дає полотну нижчу вартість за фігуру. Існують також ефекти, які доцільно використовувати лише з елементами полотна, наприклад, рендеринг сцени по одному ((пікселю)) за раз (наприклад, за допомогою трасувальника променів) або постобробка зображення за допомогою JavaScript (розмиття або спотворення).

У деяких випадках вам може знадобитися поєднати декілька з цих методів. Наприклад, ви можете намалювати ((графік)) за допомогою ((SVG)) або ((полотно)), але показати ((текст)) інформацію, розмістивши елемент HTML поверх зображення.

{{index display}}

Для невибагливих додатків не має особливого значення, який інтерфейс ви обираєте. Дисплей, який ми створили для нашої гри у цій главі, можна було б реалізувати за допомогою будь-якої з цих трьох ((графічних)) технологій, оскільки йому не потрібно малювати текст, обробляти взаємодію з мишею або працювати з надмірно великою кількістю елементів.

## Підсумок

У цій главі ми обговорили методи малювання графіки у браузері, зосередившись на елементі `<canvas>`.

Вузол полотна являє собою область у документі, на якій може малювати наша програма. Малювання здійснюється за допомогою об'єкта контексту малювання, створеного методом `getContext`.

Інтерфейс двовимірного малювання дозволяє нам зафарбовувати і обводити різні фігури. Властивість контексту `fillStyle` визначає спосіб заповнення фігур. Властивості `strokeStyle` та `lineWidth` контролюють спосіб малювання ліній.

Прямокутники та фрагменти тексту можна намалювати одним викликом методу. Методи `fillRect` і `strokeRect` малюють прямокутники, а методи `fillText` і `strokeText` - текст. Для створення нестандартних фігур потрібно спочатку побудувати контур.

{{індекс обведення, заливки}}

Виклик методу `beginPath` створює новий контур. Ряд інших методів додають лінії та криві до поточного контуру. Наприклад, `lineTo` може додати пряму лінію. Коли контур завершено, його можна зафарбувати методом `fill` або обвести методом `stroke`.

Переміщення пікселів із зображення або іншого полотна на наше полотно здійснюється за допомогою методу `drawImage`. За замовчуванням цей метод малює все вихідне зображення, але, надавши йому більше параметрів, ви можете скопіювати певну область зображення. Ми використали це для нашої гри, скопіювавши окремі пози ігрового персонажа з зображення, яке містило багато таких поз.

Трансформації дозволяють малювати фігуру в різних орієнтаціях. Контекст двовимірного малювання має поточну трансформацію, яку можна змінити за допомогою методів `translate`, `scale` і `rotate`. Ці зміни впливатимуть на всі наступні операції малювання. Стан трансформації можна зберегти за допомогою методу `save` і відновити за допомогою методу `restore`.

Під час показу анімації на полотні можна використовувати метод `clearRect` для очищення частини полотна перед його перемальовуванням.

## Вправи

### Фігури

{{index «фігури (вправа)»}}

Напишіть програму, яка намалює наступні ((фігури)) на ((полотні)):

{{index rotation}}

1. ((трапеція)) (прямокутник, який ширший з одного боку)

2. Червоний ((ромб)) (прямокутник, повернутий на 45 градусів або ¼π радіан)

3. Зигзагоподібна ((лінія))

4. Спіраль, що складається зі 100 прямих відрізків

5. Жовта ((зірка))

{{figure {url: «img/exercise_shapes.png», alt: «Зображення фігур, які вам потрібно намалювати», width: “8cm”}}}}

Під час малювання останніх двох фігур ви можете звернутися до пояснення функцій `Math.cos` та `Math.sin` у [Глава ?](dom#sin_cos), де описано, як отримати координати на колі за допомогою цих функцій.

{{index readability, «hardcoding»}}

Я рекомендую створити функцію для кожної фігури. Передавайте позицію і, за бажанням, інші властивості, такі як розмір або кількість точок, як параметри. Альтернатива, яка полягає у жорсткому кодуванні чисел по всьому коду, як правило, робить код надмірно важким для читання та модифікації.

{{if інтерактивний

```{lang: html, test: no}
<canvas width=«600» height=«200»></canvas>
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);

  // Ваш код тут.
</script> </span> </span> </span> </span> </p
```

if}}

{{hint

{{index [path, canvas], «shapes (exercise)»}}

((трапецію)) (1) найпростіше намалювати за допомогою контуру. Виберіть відповідні координати центру і додайте кожен з чотирьох кутів навколо центру.

{{index «flipHorizontally function», rotation}}

Ромб ((діамант)) (2) можна намалювати простим способом, за допомогою контуру, або цікавим способом, за допомогою `обертання` ((перетворення)). Щоб використати обертання, вам доведеться застосувати трюк, подібний до того, що ми робили у функції `flipHorizontally`. Оскільки ви хочете обертати навколо центру вашого прямокутника, а не навколо точки (0, 0), ви повинні спочатку «перевести» туди, потім обернути, а потім перевести назад.

Переконайтеся, що ви скинули перетворення після малювання будь-якої фігури, яка його створює.

{{індекс «оператор залишку», «оператор %»}}

Для ((зигзаг)) (3) стає недоцільним писати новий виклик `lineTo` для кожного відрізка. Замість цього слід використовувати ((цикл)). Ви можете на кожній ітерації малювати або два відрізки ((line)) (праворуч, а потім знову ліворуч), або один, у цьому випадку ви повинні використовувати парність (`% 2`) індексу циклу, щоб визначити, куди йти - ліворуч чи праворуч.

Вам також знадобиться цикл для ((спіраль)) (4). Якщо ви намалюєте серію точок, кожна з яких буде віддалятися по колу навколо центру спіралі, ви отримаєте коло. Якщо під час циклу змінювати радіус кола, на яке поміщається поточна точка, і пройти по колу більше одного разу, то вийде спіраль.

{{index «quadraticCurveTo method»}}

Зображену ((зірку)) (5) побудовано з ліній `quadraticCurveTo`. Ви також можете намалювати її з прямих ліній. Розділіть коло на вісім частин для зірки з вісьмома точками або на будь-яку іншу кількість частин. Намалюйте лінії між цими точками так, щоб вони вигиналися до центру зірки. За допомогою `quadraticCurveTo` ви можете використовувати центр як контрольну точку.

підказка}}

{{id exercise_pie_chart}}

### Кругова діаграма

{{index label, text, «pie chart example»}}

[Раніше у розділі (canvas#pie_chart) ми бачили приклад програми, яка малювала кругову діаграму. Модифікуйте цю програму так, щоб назву кожної категорії було показано поруч зі шматочком, який її представляє. Спробуйте знайти приємний на вигляд спосіб автоматичного позиціонування цього тексту, який би працював і для інших наборів даних. Ви можете припустити, що категорії достатньо великі, щоб залишити достатньо місця для їхніх міток.

Можливо, вам знову знадобляться `Math.sin` і `Math.cos`, які описано у [Глава ?](dom#sin_cos).

{{якщо інтерактивно

```{lang: html, test: no}
<canvas width=«600» height=«300»></canvas
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);
  let total = results
    .reduce((sum, {count}) => sum + count, 0);
  let currentAngle = -0.5 * Math.PI;
  let centerX = 300, centerY = 150;

  // Додаємо код для малювання міток зрізів у цьому циклі.
  for (let result of results) {
    let sliceAngle = (result.count / total) * 2 * Math.PI;
    cx.beginPath();
    cx.arc(centerX, centerY, 100,
           currentAngle, currentAngle + sliceAngle);
    currentAngle += sliceAngle;
    cx.lineTo(centerX, centerY);
    cx.fillStyle = result.color;
    cx.fill();
  }
</script>
```

if}}

{{hint

{{індекс «метод fillText», «властивість textAlign», «властивість textBaseline», «приклад кругової діаграми»}}

Вам потрібно викликати `fillText` і встановити властивості контексту `textAlign` і `textBaseline` таким чином, щоб текст з'явився там, де ви хочете.

Розумним способом розташування міток буде розміщення тексту на лінії, що йде від центру пирога через середину скибочки. Вам не потрібно розміщувати текст безпосередньо біля краю пирога, а краще відсунути його на задану кількість пікселів від краю пирога.

((кут)) цього рядка дорівнює `currentAngle + 0.5 * sliceAngle`. Наступний код знаходить позицію на цій лінії на відстані 120 пікселів від центру:

```{test: no}
let middleAngle = currentAngle + 0.5 * sliceAngle;
let textX = Math.cos(middleAngle) * 120 + centerX
let textY = Math.sin(middleAngle) * 120 + centerY;
```

Для `textBaseline` значення `«middle»`, ймовірно, буде доречним при використанні цього підходу. Що використовувати для `textAlign` залежить від того, з якого боку кола ми знаходимося. Зліва це має бути `'right'`, а справа - `'left'`, щоб текст розташовувався подалі від пирога.

{{index «Math.cos function»}}

Якщо ви не знаєте, як дізнатися, на якій стороні кола знаходиться заданий кут, зверніться до пояснення функції `Math.cos` у [Глава ?](dom#sin_cos). Косинус кута показує нам, якій координаті x він відповідає, що, у свою чергу, точно вказує нам, на якій стороні кола ми знаходимося.

підказка}}

### М'ячик, що підстрибує

{{index [animation, «bouncing ball»], «requestAnimationFrame function», bouncing}}

Використовуйте техніку `requestAnimationFrame`, яку ми бачили у [Глава ?](dom#animationFrame) та [Глава ?](game#runAnimation), щоб намалювати ((box)) з м'ячиком, що стрибає ((ball)) у ньому. М'яч рухається з постійною ((швидкістю)) і відскакує від стінок коробки, коли вдаряється об них.

{{if інтерактивний

```{lang: html, test: no}
<canvas width=«400» height=«400»></canvas
<script>
  let cx = document.querySelector(«canvas»).getContext(«2d»);

  let lastTime = null;
  function frame(time) {
    if (lastTime != null) {
      updateAnimation(Math.min(100, time - lastTime) / 1000)
    }
    lastTime = time;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function updateAnimation(step) {
    // Ваш код тут.
  }
</script>
```

if}}

{{hint

{{index «strokeRect method», animation, «arc method»}}

За допомогою `strokeRect` легко намалювати ((box)). Визначте прив'язку, яка утримує його розмір, або визначте дві прив'язки, якщо ширина і висота вашої коробки відрізняються. Щоб створити круглий об'єкт, створіть контур і викличте команду `arc(x, y, radius, 0, 7)`, яка створить дугу від нуля до більш ніж цілого кола. Потім заповніть контур.

{{index «collision detection», «Vec class»}}

Для моделювання положення та ((швидкості)) м'яча ви можете використати клас `Vec` з [Chapter ?](game#vector)[ (який доступний на цій сторінці)]{якщо інтерактивний}. Задайте м'ячу початкову швидкість, бажано, щоб вона не була суто вертикальною або горизонтальною, і для кожного ((кадр)) помножте цю швидкість на кількість часу, що минув. Коли м'яч наближається до вертикальної стіни, інвертуйте складову _x_ у його швидкості. Аналогічно, інвертуйте компонент _y_, коли м'яч вдаряється об горизонтальну стіну.

{{index «clearRect method», clearing}}

Після знаходження нового положення і швидкості м'яча, використовуйте `clearRect` для видалення сцени і перемалюйте її з урахуванням нового положення.

підказка}}

### Попереднє віддзеркалення

{{оптимізація індексів, «растрова графіка», дзеркало}}

Одним з недоліків ((перетворень))у є те, що вони сповільнюють малювання растрових зображень. Положення і розмір кожного ((пікселя)) потрібно трансформувати, і хоча можливо, що ((браузер)) стануть розумнішими щодо трансформації у ((майбутньому)), наразі вони спричиняють помітне збільшення часу, необхідного для малювання растрової графіки.

У такій грі, як наша, де ми малюємо лише один трансформований спрайт, це не є проблемою. Але уявіть, що нам потрібно намалювати сотні персонажів або тисячі обертових частинок від вибуху.

Подумайте, як намалювати перевернутий символ, не завантажуючи додаткові файли зображень і не виконуючи виклики трансформованого `drawImage` у кожному кадрі.

{{підказка

{{index mirror, scaling, «drawImage method»}}

Ключ до вирішення проблеми полягає у тому, що ми можемо використовувати елемент ((canvas)) у якості вихідного зображення при використанні `drawImage`. Можна створити додатковий елемент `<canvas>`, не додаючи його до документа, і намалювати на ньому наші інвертовані спрайти, один раз. При малюванні реального кадру ми просто копіюємо вже інвертовані спрайти на основне полотно.

{{index «load event»}}

Тут потрібно бути обережним, оскільки зображення не завантажуються миттєво. Ми робимо інвертоване малювання лише один раз, і якщо ми зробимо це до завантаження зображення, воно нічого не намалює. Обробник ''load'' на зображенні можна використати для малювання перевернутих зображень на додатковому полотні. Це полотно можна одразу використовувати як джерело для малювання (воно буде просто порожнім, доки ми не намалюємо на ньому символ).

підказка}}
