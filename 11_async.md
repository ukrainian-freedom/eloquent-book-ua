{{meta {load_files: [«code/hangar2.js», «code/chapter/11_async.js»], zip: «node/html"}}}

# Асинхронне програмування

{{quote {author: 

«Laozi», title: «Дао де цзин», chapter: true}}

Хто може спокійно чекати, поки багнюка вляжеться?
Хто може залишатися нерухомим до моменту дії?

quote}}

{{index «Laozi»}}

{{figure {url: «img/chapter_picture_11.jpg», alt: «Ілюстрація із зображенням двох ворон на гілці дерева», “chapter”: “Обрамлення” }}}

Центральна частина комп'ютера, яка виконує окремі кроки, що складають наші програми, називається _((процесор))_. Програми, які ми бачили до цього часу, будуть завантажувати процесор доти, доки вони не завершать свою роботу. Швидкість, з якою може бути виконано щось на кшталт циклу, що маніпулює числами, майже повністю залежить від швидкості процесора та пам'яті комп'ютера.

{{індекс [пам'ять, швидкість], [мережа, швидкість]}}

Але багато програм взаємодіють з речами поза процесором. Наприклад, вони можуть спілкуватися через комп'ютерну мережу або запитувати дані з жорсткого диска, що набагато повільніше, ніж отримувати їх з пам'яті.

Коли таке трапляється, було б прикро, якби процесор простоював без діла - можливо, він міг би виконувати іншу роботу в цей час. Частково з цим справляється ваша операційна система, яка перемикає процесор між кількома запущеними програмами. Але це не допоможе, якщо ми хочемо, щоб _одна_ програма могла працювати, поки вона чекає на мережевий запит.

## Асинхронність

{{index «синхронне програмування»}}

У моделі _синхронного_ програмування все відбувається по черзі. Коли ви викликаєте функцію, яка виконує довготривалу дію, вона повертається лише тоді, коли ця дія завершиться і вона зможе повернути результат. Це зупиняє вашу програму на час виконання дії.

{{індекс «асинхронне програмування»}}

Асинхронна модель дозволяє виконувати декілька дій одночасно. Коли ви запускаєте дію, ваша програма продовжує працювати. Коли дія завершується, програма отримує повідомлення і доступ до результату (наприклад, до даних, прочитаних з диска).

Ми можемо порівняти синхронне та асинхронне програмування на невеликому прикладі: програма, яка робить два запити через ((мережу)), а потім об'єднує результати.

{{index «синхронне програмування»}}

У синхронному середовищі, де функція запиту повертається тільки після того, як вона виконала свою роботу, найпростіший спосіб виконати це завдання - зробити запити один за одним. Це має той недолік, що другий запит буде запущено лише тоді, коли завершиться перший. Загальний час виконання буде щонайменше дорівнювати сумі часу відповіді на обидва запити.

{Паралелізм індексів

Вирішенням цієї проблеми у синхронній системі є запуск додаткових ((потоків)) керування. Нитка_ - це інша запущена програма, виконання якої операційна система може чергувати з іншими програмами - оскільки більшість сучасних комп'ютерів містять декілька процесорів, декілька ниток можуть навіть виконуватися одночасно, на різних процесорах. Другий потік може запустити другий запит, а потім обидва потоки чекають на результати, після чого вони ресинхронізуються, щоб об'єднати свої результати.

{{індекс процесора, блокування, «асинхронне програмування», часова шкала, «функція зворотного виклику»}}

На наступній діаграмі товсті лінії показують час, який програма витрачає на нормальне виконання, а тонкі лінії - час, який витрачається на очікування мережі. У синхронній моделі час, зайнятий мережею, є _частиною_ часової шкали для даного потоку управління. В асинхронній моделі запуск мережевої дії дозволяє програмі продовжувати працювати, поки мережева комунікація відбувається паралельно з нею, повідомляючи програму про її завершення.

{{figure {url: «img/control-io.svg», alt: «Діаграма показу потоку управління у синхронних та асинхронних програмах. Перша частина показує синхронну програму, де активні та очікувальні фази програми відбуваються в одному послідовному рядку. Друга частина показує багатопоточну синхронну програму з двома паралельними лініями, на яких фази очікування відбуваються паралельно одна одній, що призводить до швидшого завершення програми. Остання частина показує асинхронну програму, де декілька асинхронних дій відгалужуються від основної програми, яка в певний момент зупиняється, а потім поновлюється, коли закінчується те, на що вона чекала.»,width: “8cm”}}}.

{{index [«потік керування», «асинхронний», «асинхронне програмування», багатослівність, продуктивність}}

Інший спосіб описати різницю полягає в тому, що очікування завершення дій є _неявним_ у синхронній моделі, тоді як в асинхронній воно є _явним_- під нашим контролем.

Асинхронність ріже в обидва боки. Вона полегшує написання програм, які не вписуються у прямолінійну модель управління, але також може зробити написання програм, які вписуються у прямолінійну модель, більш незручним. Пізніше у цій главі ми розглянемо деякі способи зменшення цієї незручності.

Обидві відомі платформи програмування на JavaScript - ((браузер))s та ((Node.js))- роблять операції, які можуть зайняти деякий час, асинхронними, замість того, щоб покладатися на ((потік))s. Оскільки програмування за допомогою потоків, як відомо, є складним (зрозуміти, що робить програма, набагато складніше, коли вона робить кілька речей одночасно), це зазвичай вважається гарним рішенням.

## Зворотні виклики

{{indexsee [функція, зворотний виклик], «функція зворотного виклику»}}

Один з підходів до ((асинхронного програмування)) полягає у тому, щоб змусити функції, які мають на щось чекати, приймати додатковий аргумент, _((функцію зворотного виклику))_. Асинхронна функція запускає процес, налаштовує його так, щоб функція зворотного виклику була викликана після завершення процесу, а потім повертається.

{{index «setTimeout function», waiting}}

Як приклад, функція `setTimeout`, доступна як в Node.js, так і в браузерах, чекає задану кількість мілісекунд, а потім викликає функцію.

```{test: no}
setTimeout(() => console.log(«Tick»), 500);
```

Очікування зазвичай не є важливою роботою, але воно може бути дуже корисним, коли вам потрібно організувати виконання чогось у певний час або перевірити, чи виконується якась дія довше, ніж очікувалося.

{{index «readTextFile function»}}

Іншим прикладом поширеної асинхронної операції є читання файлу зі сховища пристрою. Уявіть, що у вас є функція `readTextFile`, яка читає вміст файлу у вигляді рядка і передає його функції зворотного виклику.

```
readTextFile(«shopping_list.txt», content => {})
  console.log(`Shopping List:\n${content}`);
});
// → Список покупок:
// → Арахісове масло
// → Банани
```

Функція `readTextFile` не є частиною стандартного JavaScript. Ми розглянемо, як читати файли в браузері і в Node.js в наступних розділах.

Виконання декількох асинхронних дій поспіль з використанням функцій зворотного виклику означає, що вам доведеться постійно передавати нові функції для обробки ((продовження)) обчислень після виконання дій. Асинхронна функція, яка порівнює два файли і видає логічне значення, що вказує на те, чи збігається їхній вміст, може мати такий вигляд:

```
function compareFiles(fileA, fileB, callback) {
  readTextFile(fileA, contentA => {
    readTextFile(fileB, contentB => {
      callback(contentA == contentB);
    });
  });
}
```

Такий стиль програмування є робочим, але рівень відступів збільшується з кожною асинхронною дією, тому що ви потрапляєте в іншу функцію. Виконання більш складних речей, таких як обгортання асинхронних дій у цикл, може стати незручним.

У певному сенсі, асинхронність є «заразною». Будь-яка функція, яка викликає функцію, що працює асинхронно, повинна сама бути асинхронною, використовуючи зворотний виклик або подібний механізм для доставки свого результату. Виклик зворотного виклику дещо складніший і схильний до помилок, ніж просте повернення значення, тому необхідність структурувати великі частини вашої програми таким чином не є найкращим рішенням.

## Обіцянки

Дещо іншим способом побудови асинхронної програми є використання асинхронних функцій, які повертають об'єкт, що представляє їхній (майбутній) результат, замість того, щоб передавати його функціям зворотного виклику. Таким чином, такі функції дійсно повертають щось значуще, а форма програми більше нагадує форму синхронних програм.

{{index «Клас обіцянки», «асинхронне програмування», «розв'язання (обіцянка)», «метод then», «функція зворотного виклику»}}

Саме для цього призначений стандартний клас `Promise`. Обіцянка - це розписка, що представляє значення, яке ще може бути недоступним. Він надає метод `then`, який дозволяє вам зареєструвати функцію, що має бути викликана, коли дія, на яку вона очікує, завершиться. Коли обіцянка _вирішується_, тобто її значення стає доступним, такі функції (їх може бути декілька) викликаються зі значенням результату. Можна викликати `then` в обіцянці, яка вже виконалася - ваша функція все одно буде викликана.

{{index «Promise.resolve function»}}

Найпростіший спосіб створити обіцянку - це викликати `Promise.resolve`. Ця функція гарантує, що значення, яке ви їй надасте, буде загорнуто в обіцянку. Якщо це вже є обіцянкою, вона просто повертається. В іншому випадку, ви отримуєте нову обіцянку, яка одразу ж розв'язується з вашим значенням у якості результату.

```
нехай fifteen = Promise.resolve(15);
fifteen.then(value => console.log(`Got ${value}`));
// → Отримано 15
```

{{index «Promise class»}}

Для створення обіцянки, яка не виконується одразу, можна використати конструктор `Promise`. Він має дещо дивний інтерфейс: конструктор очікує функцію в якості аргументу, яку одразу ж викликає, передаючи їй функцію, яку можна використати для виконання обіцянки.

Наприклад, ось як можна створити інтерфейс на основі обіцянок для функції `readTextFile`:

{{index «textFile function»}}

```
function textFile(ім'я файлу) {
  return new Promise(resolve => {
    readTextFile(filename, text => resolve(text));
  });
}

textFile(«plans.txt»).then(console.log);
```

Зверніть увагу, що, на відміну від функцій у стилі callback, ця асинхронна функція повертає осмислене значення - обіцянку надати вам вміст файлу в певний момент у майбутньому.

{{index «then method»}}

Корисною особливістю методу `then` є те, що він сам повертає іншу обіцянку. Ця обіцянка перетворюється на значення, повернуте функцією зворотного виклику, або, якщо це повернуте значення є обіцянкою, на значення, до якого перетворюється ця обіцянка. Таким чином, ви можете «зв'язати» декілька викликів `then` разом, щоб створити послідовність асинхронних дій.

Ця функція, яка читає файл з іменами файлів і повертає вміст випадкового файлу з цього списку, демонструє такий тип асинхронного конвеєра обіцянок:

```
function randomFile(listFile) {
  return textFile(listFile)
    .then(content => content.trim().split(«\n»))
    .then(ls => ls[Math.floor(Math.random() * ls.length)])
    .then(filename => textFile(filename));
}
```

Функція повертає результат цього ланцюжка викликів `then`. Початкова обіцянка отримує список файлів у вигляді рядка. Перший виклик `then` перетворює цей рядок на масив рядків, створюючи нову обіцянку. Другий виклик `then` вибирає випадковий рядок з цього масиву, створюючи третю обіцянку, яка дає єдине ім'я файлу. Останній виклик `then` читає цей файл, тому результатом роботи функції в цілому є обіцянка, яка повертає вміст випадкового файлу.

У цьому коді функції, що використовуються в перших двох викликах `then`, повертають звичайне значення, яке відразу ж буде передано в обіцянку, що повертається `then`, коли функція повернеться. Останній виклик `then` повертає обіцянку (`textFile(ім'я файлу)`), що робить його фактично асинхронним кроком.

Можна було б також виконати всі ці кроки всередині одного виклику `then`, оскільки лише останній крок є фактично асинхронним. Але такі `then`-обгортки, які виконують лише деякі синхронні перетворення даних, часто бувають корисними, наприклад, коли ви хочете повернути обіцянку, яка видає оброблену версію деякого асинхронного результату.

```
функція jsonFile(ім'я_файлу) {
  return textFile(ім'я файлу).then(JSON.розбір);
}

jsonFile(«package.json»).then(console.log);
```

Взагалі, корисно думати про обіцянку як про пристрій, який дозволяє коду ігнорувати питання про те, коли значення буде отримано. Звичайне значення має існувати до того, як ми зможемо на нього посилатися. Обіцяне значення - це значення, яке _може_ вже існувати або може з'явитися в якийсь момент у майбутньому. Обчислення, визначені в термінах обіцянок, шляхом їх поєднання з викликами `then`, виконуються асинхронно в міру того, як стають доступними їхні вхідні дані.

## Збій

{{index «обробка виключень»}}

Звичайні обчислення JavaScript можуть завершитися невдало, згенерувавши виключення. Асинхронні обчислення часто потребують чогось подібного. Мережевий запит може завершитися невдало, файл може не існувати, або якийсь код, що є частиною асинхронних обчислень, може згенерувати виключення.

{{index «функція зворотного виклику», error}}

Однією з найбільш нагальних проблем стилю зворотного виклику в асинхронному програмуванні є те, що він робить надзвичайно складним забезпечення належного повідомлення про збої у функціях зворотного виклику.

Загальноприйнятою практикою є використання першого аргументу зворотного виклику для вказівки на те, що дія не вдалася, а другого - для передачі значення, отриманого в результаті дії, коли вона була успішною.

```
someAsyncFunction((помилка, значення) => {
  if (error) handleError(error);
  else processValue(value);
});
```

Такі функції зворотного виклику повинні завжди перевіряти, чи отримали вони виключення, і переконуватися, що будь-які проблеми, які вони спричиняють, включаючи виключення, що генеруються функціями, які вони викликають, перехоплені і передані правильній функції.

{{index «rejecting (a promise)», «resolving (a promise)», «then method»}}

З обіцянками все простіше. Вони можуть бути або виконані (дія завершилася успішно), або відхилені (дія не відбулася). Обробники розв'язання (зареєстровані за допомогою `then`) викликаються лише у випадку успішного завершення дії, а відхилення передаються до нової обіцянки, яку повертає `then`. Коли обробник генерує виключення, це автоматично призводить до того, що обіцянка, створена його викликом `then`, буде відхилена. Якщо будь-який елемент у ланцюжку асинхронних дій зазнає невдачі, результат всього ланцюжка позначається як відхилений, і жодні обробники успіху не викликаються після точки, в якій сталася невдача.

{{index «Promise.reject function», «Promise class»}}

Подібно до того, як вирішення обіцянки надає значення, відхилення обіцянки також надає значення, яке зазвичай називають _причиною_ відхилення. Коли виняток у функції-обробнику спричиняє відхилення, значення винятку використовується як причина. Аналогічно, коли обробник повертає відхилену обіцянку, це відхилення перетікає в наступну обіцянку. Існує функція `Promise.reject`, яка створює нову, негайно відхилену обіцянку.

{{index «catch method»}}

Щоб явно обробляти такі відхилення, обіцянки мають метод `catch`, який реєструє обробник, що викликається, коли обіцянку відхилено, подібно до того, як обробники `then` обробляють звичайну роздільну здатність. Він також дуже схожий на `then` у тому, що повертає нову обіцянку, яка перетворюється на значення початкової обіцянки, якщо це відбувається нормально, і на результат обробника `catch` у протилежному випадку. Якщо обробник `catch` генерує помилку, нову обіцянку також буде відкинуто.

{{індекс «метод then»}}

Як скорочення, `then` також приймає обробник відхилення як другий аргумент, тому ви можете встановити обидва типи обробників в одному виклику методу: `.then(acceptHandler, rejectHandler)`.

Функція, передана конструктору `Promise`, отримує другий аргумент разом з функцією resolve, який вона може використати для відхилення нової обіцянки.

{{index «textFile function»}}

Коли наша функція `readTextFile` стикається з проблемою, вона передає помилку своїй функції зворотного виклику як другий аргумент. Наша обгортка `textFile` повинна перевірити цей аргумент, щоб у разі помилки обіцянку, яку вона повертає, було відкинуто.

```{includeCode: true}
function textFile(ім'я файлу) {
  return new Promise((resolve, reject) => {
    readTextFile(filename, (text, error) => {
      if (error) reject(error);
      else resolve(text);
    });
  });
}
```

Ланцюжки обіцяних значень, створені викликами `then` і `catch`, таким чином, утворюють конвеєр, по якому рухаються асинхронні значення або збої. Оскільки такі ланцюжки створюються шляхом реєстрації обробників, з кожним посиланням пов'язаний обробник успіху або обробник відмови (або обидва). Обробники, які не відповідають типу результату (успіх або невдача), ігноруються. Обробники, які збігаються, викликаються, і їх результат визначає, яке значення буде наступним - успіх, якщо вони повертають значення, яке не є обіцяним, відхилення, якщо вони генерують виключення, і результат обіцянки, якщо вони повертають обіцяне значення.

```{test: no}
new Promise((_, reject) => reject(new Error(«Fail»)))
  .then(value => console.log(«Обробник 1:», value))
  .catch(reason => {
    console.log("Виникла помилка » + reason);
    return «nothing»;
  })
  .then(value => console.log(«Обробник 2:», value));
// → Виникла помилка Помилка: Fail
// → Обробник 2: nothing
```

Перша функція-обробник `then` не викликається, оскільки в цій точці конвеєра обіцянка містить відмову. Обробник `catch` обробляє цю відмову і повертає значення, яке передається другій функції-обробнику `then`.

{{index «неперехоплене виключення», «обробка винятків»}}

Подібно до того, як неперехоплене виключення обробляється середовищем, середовище JavaScript може виявити, коли відхилення обіцянки не обробляється, і повідомить про це як про помилку.

## Карла

{{index «Carla the crow»}}

У Берліні сонячний день. Злітно-посадкова смуга старого, виведеного з експлуатації аеропорту кишить велосипедистами та скейтерами. У траві біля сміттєвого контейнера галасливо кружляє зграя ворон, намагаючись переконати групу туристів розлучитися з бутербродами.

Одна з ворон виділяється - велика неохайна самка з кількома білими пір'їнками на правому крилі. Вона приманює людей з умінням і впевненістю, які свідчать про те, що вона робить це вже давно. Коли літній чоловік відволікається на витівки іншої ворони, вона несподівано налітає, вихоплює з його руки недоїдену булочку і відлітає геть.

На відміну від решти групи, які виглядають так, ніби вони раді провести тут цілий день, велика ворона виглядає цілеспрямованою. Несучи свою здобич, вона летить прямо до даху будівлі ангару, зникаючи у вентиляційному отворі.

Всередині будівлі чути дивне постукування - тихе, але наполегливе. Він долинає з вузького простору під дахом недобудованої сходової клітки. Там сидить ворона, оточена вкраденими закусками, півдюжиною смартфонів (кілька з яких увімкнені) і плутаниною кабелів. Вона швидко стукає дзьобом по екрану одного з телефонів. На ньому з'являються слова. Якби ви не знали краще, можна було б подумати, що вона друкує на машинці.

Ця ворона відома своїм одноліткам як «кря-кря». Але оскільки ці звуки погано підходять для людських голосових зв'язок, ми будемо називати її Карлою.

Карла - дещо своєрідна ворона. В юності вона була зачарована людською мовою, підслуховувала людей, поки не починала добре розуміти, про що вони говорять. Пізніше її інтерес переключився на людські технології, і вона почала красти телефони, щоб вивчати їх. Її нинішній проект - навчання програмуванню. Текст, який вона набирає у своїй прихованій лабораторії, насправді є шматком асинхронного коду JavaScript.

## Зламування

{{index «Carla the crow»}}

Карла любить інтернет. На жаль, на телефоні, з яким вона працює, ось-ось закінчаться передоплачені дані. У будинку є бездротова мережа, але для доступу до неї потрібен код.

На щастя, бездротові маршрутизатори в будівлі 20-річної давнини і погано захищені. Провівши деякі дослідження, Карла з'ясовує, що механізм автентифікації мережі має недолік, який вона може використати. Приєднуючись до мережі, пристрій повинен надіслати правильний шестизначний пароль. Точка доступу відповість повідомленням про успіх або невдачу, залежно від того, чи правильний код було надіслано. Однак у разі надсилання часткового коду (скажімо, лише трьох цифр) відповідь буде різною залежно від того, чи є ці цифри правильним початком коду чи ні. Надсилання неправильних цифр негайно повертає повідомлення про помилку. При надсиланні правильних цифр точка доступу чекає на додаткові цифри.

Це дозволяє значно прискорити вгадування числа. Карла може знайти першу цифру, пробуючи кожне число по черзі, поки не знайде те, яке не повертає негайно повідомлення про помилку. Маючи одну цифру, вона може знайти другу таким же чином, і так далі, поки не дізнається весь пароль.

Припустимо, що у Карли є функція `joinWifi`. Отримавши ім'я мережі та пароль (у вигляді рядка), функція намагається приєднатися до мережі, повертаючи обіцянку, яка виконується у разі успіху і відхиляється, якщо аутентифікація не вдалася. Перше, що їй потрібно, це спосіб обернути обіцянку так, щоб вона автоматично відхилялася після того, як це займе занадто багато часу, щоб програма могла швидко рухатися далі, якщо точка доступу не відповість.

```{includeCode: true}
function withTimeout(promise, time) {
  return new Promise((resolve, reject) => {
    promise.then(resolve, reject);
    setTimeout(() => reject(«Закінчився таймаут»), time);
  });
}
```

Тут використовується той факт, що обіцянка може бути виконана або відхилена лише один раз. Якщо обіцянка, передана як аргумент, буде виконана або відхилена першою, цей результат буде результатом обіцянки, повернутої `withTimeout`. Якщо, з іншого боку, `setTimeout` спрацює першим, відхиливши обіцянку, будь-які подальші виклики resolve або reject ігноруються.

Для того, щоб знайти весь пароль, програма повинна повторно шукати наступну цифру, пробуючи кожну цифру. Якщо автентифікація пройшла успішно, ми знаємо, що знайшли те, що шукали. Якщо ж вона одразу ж зазнає невдачі, ми знаємо, що ця цифра була неправильною, і повинні спробувати наступну цифру. Якщо запит завершився, ми знайшли ще одну правильну цифру і повинні продовжити, додавши ще одну цифру.

Оскільки ви не можете чекати на обіцянку всередині циклу `for`, Карла використовує рекурсивну функцію для керування цим процесом. При кожному виклику ця функція отримує код, який ми вже знаємо, а також наступну цифру, яку потрібно спробувати. Залежно від того, що відбувається, вона може повернути готовий код або викликати саму себе, щоб почати розгадувати наступну позицію в коді або спробувати ще раз з іншою цифрою.

```{includeCode: true}
function crackPasscode(networkID) {
  function nextDigit(code, digit) {
    нехай newCode = код + цифра;
    return withTimeout(joinWifi(networkID, newCode), 50)
      .then(() => newCode)
      .catch(failure => {
        if (failure == «Тайм-аут») {
          return nextDigit(newCode, 0);
        } else if (digit < 9) {
          повернути nextDigit(code, digit + 1);
        } else {
          вивести помилку;
        }
      });
  }
  return nextDigit(«», 0);
}
```

Точка доступу має тенденцію відповідати на погані запити на автентифікацію приблизно через 20 мілісекунд, тому для безпеки ця функція чекає 50 мілісекунд перед тим, як завершити запит.

```
crackPasscode(«HANGAR 2»).then(console.log);
// → 555555
```

Карла нахиляє голову і зітхає. Це було б більш приємно, якби код було трохи складніше вгадати.

## Асинхронні функції

{{index «Promise class», рекурсія}}

Навіть з обіцянками, цей тип асинхронного коду дратує при написанні. Обіцянки часто потрібно пов'язувати між собою багатослівними, довільними на вигляд способами. Щоб створити асинхронний цикл, Карла була змушена ввести рекурсивну функцію.

{{index «синхронне програмування», «асинхронне програмування»}}

Насправді функція зламу працює абсолютно лінійно - вона завжди чекає на завершення попередньої дії, перш ніж почати наступну. У моделі синхронного програмування це було б простіше виразити.

{{index «async-функція», «ключове слово await»}}

Хороша новина полягає в тому, що JavaScript дозволяє писати псевдосинхронний код для опису асинхронних обчислень. Функція `async` неявно повертає обіцянку і може у своєму тілі «очікувати» на інші обіцянки так, щоб  виглядати синхронно.

{{index «findInStorage function»}}

Ми можемо переписати `crackPasscode` таким чином:

```
async function crackPasscode(networkID) {
  for (let code = «»;;) {
    for (let digit = 0;; digit++) {
      let newCode = code + digit;
      try {
        wait withTimeout(joinWifi(networkID, newCode), 50);
        return newCode;
      } catch (failure) {
        if (failure == «Тайм-аут») {
          code = newCode;
          break;
        } else if (digit == 9) { { code = newCode
          виводимо помилку;
        }
      }
    }
  }
}
```

Ця версія більш чітко показує двоциклову структуру функції (внутрішній цикл перебирає цифри від 0 до 9, а зовнішній - додає цифри до паролю).

{{index «async-функція», «ключове слово повернення», «обробка виключень»}}

Функція `async` позначається словом `async` перед ключовим словом `function`. Методи також можна зробити `async`, додавши слово `async` перед їхнім іменем. Коли така функція або метод викликається, вона повертає обіцянку. Як тільки функція повертає щось, ця обіцянка виконується. Якщо тіло функції генерує виключення, обіцянка відхиляється.

{{індекс «ключове слово await», [«потік керування», asynchronous]}}

Всередині функції `async` слово `await` можна поставити перед виразом, щоб дочекатися розв'язання обіцянки і лише після цього продовжити виконання функції. Якщо обіцянка відхиляється, у точці `await` буде згенеровано виключення.

Така функція більше не виконується від початку до кінця за один раз, як звичайна функція JavaScript. Замість цього вона може бути «заморожена» в будь-якій точці, яка має `await`, і може бути відновлена пізніше.

Для більшості асинхронного коду така нотація зручніша, ніж пряме використання обіцянок. Вам все одно потрібно мати уявлення про обіцянки, оскільки у багатьох випадках ви будете взаємодіяти з ними безпосередньо. Але якщо їх з'єднати разом, функції `async` загалом приємніше писати, ніж ланцюжки викликів `then`.

{{id генератор}}

## Генератори

{{index «async function»}}

Здатність функцій призупиняти роботу, а потім відновлювати її знову не є виключною властивістю `async`-функцій. У JavaScript також є функція, яка називається _((генератор))_ функції. Вони схожі, але без обіцянок.

Коли ви визначаєте функцію за допомогою `function*` (ставите зірочку після слова `function`), вона стає генератором. Коли ви викликаєте генератор, він повертає ((ітератор)), що ми вже бачили у [Глава ?](об'єкт).

```
function* powers(n) {
  for (let current = n;; current *= n) {
    вивести current;
  }
}

for (let power of powers(3)) {
  if (power > 50) break;
  console.log(power);
}
// → 3
// → 9
// → 27
```

{{index «next method», «yield keyword»}}

Спочатку, коли ви викликаєте `powers`, функція заморожується на старті. Кожного разу, коли ви викликаєте `next` на ітераторі, функція виконується доти, доки не досягне виразу `yield`, який призупиняє її роботу і змушує отримане значення стати наступним значенням, виробленим ітератором. Коли функція повертається (у нашому прикладі вона ніколи не повертається), ітератор завершує свою роботу.

Написання ітераторів часто значно спрощується, коли ви використовуєте функції-генератори. Ітератор для класу `Group` (з вправи у [Глава ?](об'єкт#group_iterator)) можна написати за допомогою цього генератора:

{{індекс «Клас групи»}}

```
Group.prototype[Symbol.iterator] = function*() {
  for (let i = 0; i < this.members.length; i++) {
    return this.members[i];
  }
};
```

```{hidden: true, includeCode: true}
class Group {
  constructor() { this.members = []; }
  add(m) { this.members.add(m); }
}
```

{{index [state, in iterator]}}

Більше не потрібно створювати об'єкт для зберігання станів ітерації - генератори станів автоматично зберігають свій локальний стан кожного разу, коли вони виходять з ітерації.

Такі вирази «виходу» можуть зустрічатися лише безпосередньо у самій функції-генераторі, а не у внутрішній функції, яку ви визначаєте всередині неї. Стан, який генератор зберігає при завершенні роботи, - це лише його _локальне_ оточення і позиція, в якій він завершив роботу.

{{index «await keyword»}}

Функція `async` є особливим типом генератора. При виклику вона видає обіцянку, яка вирішується, коли вона повертається (завершується), і відхиляється, коли вона генерує виключення. Кожного разу, коли вона видає (очікує) обіцянку, результат цієї обіцянки (значення або згенероване виключення) є результатом виразу `await`.

## Арт-проект Corvid

{{index «Carla the crow»}}

Одного ранку Карла прокидається від незнайомого шуму, що долинає з асфальту біля її ангару. Вискочивши на край даху, вона бачить, що люди до чогось готуються. Там багато електричних кабелів, сцена і якась велика чорна стіна, що зводиться.

Будучи допитливою вороною, Карла придивляється до стіни. Виявляється, вона складається з низки великих скляних пристроїв, під'єднаних до кабелів. На задній панелі пристроїв написано «LedTec SIG-5030».

Швидкий пошук в Інтернеті дає змогу знайти інструкцію з експлуатації цих пристроїв. Вони виглядають як дорожні знаки з програмованою матрицею бурштинових світлодіодних ліхтарів. Ймовірно, люди мали намір виводити на них якусь інформацію під час свого заходу. Цікаво, що екрани можна програмувати через бездротову мережу. Можливо, вони підключені до локальної мережі будівлі?

Кожен пристрій у мережі отримує _IP-адресу_, яку інші пристрої можуть використовувати для надсилання йому повідомлень. Ми поговоримо про це докладніше в [Розділ ?] (браузер). Карла помітила, що всі її телефони мають адреси на кшталт `10.0.0.20` або `10.0.0.33`. Можливо, варто спробувати надіслати повідомлення на всі такі адреси і подивитися, чи відповідає якась з них інтерфейсу, описаному в посібнику для знаків.

[Глава ?](http) показує, як робити реальні запити у реальних мережах. У цій главі ми будемо використовувати спрощену фіктивну функцію `request` для спілкування з мережею. Ця функція приймає два аргументи - мережеву адресу і повідомлення, яким може бути будь-що, що може бути надіслано у форматі JSON, і повертає обіцянку, яка або підтверджує відповідь від машини за вказаною адресою, або відхиляє, якщо виникла проблема.

Згідно з інструкцією, ви можете змінити те, що відображається на вивісці SIG-5030, надіславши їй повідомлення з вмістом на кшталт `{«command»: «display», “data”: [0, 0, 3, ...]}`, де `дані` містять по одному числу для кожної світлодіодної точки, що забезпечує її яскравість - 0 означає вимкнено, 3 означає максимальну яскравість. Кожна вивіска має 50 світлодіодів завширшки і 30 заввишки, тому команда оновлення має надіслати 1500 чисел.

Цей код надсилає повідомлення про оновлення вивіски на всі адреси в локальній мережі, щоб перевірити, що залишилося.  Кожне з чисел в IP-адресі може мати значення від 0 до 255. У даних, які вона надсилає, вона активує кількість індикаторів, що відповідає останній цифрі мережевої адреси.

```
for (let addr = 1; addr < 256; addr++) {
  let data = [];
  for (let n = 0; n < 1500; n++) { data.push(n < addr)
    data.push(n < addr ? 3 : 0);
  }
  let ip = `10.0.0.${addr}`;
  request(ip, {команда: «display», data})
    .then(() => console.log(`Запит до ${ip} прийнято`))
    .catch(() => {});
}
```

Оскільки більшість цих адрес не існують або не приймають такі повідомлення, виклик `catch` гарантує, що мережеві помилки не призведуть до аварійного завершення роботи програми. Всі запити надсилаються негайно, не чекаючи завершення інших запитів, щоб не витрачати час на те, що деякі машини не відповідатимуть.

Запустивши сканування мережі, Карла повертається на вулицю, щоб побачити результат. На її радість, всі екрани тепер показують смужку світла у верхньому лівому кутку. Вони «є» в локальній мережі і « приймають» команди. Вона швидко записує цифри, показані на кожному екрані. Є дев'ять екранів, розташованих три у висоту і три в ширину. Вони мають наступні мережеві адреси:

```{includeCode: true}
const screenAddresses = [
  «10.0.0.44», “10.0.0.45”, “10.0.0.41”,
  «10.0.0.31», “10.0.0.40”, “10.0.0.42”,
  «10.0.0.48», “10.0.0.47”, »10.0.0.46»
];
```

Тепер це відкриває можливості для всіляких витівок. Вона могла б намалювати на стіні гігантськими літерами «ворони правлять, люди пускають слину». Але це виглядає трохи грубувато. Натомість вона планує показати відео з вороною, що літає вночі, затуляючи собою всі екрани.

Карла знаходить відповідний відеокліп, у якому півторасекундний відеоряд можна повторювати, щоб створити циклічне відео, що демонструє помах воронових крил. Щоб вмістити відео на дев'ять екранів (кожен з яких може показувати 50×30 пікселів), Карла вирізає і змінює розмір відео, щоб отримати серію зображень розміром 150×90, по 10 в секунду. Потім кожне з них розрізається на дев'ять прямокутників і обробляється так, щоб темні місця на відео (де є ворона) були яскраво освітлені, а світлі місця (без ворони) залишалися темними, що має створити ефект бурштинової ворони, яка летить на чорному тлі.

Вона налаштувала змінну `clipImages` для зберігання масиву кадрів, де кожен кадр представлений масивом з дев'яти наборів пікселів - по одному для кожного екрану - у форматі, який очікують знаки.

Щоб відобразити один кадр відео, Карлі потрібно надіслати запит на всі екрани одночасно. Але їй також потрібно чекати на результат цих запитів, як для того, щоб не почати надсилати наступний кадр до того, як поточний буде відправлено належним чином, так і для того, щоб помітити, коли запити не спрацьовують.

{{index «Promise.all function»}}

Клас `Promise` має статичний метод `all`, який можна використовувати для перетворення масиву обіцянок в одну обіцянку, яка перетворюється на масив результатів. Це надає зручний спосіб виконати декілька асинхронних дій паралельно, дочекатися їхнього завершення, а потім зробити щось з їхніми результатами (або принаймні дочекатися їхнього завершення, щоб переконатися, що вони не завершаться невдало).

```{includeCode: true}
function displayFrame(frame) {
  return Promise.all(frame.map((data, i) => {
    return request(screenAddresses[i], {
      команда: «display»,
      дані
    });
  }));
}
```

Це відображення зображень у `frame` (який є масивом масивів даних відображення) для створення масиву
обіцянок запиту. Потім повертається обіцянка, яка об'єднує їх усі.

Для того, щоб мати можливість зупинити відтворення відео, процес обгорнуто у клас. Цей клас має асинхронний метод `play`, який повертає обіцянку, що розв'язується лише тоді, коли відтворення знову зупинено за допомогою методу `stop`.

```{includeCode: true}
function wait(time) {
  return new Promise(accept => setTimeout(accept, time));
}

class VideoPlayer {
  constructor(frames, frameTime) {
    this.frames = frames;
    this.frameTime = frameTime;
    this.stopped = true;
  }

  async play() {
    this.stopped = false;
    for (let i = 0; !this.stopped; i++) {
      let nextFrame = wait(this.frameTime);
      wait displayFrame(this.frames[i % this.frames.length]);
      wait nextFrame;
    }
  }

  stop() {
    this.stopped = true;
  }
}
```

Функція `wait` обертає `setTimeout` в обіцянку, яка виконується через задану кількість мілісекунд. Це корисно для керування швидкістю відтворення.

```{startCode: true}
let video = new VideoPlayer(clipImages, 100);
video.play().catch(e => {
  console.log("Відтворення не вдалося: » + e);
});
setTimeout(() => video.stop(), 15000);
```

Протягом усього тижня, що стоїть екранна стіна, щовечора, коли стемніє, на ній загадковим чином з'являється величезний птах, що світиться помаранчевим кольором.

## Цикл обробки подій

{{index «asynchronous programming», scheduling, «event loop», timeline}}

Асинхронна програма починається з запуску головного скрипту, який часто встановлює зворотні виклики, що будуть викликані пізніше. Цей основний сценарій, а також зворотні виклики, виконуються до завершення безперервно, як єдине ціле. Але між ними програма може простоювати, очікуючи, що щось станеться.

{{index «setTimeout function»}}

Отже, зворотні виклики не викликаються безпосередньо кодом, який їх запланував. Якщо я викликаю `setTimeout` зсередини функції, ця функція повернеться до моменту виклику функції зворотного виклику. І коли функція зворотного виклику повернеться, керування не повернеться до функції, яка його запланувала.

{{index «Promise class», «catch keyword», «exception handling»}}

Асинхронна поведінка відбувається у власній порожній функції ((стек викликів)). Це одна з причин, чому без обіцянок керувати винятками в асинхронному коді так важко. Оскільки кожен зворотний виклик починається з майже порожнього стеку, ваші обробники `catch` не будуть знаходитись у стеку, коли вони генерують виключення.

```
try {
  setTimeout(() => {
    throw new Error(«Woosh»);
  }, 20);
} catch (e) {
  // Це не буде виконуватись
  console.log(«Caught», e);
}
```

{{index thread, queue}}

Незалежно від того, наскільки близько одна від одної відбуваються події, такі як таймаут або вхідні запити, середовище JavaScript виконуватиме лише одну програму одночасно. Ви можете уявити це як запуск великого циклу _навколо_ вашої програми, який називається _цикл обробки подій_. Коли нічого не відбувається, цей цикл призупиняється. Але коли події надходять, вони додаються до черги, і їхній код виконується один за одним. Оскільки дві речі не можуть виконуватися одночасно, повільний код може затримати обробку інших подій.

У цьому прикладі встановлюється тайм-аут, але потім відбувається затримка до моменту закінчення тайм-ауту, що призводить до запізнення тайм-ауту.

```
let start = Date.now();
setTimeout(() => {
  console.log(«Таймаут закінчився в», Date.now() - start);
}, 20);
while (Date.now() < start + 50) {}
console.log(«Втрачено часу до», Date.now() - start);
// → Даремно витрачено часу до 50
// → Таймаут закінчився на 55
```

{{index «resolving (a promise)», «rejecting (a promise)», «Promise class»}}

Обіцянки завжди вирішуються або відхиляються як нова подія. Навіть якщо обіцянка вже виконана, її очікування призведе до того, що ваш зворотний виклик буде виконано після завершення поточного сценарію, а не одразу.

```
Promise.resolve(«Done»).then(console.log);
console.log(«Я перший!»);
// → Я перший!
// → Виконано
```

У наступних розділах ми розглянемо інші типи подій, які виконуються у циклі.

## Асинхронні помилки

{{index «asynchronous programming», [state, transitions]}}

Коли ваша програма виконується синхронно, за один прохід, не відбувається жодних змін стану, окрім тих, які виконує сама програма. Для асинхронних програм все інакше - вони можуть мати « прогалини » у виконанні, під час яких може виконуватися інший код.

Розглянемо приклад. Це функція, яка намагається повідомити розмір кожного файлу у масиві файлів, намагаючись прочитати їх одночасно, а не послідовно.

{{index «fileSizes function»}}

```{includeCode: true}
async function fileSizes(files) {
  let list = «»;
  await Promise.all(files.map(async fileName => {
    list += fileName + «: » +
      (await textFile(fileName)).length + «\n»;
  }));
  return list;
}
```

{{index «async function»}}

Частина `async fileName =>` показує, як ((стрілочна функція))s також можна зробити `async`, поставивши перед ними слово `async`.

{{index «Promise.all function»}}

Код не виглядає відразу підозрілим... він відображає функцію стрілки `async` на масив імен, створюючи масив обіцянок, а потім використовує `Promise.all`, щоб дочекатися їх усіх, перш ніж повернути сформований ними список.

Але ця програма повністю зламана. Вона завжди повертатиме лише один рядок, у якому буде вказано файл, який було прочитано найдовше.

{{якщо інтерактивно

```
fileSizes([«plans.txt», «shopping_list.txt»])
  .then(console.log);
```

if}}

Можеш з'ясувати, чому?

{{індекс «+= оператор»}}

Проблема полягає в операторі `+=`, який бере _поточне_ значення `list` на момент початку виконання оператора, а потім, коли `await` завершується, встановлює прив'язку `list` на це значення плюс доданий рядок.

{{index «await ключове слово»}}

Але між початком виконання оператора та його завершенням існує асинхронний проміжок часу. Вираз `map` виконується до того, як щось було додано до списку, тому кожен з операторів `+=` починається з порожнього рядка і закінчується, коли завершується пошук у сховищі, встановлюючи `list` у результат додавання свого рядка до порожнього рядка.

{{index «побічний ефект»}}

Цього можна було б легко уникнути, повернувши рядки з відображених обіцянок і викликавши `join` до результату `Promise.all`, замість того, щоб створювати список за допомогою зміни прив'язки. Як завжди, обчислення нових значень менш схильне до помилок, ніж зміна існуючих значень.

{{index «fileSizes function»}}

```
async function fileSizes(files) {
  let lines = files.map(async fileName => {
    return fileName + «: » +
      (await textFile(fileName)).length;
  });
  return (await Promise.all(lines)).join(«\n»);
}
```

Таких помилок легко припуститися, особливо при використанні `await`, і ви повинні знати, де у вашому коді є прогалини. Перевагою _явної_ асинхронності JavaScript (чи то через зворотні виклики, чи то через обіцянки, чи то через `await`) є те, що виявити ці прогалини відносно легко.

## Підсумок

Асинхронне програмування дозволяє виражати очікування для довготривалих дій без зупинки всієї програми. Середовища JavaScript зазвичай реалізують цей стиль програмування за допомогою функцій зворотного виклику, які викликаються після завершення дій. Цикл подій планує виклик таких функцій зворотного виклику в потрібний момент, одна за одною, щоб їх виконання не перекривалося.

Асинхронне програмування полегшують обіцянки - об'єкти, які представляють дії, що можуть завершитися у майбутньому, та функції `async`, які дозволяють писати асинхронну програму так, як якщо б вона була синхронною.

## Вправи

## Quiet Times

{{index «quiet times (exercise)», «security camera», «Carla the crow», «async function»}}

Біля лабораторії Карли встановлено камеру спостереження, яка активується датчиком руху. Вона підключена до мережі і починає надсилати відеопотік, коли вона активна. Щоб її не викрили, Карла налаштувала систему, яка помічає цей тип бездротового мережевого трафіку і вмикає світло в її лігві щоразу, коли ззовні спостерігається активність, тож вона знає, коли треба сидіти тихо.

{{index «Date class», «Date.now function», timestamp}}

Вона також вже деякий час записує час, коли камера спрацьовує, і хоче використовувати цю інформацію, щоб візуалізувати, коли в середньому за тиждень буває тихо, а коли - жваво. Журнал зберігається у файлах, що містять один номер мітки часу (повертається `Date.now()`) у рядку.

```{lang: null}
1695709940692
1695701068331
1695701189163
```

У файлі `«camera_logs.txt»` зберігається список лог-файлів. Напишіть асинхронну функцію `activityTable(day)`, яка для заданого дня тижня повертає масив з 24 чисел, по одному для кожної години дня, які містять кількість спостережень мережевого трафіку камер, помічених у цю годину дня. Дні ідентифікуються за номерами за системою, що використовується функцією `Date.getDay`, де неділя дорівнює 0, а субота - 6.

Функція `activityGraph`, надана пісочницею, підсумовує таку таблицю у рядок.

{{index «textFile function»}}

Для читання файлів використовуйте функцію `textFile`, визначену раніше - за заданим іменем файлу вона повертає обіцянку, яка перетворюється на вміст файлу. Пам'ятайте, що `new Date(timestamp)` створює об'єкт `Date` для цього часу, який має методи `getDay` і `getHours`, що повертають день тижня і годину дня.

Обидва типи файлів - список файлів журналів і самі файли журналів - мають кожен елемент даних у окремому рядку, відокремленому символами нового рядка (`«\n»`).

{{якщо інтерактивно

```{test: no}
async function activityTable(day) {
  let logFileList = await textFile(«camera_logs.txt»);
  // Ваш код тут
}

activityTable(1)
  .then(table => console.log(activityGraph(table)));
```

if}}

{{hint

{{index «тихий час (вправа)», «метод розбиття», «функція textFile», «клас дати»}}

Вам потрібно перетворити вміст цих файлів у масив. Найпростіший спосіб зробити це - застосувати метод `split` до рядка, отриманого за допомогою функції `textFile`. Зауважте, що для файлів журналів це все одно дасть вам масив рядків, які ви маєте перетворити на числа перед тим, як передавати їх до `new Date`.

Підсумовування всіх часових точок у таблицю годин можна зробити, створивши таблицю (масив), яка містить число для кожної години доби. Після цього ви можете переглянути всі мітки часу (файли журналів і числа у кожному файлі журналу) і для кожної з них, якщо вона сталася у відповідний день, взяти годину, в яку вона сталася, і додати одиницю до відповідного числа у таблиці.

{{index «async function», «await keyword», «Promise class»}}

Переконайтеся, що ви використовуєте `await` для результату асинхронних функцій, перш ніж щось з ним робити, інакше ви отримаєте `Обіцянку` там, де ви очікували рядок.

підказка}}


### Реальні обіцянки

{{index «real promises (exercise)», «Promise class»}}

Перепишіть функцію з попередньої вправи без `async`/`await`, використовуючи звичайні методи `Promise`.

{{якщо інтерактивно

```{test: no}}
function activityTable(day) {
  // Ваш код тут
}

activityTable(6)
  .then(table => console.log(activityGraph(table)));
```

if}}

{{index «async function», «await keyword», performance}}

У цьому стилі використання `Promise.all` буде зручнішим, ніж спроба змоделювати цикл над лог-файлами. У функції `async` простіше просто використовувати `await` у циклі. Якщо читання файлу займає деякий час, який з цих двох підходів займе найменше часу для виконання?

{{index «rejecting (a promise)»}}

Якщо в одному з файлів, перелічених у списку файлів, допущено помилку, і його читання завершилося невдачею, як ця невдача відобразиться на об'єкті `Promise`, який повертає ваша функція?

{{hint

{{index «real promises (exercise)», «then method», «textFile function», «Promise.all function»}}

Найпростіший підхід до написання цієї функції полягає у використанні ланцюжка викликів `then`. Перша обіцянка створюється шляхом читання списку лог-файлів. Перший зворотний виклик може розділити цей список і відобразити `textFile` на нього, щоб отримати масив обіцянок для передачі в `Promise.all`. Він може повернути об'єкт, отриманий від `Promise.all`, так що все, що він поверне, стане результатом значення, отриманого від цього першого `then`.

{{індекс «асинхронне програмування»}}

Тепер у нас є обіцянка, яка повертає масив лог-файлів. Ми можемо знову викликати `then` і додати туди логіку підрахунку міток часу. Щось на кшталт цього:

```{test: no}
function activityTable(day) {
  return textFile(«camera_logs.txt»).then(files => {
    return Promise.all(files.split(«\n»).map(textFile));
  }).then(logs => {
    // проаналізувати...
  });
}
```

Або ви можете, для ще кращого планування роботи, помістити аналіз кожного файлу всередину `Promise.all`, так, щоб цю роботу можна було розпочати для першого файлу, який повертається з диска, ще до того, як повернуться інші файли.

```{test: no}
function activityTable(day) {
  let table = []; // ініціалізація...
  return textFile(«camera_logs.txt»).then(files => {
    return Promise.all(files.split(«\n»).map(name => {
      return textFile(name).then(log => {
        // проаналізувати...
      });
    }));
  }).then(() => table);
}
```

{{index «await keyword», scheduling}}

Це показує, що те, як ви структуруєте свої обіцянки, може мати реальний вплив на те, як планується робота. Простий цикл з `await` зробить процес повністю лінійним - він чекатиме на завантаження кожного файлу, перш ніж продовжити. «Обіцяти.все» дає можливість концептуально працювати над декількома завданнями одночасно, дозволяючи їм просуватися вперед, поки файли все ще завантажуються. Це може бути швидше, але це також робить порядок, в якому все буде відбуватися, менш передбачуваним. У цьому випадку ми лише збільшуватимемо числа в таблиці, що неважко зробити безпечним способом. Для інших типів проблем це може бути набагато складніше.

{{index «rejecting (a promise)», «then method»}}

Якщо файл у списку не існує, обіцянку, повернуту `textFile`, буде відкинуто. Оскільки `Promise.all` відхиляє, якщо будь-яка з переданих йому обіцянок зазнає невдачі, значення зворотного виклику, переданого першому `then`, також буде відхиленою обіцянкою. Це призводить до того, що обіцянка, яку повертає `then`, зазнає невдачі, тому зворотний виклик, що передається другому `then`, навіть не викликається, і функція повертає відхилену обіцянку.

підказка}}

### Збірка Promise.all

{{index «Promise class», «Promise.all function», «building Promise.all (exercise)»}}

Як ми бачили, за наявності масиву ((promise))s, `Promise.all` повертає обіцянку, яка чекає на завершення всіх обіцянок у масиві. Після цього вона виконується успішно і повертає масив значень результату. Якщо одна з обіцянок у масиві зазнає невдачі, обіцянка, яку повертає `all`, також зазнає невдачі, передаючи причину невдачі з обіцянки, що зазнала невдачі.

Реалізуйте щось подібне самостійно як звичайну функцію з назвою `Promise_all`.

Пам'ятайте, що після того, як обіцянка була успішною або невдалою, вона не може бути успішною або невдалою знову, і подальші виклики функцій, які її вирішують, ігноруються. Це може спростити роботу з невдачею вашої обіцянки.

{{if інтерактивний

```{test: no}
function Promise_all(promises) {
  return new Promise((resolve, reject) => {
    // Ваш код тут.
  });
}

// Тестовий код.
Promise_all([]).then(array => {
  console.log(«Тут має бути []:», array);
});
function soon(val) {
  return new Promise(resolve => {
    setTimeout(() => resolve(val), Math.random() * 500);
  });
}
Promise_all([soon(1), soon(2), soon(3)]).then(array => {
  console.log(«Має бути [1, 2, 3]:», array);
});
Promise_all([soon(1), Promise.reject(«X»), soon(3)])
  .then(array => {
    console.log(«Ми не повинні сюди потрапити»);
  })
  .catch(error => {
    if (error != «X») {
      console.log(«Неочікуваний збій:», error);
    }
  });
```

if}}

{{hint

{{індекс «функція Promise.all», «клас обіцянки», «метод then», «побудова Promise.all (exercise)»}}

Функція, передана конструктору `Promise`, повинна буде викликати метод `then` для кожної з обіцянок у заданому масиві. Коли одна з них виконається, повинні відбутися дві речі. Отримане значення має бути збережено у правильній позиції масиву результатів, і ми повинні перевірити, чи це була остання очікувана ((promise)) обіцянка, і завершити нашу власну обіцянку, якщо це було так.

{{index «змінна-лічильник»}}

Останнє можна зробити за допомогою лічильника, який ініціалізується довжиною вхідного масиву і від якого ми віднімаємо 1 кожного разу, коли обіцянка виконується успішно. Коли він досягне 0, ми закінчимо. Переконайтеся, що ви врахували ситуацію, коли вхідний масив порожній (а отже, жодна обіцянка ніколи не виконається).

Обробка невдачі вимагає певних роздумів, але виявляється надзвичайно простою. Просто передайте функцію `reject` обгорткової обіцянки кожній з обіцянок у масиві як обробник `catch` або як другий аргумент до `then` так, щоб відмова в одній з них викликала відхилення всієї обгорткової обіцянки.

підказка}}
