{{meta {load_files: [«code/chapter/16_game.js», «code/levels.js», «code/_stop_keys.js»], zip: «html include=[\«css/game.css\»]"}}}

# Project: Платформерна гра

{{quote {author: «Iain Banks», title: «The Player of Games», chapter: true}} {{quote {author: “Iain Banks”, title: “The Player of Games”, chapter: true}}
Вся реальність - це гра.

quote}}

{{індекс «Бенкс, Ієн», «розділ проекту», «симуляція» }}

{{figure {url: «img/chapter_picture_16.jpg», alt: «Ілюстрація із зображенням персонажа комп'ютерної гри, що стрибає через лаву у двовимірному світі», »chapter: «Обрамлення"}}}.

Моє початкове захоплення комп'ютерами, як і у багатьох дітей-ботаніків, було пов'язане з комп'ютерними іграми. Мене приваблювали крихітні симульовані ((світ)), якими я міг маніпулювати і в яких розгорталися історії - більше, гадаю, через те, як я проектував на них свою ((уяву)), ніж через ті можливості, які вони насправді пропонували.

Я нікому не бажаю кар'єри програміста ігор. Як і у випадку з музичною індустрією, невідповідність між кількістю молодих людей, які хочуть працювати в ній, і реальним попитом на таких людей створює досить нездорове середовище. Але писати ігри для розваги - це весело.

{{index «jump-and-run game», dimensions}}

У цій главі ми розглянемо реалізацію невеликої ((платформної гри)). Платформні ігри (або ігри «стрибай і біжи») - це ігри, у яких гравець повинен переміщати фігурку у ((світі)), який зазвичай є двовимірним і видимим збоку, перестрибуючи через предмети і на них.

## Гра

{{index minimalism, «Palef, Thomas», «Dark Blue (гра)»}}

Наша ((гра)) буде приблизно заснована на [Dark Blue](http://www.lessmilk.com/games/10)[ (www.lessmilk.com/games/10_)]{if book} Томаса Палефа. Я вибрав цю гру, тому що вона і цікава, і мінімалістична, і тому що її можна створити без зайвого ((коду)). Виглядає вона так:

{{figure {url: «img/darkblue.png», alt: «Скріншот гри «Dark Blue», що показує світ, зроблений з кольорових коробок. Чорна коробка, що представляє гравця, стоїть на білих лініях на синьому тлі. Маленькі жовті монети плавають у повітрі, а деякі частини фону червоні, що зображують лаву.» }}}.

{{індексна монета, лава}}

Темна ((коробка)) представляє ((гравця)), завданням якого є збирати жовті коробки (монети), уникаючи при цьому червоного кольору (лави). Рівень вважається завершеним, коли всі монети зібрано.

{{індексна клавіатура, стрибки}}

Гравець може ходити за допомогою клавіш зі стрілками вліво та вправо, а також стрибати за допомогою стрілки вгору. Стрибки - це особливість цього ігрового персонажа. Він може досягати висоти, що в кілька разів перевищує його власний зріст, і може змінювати напрямок у повітрі. Це може бути не зовсім реалістично, але допомагає гравцеві відчути, що він безпосередньо контролює ситуацію на екрані ((аватар)).

{{індекс «дробове число», дискретизація, «штучне життя», «електронне життя»}}

Гра складається зі статичного ((фон)), викладеного у вигляді ((сітка)), на який накладаються рухомі елементи. Кожне поле на сітці може бути або порожнім, або суцільним, або ((лава)). Рухомими елементами є гравець, монети та певні шматки лави. Позиції цих елементів не обмежені сіткою - їхні координати можуть бути дробовими, що забезпечує плавний ((рух)).

## Технологія

{{index «обробка подій», клавіатура, [DOM, графіка]}}

Ми будемо використовувати ((браузер)) DOM для відображення гри, а користувацьке введення будемо зчитувати за допомогою обробки ключових подій.

{{index rectangle, «background (CSS)», «position (CSS)», graphics}}

Код, пов'язаний з екраном та клавіатурою, - це лише невелика частина роботи, яку нам потрібно виконати, щоб створити цю ((гру)). Оскільки все виглядає як кольорові ((box))и, малювання нескладне: ми створюємо DOM-елементи і використовуємо стилі, щоб надати їм колір фону, розмір і позицію.

{{index «table (HTML-тег)»}}

Ми можемо представити фон у вигляді таблиці, оскільки він являє собою незмінну ((сітку)) квадратів. Вільно рухомі елементи можна перекрити за допомогою абсолютно позиціонованих елементів.

{{індекс продуктивності, [DOM, графіка]}}

У іграх та інших програмах, які повинні анімувати ((графіка)) і реагувати на дії користувача ((введення)) без помітної затримки, ((ефективність)) має важливе значення. Хоча DOM спочатку не призначався для високопродуктивної графіки, він справляється з цим краще, ніж можна було б очікувати. Ви бачили деякі ((анімації)) у [Глава ?](dom#animation). На сучасному комп'ютері така проста гра буде працювати добре, навіть якщо ми не будемо надто перейматися ((оптимізацією)).

{{index canvas, [DOM, графіка]}}

У [наступному розділі](canvas) ми розглянемо іншу технологію ((браузер)), тег `<canvas>`, який забезпечує більш традиційний спосіб малювання графіки, працюючи з фігурами та ((пікселями)), а не з елементами DOM.

## Рівні

{{розміри індексів}}

Нам потрібен зручний для читання і редагування спосіб вказівки рівнів. Оскільки все може починатися з сітки, ми можемо використовувати великі рядки, у яких кожен символ представляє елемент - або частину фонової сітки, або рухомий елемент.

План для невеликого рівня може виглядати наступним чином:

```{includeCode: true}
let simpleLevelPlan = `
......................
..#................#..
..#..............=.#..
..#.........o.o....#...
..#.@......#####...#..
..#####............#..
......#++++++++++++#..
......##############..
......................`;
```

{{рівень індексу}}

Крапки - це порожній простір, символи хешу (`#`) - стіни, а знаки плюс - лава. Початкова позиція ((гравця)) - це позиція ((за знаком)) (`@`). Кожен символ O - це монета, а знак рівності (`=`) вгорі - блок лави, який рухається вперед-назад по горизонталі.

{{індекс стрибає}}

Ми підтримуємо два додаткових типи руху ((лави)): символ труби (`|`) створює вертикально рухомі блоки, а `v` позначає _капаючу_ лаву - вертикально рухому лаву, яка не відскакує вперед-назад, а лише рухається вниз, відскакуючи назад у початкове положення, коли потрапляє на підлогу.

Ціла ((гра)) складається з декількох ((рівнів)), які ((гравець)) повинен пройти. Рівень вважається завершеним, коли зібрано всі ((монети)). Якщо гравець торкається ((лава)), поточний рівень відновлюється до початкової позиції, і гравець може спробувати ще раз.

{{id level}}

## Читання рівня

{{index «Клас рівня»}}

Наступна функція ((клас)) зберігає об'єкт ((рівень)). Його аргументом має бути рядок, що визначає рівень.

```{includeCode: true}
class Level {
  constructor(plan) {
    let rows = plan.trim().split(«\n»).map(l => [...l]);
    this.height = rows.length
    this.width = rows[0].length;
    this.startActors = [];

    this.rows = rows.map((row, y) => {
      return row.map((ch, x) => {
        let type = levelChars[ch];
        if (typeof type != «string») {
          let pos = new Vec(x, y);
          this.startActors.push(type.create(pos, ch));
          type = «empty»;
        }
        повернути тип;
      });
    });
  }
}
```

{{index «trim method», «split method», [whitespace, trimming]}}

Метод `trim` використовується для видалення пробілів на початку і в кінці рядка плану. Це дозволяє нашому прикладу плану починатися з нового рядка, так що всі рядки знаходяться безпосередньо один під одним. Решта рядка розбивається на ((символ нового рядка))s, і кожен рядок перетворюється на масив, створюючи масив символів.

{{index [array, «as matrix»]}}

Отже, `rows` містить масив масивів символів, рядків плану. З них ми можемо отримати ширину та висоту рівня. Але нам ще потрібно відокремити рухомі елементи від фонової сітки. Назвемо рухомі елементи _акторами_. Вони зберігатимуться у масиві об'єктів. Тло буде масивом масивів рядків, що містять такі типи полів, як ``порожнє``, ``стіна`` або ``лава``.

{{index «map method»}}

Щоб створити ці масиви, ми зіставляємо рядки, а потім їхній вміст. Пам'ятайте, що `map` передає індекс масиву як другий аргумент функції відображення, який вказує нам на x- та y-координати заданого персонажа. Позиції у грі зберігатимуться як пари координат, де верхній лівий кут дорівнює 0,0, а кожна клітинка фону - 1 одиниця у висоту та ширину.

{{index «static method»}}

Для інтерпретації символів на плані конструктор `Level` використовує об'єкт `levelChars`, який для кожного символу, що використовується в описах рівнів, містить рядок, якщо це тип фону, і клас, якщо він створює актора. Якщо `type` є класом актора, його статичний метод `create` використовується для створення об'єкта, який додається до `startActors`, а функція відображення повертає `«порожньо»` для цього фонового квадрата.

{{index «Vec class»}}

Позиція актора зберігається як об'єкт `Vec`. Це двовимірний вектор, об'єкт з властивостями `x` та `y`, як показано у вправах [Розділу ?] (об'єкт#вектор_вправи).

{{індекс [стан, в об'єктах]}}

Під час гри актори будуть опинятися у різних місцях або навіть зникати зовсім (як монети, коли їх збирають). Ми будемо використовувати клас `State` для відстеження стану гри, що виконується.

```{includeCode: true}
class State {
  constructor(level, actors, status) {
    this.level = level
    this.actors = actors
    this.status = status;
  }

  static start(level) {
    return new State(level, level.startActors, «playing»);
  }

  get player() {
    return this.actors.find(a => a.type == «player»);
  }
}
```

Властивість `status` зміниться на `«програно»` або `«виграно»`, коли гра закінчиться.

Це знову ж таки стійка структура даних - оновлення стану гри створює новий стан і залишає старий стан недоторканим.

## Актори

{{index actor, «Vec class», [інтерфейс, об'єкт]}}

Об'єкти-актори представляють поточну позицію та стан певного рухомого елементу (гравця, монети або рухомої лави) у нашій грі. Всі об'єкти акторів мають однаковий інтерфейс. Вони мають властивості `size` та `pos`, що містять розмір та координати верхнього лівого кута прямокутника, який представляє цей об'єкт, а також метод `update`.

Метод `update` використовується для обчислення нового стану та позиції актора після заданого кроку часу. Він імітує те, що робить актор - рухається у відповідь на натискання клавіш зі стрілками для гравця і підстрибує туди-сюди для лави - і повертає новий, оновлений об'єкт актора.

Властивість `type` містить рядок, який ідентифікує тип актора - `player`, `coin` або `lava`. Це корисно під час малювання гри - вигляд прямокутника, намальованого для актора, базується на його типі.

Класи акторів мають статичний метод `create`, який використовується конструктором `Level` для створення актора з персонажа на плані рівня. Йому передаються координати персонажа і сам персонаж, що є необхідним, оскільки клас `Lava` обробляє декілька різних персонажів.

{{id vector}}

Це клас `Vec`, який ми будемо використовувати для наших двовимірних значень, таких як положення та розмір акторів.

```{includeCode: true}
class Vec {
  constructor(x, y) {
    this.x = x; this.y = y;
  }
  plus(other) {
    return new Vec(this.x + other.x, this.y + other.y);
  }
  times(factor) {
    return new Vec(this.x * factor, this.y * factor);
  }
}
```

{{index «times method», множення}}

Метод `times` масштабує вектор на задане число. Він буде корисним, коли нам потрібно помножити вектор швидкості на часовий інтервал, щоб отримати відстань, пройдену за цей час.

Різні типи акторів отримують власні класи, оскільки їхня поведінка дуже відрізняється. Давайте визначимо ці класи. Ми розглянемо їхні методи `update` пізніше.

{{index simulation, «Клас гравця»}}

Клас гравця має властивість `speed`, яка зберігає його поточну швидкість для імітації імпульсу та гравітації.

```{includeCode: true}}
class Player {
  constructor(pos, speed) {
    this.pos = pos;
    this.speed = speed;
  }

  get type() { return «player»; }

  static create(pos) {
    return new Player(pos.plus(new Vec(0, -0.5)),
                      new Vec(0, 0));
  }
}

Player.prototype.size = new Vec(0.8, 1.5);
```

Оскільки гравець має висоту півтори клітинки, його початкова позиція встановлюється на півклітинки вище позиції, де з'явився символ `@`. Таким чином, його нижня частина збігається з нижньою частиною клітинки, де він з'явився.

Властивість `size` однакова для всіх екземплярів `Player`, тому ми зберігаємо її на прототипі, а не на самих екземплярах. Ми могли б використати ((getter)) на кшталт `type`, але це призвело б до створення і повернення нового об'єкта `Vec` кожного разу, коли читається властивість, що було б марнотратством. (Рядки, будучи ((незмінними)), не потрібно створювати заново щоразу, коли вони обчислюються).

{{index «Lava class», bouncing}}

При створенні актора `Lava` нам потрібно ініціалізувати об'єкт по-різному, залежно від того, на якому персонажі він базується. Динамічна лава рухається з поточною швидкістю, доки не натрапить на перешкоду. У цей момент, якщо у неї є властивість `reset`, вона повернеться у початкове положення (капає). Якщо ні, то він змінить швидкість і продовжить рух у зворотному напрямку (підстрибуючи).

Метод `create` дивиться на символ, переданий конструктором `Level`, і створює відповідний актор лави.

```{includeCode: true}
class Lava {
  constructor(pos, speed, reset) {
    this.pos = pos;
    this.speed = speed;
    this.reset = reset;
  }

  get type() { return «lava»; }

  static create(pos, ch) {
    if (ch == «=») {
      return new Lava(pos, new Vec(2, 0));
    } else if (ch == «|») { return
      return new Lava(pos, new Vec(0, 2));
    } else if (ch == «v») { return new Vec(0, 2)
      return new Lava(pos, new Vec(0, 3), pos);
    }
  }
}

Lava.prototype.size = new Vec(1, 1);
```

{{index «Coin class», animation}}

Актори `Coin` відносно прості. Здебільшого вони просто сидять на своїх місцях. Але щоб трохи оживити гру, їм додано «вобл» - легкі вертикальні рухи вперед-назад. Щоб відстежувати це, об'єкт монети зберігає базову позицію, а також властивість «коливання», яка відстежує ((фазу)) руху, що підстрибує. Разом вони визначають фактичне положення монети (зберігається у властивості `pos`).

```{includeCode: true}
class Coin {
  constructor(pos, basePos, wobble) {
    this.pos = pos;
    this.basePos = basePos;
    this.wobble = wobble;
  }

  get type() { return «coin»; }

  static create(pos) {
    let basePos = pos.plus(new Vec(0.2, 0.1));
    return new Coin(basePos, basePos,
                    Math.random() * Math.PI * 2);
  }
}

Coin.prototype.size = new Vec(0.6, 0.6);
```

{{індекс «Math.random function», «random number», «Math.sin function», sine, wave}}

У [Главі ?](dom#sin_cos) ми бачили, що `Math.sin` дає нам координату y точки на колі. Ця координата плавно змінюється вперед і назад, коли ми рухаємося вздовж кола, що робить функцію синуса корисною для моделювання хвилеподібного руху.

{{індекс pi}}

Щоб уникнути ситуації, коли всі монети рухаються вгору і вниз синхронно, початкова фаза кожної монети рандомізована. Період хвилі `Math.sin`, тобто ширина хвилі, яку він створює, дорівнює 2π. Ми множимо значення, повернуте `Math.random`, на це число, щоб надати монеті випадкову початкову позицію на хвилі.

{{index map, [object, «as map»]}}

Тепер ми можемо визначити об'єкт `levelChars`, який зіставляє символи плану з типами фонової сітки або класами акторів.

```{includeCode: true}
const levelChars = {
  «.": «пусто», “#”: «стіна», “+”: «lava»,
  «@": гравець, «o»: Монета,
  «=": Лава, «|»: Лава, «v»: Лава
};
```

Це дає нам усі частини, необхідні для створення екземпляра `Level`.

```{includeCode: strip_log}
let simpleLevel = new Level(simpleLevelPlan);
console.log(`${simpleLevel.width} by ${simpleLevel.height}`);
// → 22 на 9
```

Наше завдання полягає у відображенні таких рівнів на екрані та моделюванні часу і руху всередині них.

{{id domdisplay}}

## Малюнок

{{index graphics, encapsulation, «DOMDisplay class», [DOM, graphics]}}

У [наступному розділі](canvas#canvasdisplay) ми ((відобразимо)) ту саму гру у інший спосіб. Щоб зробити це можливим, ми винесемо логіку малювання за межі інтерфейсу і передамо її грі як аргумент. Таким чином, ми можемо використовувати ту саму ігрову програму з різними новими модулями відображення.

Ігровий об'єкт малює заданий ((рівень)) і стан. Ми передаємо його конструктор грі, щоб його можна було замінити. Клас дисплея, який ми визначаємо у цій главі, називається `DOMDisplay`, тому що він використовує елементи DOM для відображення рівня.

{{index «style attribute», CSS}}

Ми будемо використовувати таблицю стилів для встановлення фактичних кольорів та інших фіксованих властивостей елементів, з яких складається гра. Також можна було б безпосередньо призначити властивість `style` елементам під час їх створення, але це призвело б до створення більш багатослівних програм.

{{index «class attribute»}}

Наступна допоміжна функція надає стислий спосіб створення елемента і надання йому деяких атрибутів та дочірніх вузлів:

```{includeCode: true}
function elt(name, attrs, ...children) {
  let dom = document.createElement(name);
  for (let attr of Object.keys(attrs)) {
    dom.setAttribute(attr, attrs[attr]);
  }
  for (let child of children) {
    dom.appendChild(child);
  }
  return dom;
}
```

Дисплей створюється шляхом надання йому батьківського елемента, до якого він має приєднатися, та об'єкта ((level)).

```{includeCode: true}
class DOMDisplay {
  constructor(parent, level) {
    this.dom = elt(«div», {class: «game"}, drawGrid(level));
    this.actorLayer = null;
    parent.appendChild(this.dom);
  }

  clear() { this.dom.remove(); }
}
```

{{index level}}

Сітка рівня ((background)), яка ніколи не змінюється, малюється один раз. Актори перемальовуються кожного разу, коли дисплей оновлюється з певним станом. Властивість `actorLayer` буде використано для відстеження елемента, який містить акторів, щоб їх можна було легко видалити та замінити.

{{index scaling, «DOMDisplay class»}}

Наші ((координати)) та розміри відстежуються у ((сітка)) одиницях, де розмір або відстань 1 означає один блок сітки. При встановленні розмірів ((pixel)) нам доведеться масштабувати ці координати - все у грі було б смішно маленьким при одному пікселі на квадрат. Константа `scale` задає кількість пікселів, яку займає один юніт на екрані.

```{includeCode: true}
const scale = 20;

function drawGrid(level) {
  return elt(«table», {
    class: «background»,
    style: `width: ${level.width * scale}px`
  }, ...level.rows.map(row =>)
    elt(«tr», {style: `height: ${scale}px`},
        ...row.map(type => elt(«td», {class: type})))
  ));
}
```

{{index «table (HTML-тег)», «tr (HTML-тег)», «td (HTML-тег)», «spread operator»}}

Форма елемента `<table>` добре відповідає структурі властивості `rows` рівня - кожен рядок сітки перетворюється на рядок таблиці (елемент `<tr>`). Рядки в сітці використовуються як імена класів для елементів комірок таблиці (`<td>`). У коді використовується оператор spread (потрійна крапка) для передачі масивів дочірніх вузлів до `elt` як окремих аргументів.

{{id game_css}}

Наступний код ((CSS)) робить таблицю схожою на потрібний нам фон:

```{lang: «css"}}
.background { background: rgb(52, 166, 251);
                 table-layout: fixed;
                 border-spacing: 0; }
.background td { padding: 0; }
.lava { background: rgb(255, 100, 100); }
.wall { background: white; }
```

{{index «padding (CSS)»}}

Деякі з них (`table-layout`, `border-spacing` і `padding`) використовуються для придушення небажаної поведінки за замовчуванням. Ми не хочемо, щоб макет ((таблиці)) залежав від вмісту її клітинок, а також не хочемо, щоб між клітинками ((таблиці)) були пробіли або відступи всередині них.

{{index «background (CSS)», «rgb (CSS)», CSS}}

Правило `background` задає колір фону. CSS дозволяє задавати кольори як словами (`white`), так і у форматі `rgb(R, G, B)`, де червона, зелена і синя складові кольору розділені трьома числами від 0 до 255. У форматі `rgb(52, 166, 251)` червона складова дорівнює 52, зелена - 166, а синя - 251. Оскільки синя складова є найбільшою, результуючий колір буде синюватим. У правилі `.lava` перше число (червоне) є найбільшим.

{{index [DOM, graphics]}}

Ми малюємо кожен ((actor)), створюючи для нього DOM-елемент і встановлюючи позицію і розмір цього елемента на основі властивостей актора. Значення мають бути помножені на `scale`, щоб перейти від ігрових одиниць до пікселів.

```{includeCode: true}
function drawActors(actors) {
  return elt(«div», {}, ...actors.map(actor => {
    let rect = elt(«div», {class: `actor ${actor.type}`});
    rect.style.width = `${actor.size.x * scale}px`;
    rect.style.height = `${actor.size.y * scale}px`;
    rect.style.left = `${actor.pos.x * scale}px`;
    rect.style.top = `${actor.pos.y * scale}px`;
    повернути rect;
  }));
}
```

{{index «position (CSS)», «class attribute»}}

Щоб надати елементу більше одного класу, ми розділяємо імена класів пробілами. У наступному коді ((CSS)) клас `actor` надає акторам їхню абсолютну позицію. Ім'я їхнього типу використовується як додатковий клас, щоб надати їм колір. Нам не потрібно визначати клас `lava` знову, тому що ми повторно використовуємо клас для квадратів сітки лави, які ми визначили раніше.

```{lang: «css"}
.actor { position: absolute; }
.coin { background: rgb(241, 229, 89); }
.player { background: rgb(64, 64, 64); }
```

{{індекс графіки, оптимізація, ефективність, [стан, «додатку»], [DOM, графіка]}}

Метод ``синхронізувати стан`` використовується для того, щоб змусити дисплей показувати заданий стан. Він спочатку видаляє стару графіку акторів, якщо така є, а потім перемальовує акторів у нові позиції. Може виникнути спокуса спробувати повторно використати DOM-елементи для акторів, але для цього нам знадобиться багато додаткового обліку, щоб пов'язати акторів з DOM-елементами і переконатися, що ми видаляємо елементи, коли їхні актори зникають. Оскільки у грі зазвичай буде лише декілька акторів, перемальовування їх усіх не буде дорогим.

```{includeCode: true}
DOMDisplay.prototype.syncState = function(state) {
  if (this.actorLayer) this.actorLayer.remove();
  this.actorLayer = drawActors(state.actors);
  this.dom.appendChild(this.actorLayer);
  this.dom.className = `game ${state.status}`;
  this.scrollPlayerIntoView(state);
};
```

{{index level, «атрибут класу»}}

Додавши поточний стан рівня як ім'я класу до обгортки, ми можемо дещо по-іншому стилізувати актор гравця, коли гра виграна або програна, додавши правило ((CSS)), яке вступає в силу лише тоді, коли у гравця є ((елемент-предк)) з заданим класом.

```{lang: «css"}}
.lost .player {
  background: rgb(160, 64, 64);
}
.win .player {
  box-shadow: -4px -7px 8px white, 4px -7px 8px white;
}
```

{{index player, «box shadow (CSS)»}}

Після дотику до ((лава)) гравець стає темно-червоним, що вказує на те, що його обпікає. Коли буде зібрано останню монету, ми додамо дві розмиті білі тіні - одну вгорі ліворуч і одну вгорі праворуч, щоб створити ефект білого ореолу.

{{id viewport}}

{{index «position (CSS)», «max-width (CSS)», «overflow (CSS)», «max-height (CSS)», viewport, scrolling, [DOM, graphics]}}

Ми не можемо припустити, що рівень завжди поміщається в _viewport_, елемент, в який ми малюємо гру. Ось чому нам потрібен виклик `scrollPlayerIntoView`: він гарантує, що якщо рівень виступає за межі області перегляду, ми прокрутимо цю область перегляду, щоб переконатися, що гравець знаходиться біля її центру. Наступний код ((CSS)) надає DOM-елементу гри максимальний розмір і гарантує, що все, що стирчить з поля елемента, не буде видимим. Ми також задаємо йому відносну позицію, щоб актори всередині нього розташовувалися відносно верхнього лівого кута рівня.

```{lang: css}
.game {{lang: css}
  overflow: hidden;
  max-width: 600px;
  max-height: 450px;
  position: relative;
}
```

{{індекс прокрутки}}

У методі `scrollPlayerIntoView` ми знаходимо позицію гравця та оновлюємо позицію прокрутки елемента обгортки. Ми змінюємо позицію прокрутки, маніпулюючи властивостями `scrollLeft` та `scrollTop` цього елемента, коли гравець знаходиться надто близько до краю.

```{includeCode: true}
DOMDisplay.prototype.scrollPlayerIntoView = function(state) {
  let width = this.dom.clientWidth
  let height = this.dom.clientHeight
  let margin = width / 3;

  // Екран перегляду
  let left = this.dom.scrollLeft, right = left + width;
  let top = this.dom.scrollTop, bottom = top + height;

  let player = state.player;
  let center = player.pos.plus(player.size.times(0.5))
                         .times(scale);

  if (center.x < left + margin) {
    this.dom.scrollLeft = center.x - margin;
  } else if (center.x > right - margin) { this.dom.scrollLeft = center.x - margin; }
    this.dom.scrollLeft = center.x + margin - width;
  }
  if (center.y < top + margin) {
    this.dom.scrollTop = center.y - margin
  } else if (center.y > bottom - margin) { this.dom.scrollTop = center.y - margin; } if (center.y > bottom - margin)
    this.dom.scrollTop = center.y + margin - height
  }
};
```

{{індекс центру, координати, читабельність}}

Спосіб знаходження центру гравця показує, як методи нашого типу `Vec` дозволяють записувати обчислення з об'єктами у відносно читабельному вигляді. Щоб знайти центр актора, ми додаємо його позицію (верхній лівий кут) і половину його розміру. Це центр у координатах рівня, але нам потрібен центр у координатах пікселів, тому ми помножимо отриманий вектор на наш масштаб відображення.

{Перевірка індексів

Далі виконується низка перевірок, щоб переконатися, що позиція гравця не виходить за межі дозволеного діапазону. Зауважте, що іноді це може призвести до встановлення безглуздих координат прокрутки, які є меншими за нуль або виходять за межі області прокрутки елемента. Це нормально - DOM обмежить їх до прийнятних значень. Встановлення значення `scrollLeft` у `-10` призведе до того, що воно стане рівним `0`.

Хоча було б трохи простіше завжди намагатися прокручувати плеєр до центру ((області перегляду)), це створює досить незручний ефект. Коли ви стрибаєте, вид постійно зміщується вгору і вниз. Приємніше мати «нейтральну» область посередині екрана, де ви можете переміщатися, не спричиняючи скролінгу.

{{індекс [гри, скріншот]}}

Тепер ми можемо відобразити наш крихітний рівень.

```{lang: html}
<link rel=«stylesheet» href=«css/game.css»>

<script>
  let simpleLevel = new Level(simpleLevelPlan);
  let display = new DOMDisplay(document.body, simpleLevel);
  display.syncState(State.start(simpleLevel));
</script> </span> </span> </span> </span> </span
```

{{if book

{{figure {url: «img/game_simpleLevel.png», alt: «Скріншот зображеного рівня», width: “7cm”}}}}

if}}

{{index «link (HTML-тег)», CSS}}

Тег `<link>`, коли він використовується з `rel=«stylesheet»`, є способом завантаження файлу CSS на сторінку. Файл `game.css` містить стилі, необхідні для нашої гри.

## Рух та зіткнення

{{index physics, [animation, «platform game»]}}

Тепер ми підійшли до того моменту, коли можна починати додавати рух. Основний підхід, який використовується у більшості подібних ігор, полягає у тому, щоб розбити ((час)) на невеликі кроки і на кожному кроці переміщати акторів на відстань, що відповідає їх швидкості, помноженій на розмір кроку часу. Ми будемо вимірювати час у секундах, тому швидкості виражаються в одиницях за секунду.

{{індекс перешкоди, «виявлення зіткнень»}}

Переміщати речі легко. Складніше мати справу з взаємодією між елементами. Коли гравець вдаряється об стіну або підлогу, він не повинен просто проходити крізь неї. Гра повинна помічати, коли певний рух призводить до того, що об'єкт вдаряється об інший об'єкт, і реагувати відповідно. Для стін рух повинен бути зупинений. При ударі об монету, цю монету потрібно зібрати. При дотику до лави гра повинна бути програна.

Розв'язання цієї задачі для загального випадку є серйозною проблемою. Ви можете знайти бібліотеки, які зазвичай називаються _((фізичний рушій))s_, що імітують взаємодію між фізичними об'єктами у двох або трьох ((вимірах)). У цій главі ми застосуємо скромніший підхід, розглядаючи лише зіткнення між прямокутними об'єктами і обробляючи їх у досить спрощений спосіб.

{{index bouncing, «виявлення зіткнень», [анімація, «гра на платформі»]}}

Перед переміщенням ((гравця)) або блоку ((лави)) ми перевіряємо, чи не заведе цей рух всередину стіни. Якщо це станеться, ми просто скасовуємо рух. Реакція на таке зіткнення залежить від типу актора - гравець зупиниться, тоді як блок лави відскочить назад.

{Дискретизація індексів

Такий підхід вимагає, щоб наші ((time)) кроки були досить малими, оскільки це призведе до зупинки руху до того, як об'єкти фактично доторкнуться один до одного. Якщо кроки часу (і, відповідно, кроки руху) будуть занадто великими, гравець буде зависати на значній відстані над землею. Інший підхід, можливо, кращий, але складніший, полягає в тому, щоб знайти точне місце зіткнення і переміститися туди. Ми скористаємося простим підходом і приховаємо його недоліки, забезпечивши анімацію невеликими кроками.

{{index obstacle, «touches method», «collision detection»}}

{{id touches}}

Цей метод визначає, чи торкається ((прямокутник)) (заданий позицією та розміром) елемента сітки заданого типу.

```{includeCode: true}
Level.prototype.touches = function(pos, size, type) {
  let xStart = Math.floor(pos.x);
  let xEnd = Math.ceil(pos.x + size.x)
  let yStart = Math.floor(pos.y)
  let yEnd = Math.ceil(pos.y + size.y);

  for (let y = yStart; y < yEnd; y++) {
    for (let x = xStart; x < xEnd; x++) {
      let isOutside = x < 0 || x >= this.width || x >= this.height
                      y < 0 || y >= this.height;
      let here = isOutside ? «wall» : this.rows[y][x];
      if (here == type) return true;
    }
  }
  return false;
};
```

{{index «Math.floor function», «Math.ceil function»}}

Метод обчислює набір квадратів сітки, якими тіло ((перекривається)) перекривається, використовуючи функції `Math.floor` та `Math.ceil` на його ((координатах)). Пам'ятайте, що квадрати ((сітки)) мають розмір 1 на 1 одиницю. Округляючи сторони квадрата вгору і вниз, ми отримуємо діапазон ((фон)) квадратів, яких торкається квадрат.

{{figure {url: «img/game-grid.svg», alt: «Діаграма, що показує сітку з накладеною на неї чорною коробкою. Всі клітинки сітки, які частково покриваються блоком, позначено.», width: “3cm”}}}.

Ми обходимо блок ((сітка)) квадратів, знайдених за ((округлення)) ((координати)), і повертаємо `true`, коли знайдено відповідний квадрат. Клітинки за межами рівня завжди розглядаються як «стіна», щоб гарантувати, що гравець не зможе покинути світ, і що ми випадково не спробуємо прочитати за межами нашого масиву `rows`.

Метод state `update` використовує `touches`, щоб з'ясувати, чи торкається гравець лави.

```{includeCode: true}
State.prototype.update = function(time, keys) {
  let actors = this.actors
    .map(actor => actor.update(time, this, keys));
  let newState = new State(this.level, actors, this.status);

  if (newState.status != «playing») return newState;

  let player = newState.player;
  if (this.level.touches(player.pos, player.size, «lava»)) { {
    return new State(this.level, actors, «lost»);
  }

  for (let actor of actors) {
    if (actor != player && overlap(actor, player)) {
      newState = actor.collide(newState);
    }
  }
  return newState;
};
```

Методу передається часовий крок і структура даних, яка вказує йому, які клавіші утримуються натиснутими. Перше, що він робить, це викликає метод `update` для всіх акторів, створюючи масив оновлених акторів. Актори також отримують часовий крок, ключі та стан, щоб вони могли базувати своє оновлення на цих даних. Тільки гравець буде читати ключі, оскільки це єдиний актор, який керується за допомогою клавіатури.

Якщо гру вже завершено, то ніякої подальшої обробки не потрібно робити (гру не можна виграти після програшу, або навпаки). В іншому випадку метод перевіряє, чи торкається гравець фонової лави. Якщо так, то гру програно, і на цьому все. Нарешті, якщо гра все ще триває, метод перевіряє, чи не перекривають гравця інші актори.

Перекриття між акторами виявляється за допомогою функції `overlap`. Вона приймає два об'єкти-актори і повертає «true», коли вони дотикаються - це відбувається у випадку, коли вони перекриваються як по осі x, так і по осі y.

```{includeCode: true}
function overlap(actor1, actor2) {
  return actor1.pos.x + actor1.size.x > actor2.pos.x &&
         actor1.pos.x < actor2.pos.x + actor2.size.x &&
         actor1.pos.y + actor1.size.y > actor2.pos.y &&
         actor1.pos.y < actor2.pos.y + actor2.size.y
}
```

Якщо якийсь актор перекривається, його метод `collide` отримує можливість оновити стан. Дотик до лавового актора встановлює стан гри у ``загублено``. Монети зникають при дотику до них і встановлюють статус ``виграно``, коли це остання монета на рівні.

```{includeCode: true}
Lava.prototype.collide = function(state) {
  return new State(state.level, state.actors, «lost»);
};

Coin.prototype.collide = function(state) {
  let filtered = state.actors.filter(a => a != this);
  let status = state.status;
  if (!filtered.some(a => a.type == «coin»)) status = «won»;
  return new State(state.level, filtered, status);
};
```

{{id actors}}

## Оновлення акторів

{{index actor, «Клас лави», lava}}

Методи `update` об'єктів акторів приймають як аргументи часовий крок, об'єкт стану та об'єкт `keys`. Метод для типу актора `Lava` ігнорує об'єкт `keys`.

```{includeCode: true}
Lava.prototype.update = function(time, state) {
  нехай newPos = this.pos.plus(this.speed.times(time));
  if (!state.level.touches(newPos, this.size, «стіна»)) {
    return new Lava(newPos, this.speed, this.reset);
  } else if (this.reset) {
    повернути new Lava(this.reset, this.speed, this.reset);
  } else {
    return new Lava(this.pos, this.speed.times(-1));
  }
};
```

{{index bouncing, multiplication, «Vec class», «collision detection»}}

Цей метод `update` обчислює нову позицію, додаючи до старої позиції добуток кроку ((time)) на поточну швидкість. Якщо нова позиція не блокується перешкодою, вона переміщується туди. Якщо перешкода є, поведінка залежить від типу блоку ((лава)): лава, що капає, має позицію «скидання», на яку вона відскакує, коли вдаряється об щось. Лава, що стрибає, інвертує свою швидкість, помноживши її на `-1`, так що вона починає рухатися у зворотному напрямку.

{{index «Coin class», coin, wave}}

Монети використовують свій метод `update` для коливання. Вони ігнорують зіткнення з сіткою, оскільки просто коливаються всередині власного квадрату.

```{includeCode: true}
const wobbleSpeed = 8, wobbleDist = 0.07;

Coin.prototype.update = function(time) {
  let wobble = this.wobble + time * wobbleSpeed;
  let wobblePos = Math.sin(wobble) * wobbleDist;
  return new Coin(this.basePos.plus(new Vec(0, wobblePos)),
                  this.basePos, wobble);
};
```

{{index «Math.sin function», sine, phase}}

Властивість `wobble` інкрементується для відстеження часу, а потім використовується як аргумент функції `Math.sin` для знаходження нової позиції на ((хвилі)). Поточна позиція монети обчислюється з її базової позиції та зміщення на основі цієї хвилі.

{{index «collision detection», «Player class»}}

Залишається сам ((гравець)). Рух гравця обробляється окремо за ((віссю)), оскільки удар об підлогу не повинен перешкоджати горизонтальному руху, а удар об стіну не повинен зупиняти падіння або стрибки.

```{includeCode: true}
const playerXSpeed = 7;
const gravity = 30
const jumpSpeed = 17;

Player.prototype.update = function(time, state, keys) {
  let xSpeed = 0;
  if (keys.ArrowLeft) xSpeed -= playerXSpeed;
  if (keys.ArrowRight) xSpeed += playerXSpeed;
  let pos = this.pos;
  let movedX = pos.plus(new Vec(xSpeed * time, 0));
  if (!state.level.touches(movedX, this.size, «wall»)) {
    pos = movedX;
  }

  let ySpeed = this.speed.y + time * gravity;
  let movedY = pos.plus(new Vec(0, ySpeed * time));
  if (!state.level.touches(movedY, this.size, «wall»)) {
    pos = movedY;
  } else if (keys.ArrowUp && ySpeed > 0) { { pos = movedY; } else if (keys.ArrowUp && ySpeed > 0) {
    ySpeed = -jumpSpeed;
  } else {
    ySpeed = 0;
  }
  return new Player(pos, new Vec(xSpeed, ySpeed));
};
```

{{index [animation, «platform game»], keyboard}}

Горизонтальний рух обчислюється на основі стану клавіш зі стрілками вліво та вправо. Якщо немає стіни, що блокує нову позицію, створену цим рухом, вона використовується. В іншому випадку зберігається стара позиція.

{{прискорення індексу, фізика}}

Вертикальний рух працює аналогічно, але має імітувати ((стрибки)) і ((гравітацію)). Вертикальна швидкість гравця (`ySpeed`) спочатку прискорюється, щоб врахувати ((гравітацію)).

{{індекс «виявлення зіткнень», клавіатура, стрибки}}

Знову перевіряємо наявність стін. Якщо ми не натрапили на жодну, використовується нова позиція. Якщо стіна _є_, то можливі два варіанти розвитку подій. Коли натиснуто стрілку вгору,  і ми рухаємося вниз (тобто предмет, в який ми влучили, знаходиться під нами), швидкість встановлюється на відносно велике від'ємне значення. Це змушує гравця підстрибнути. Якщо цього не сталося, то гравець просто врізався в щось, і швидкість встановлюється на нуль.

Сила гравітації, швидкість ((стрибка)) та інші ((константи)) у грі були визначені шляхом простого експериментування з деякими числами і визначенням того, які з них підходять. Ви можете спробувати поекспериментувати з ними.

## Клавіші відстеження

{{індекс клавіатури}}

Для такої ((гри)), як ця, ми не хочемо, щоб клавіші спрацьовували один раз при натисканні. Навпаки, ми хочемо, щоб їхній ефект (переміщення фігурки гравця) залишався активним доти, доки їх утримують.

{{index «preventDefault method»}}

Нам потрібно створити обробник клавіш, який зберігатиме поточний стан клавіш зі стрілками ліворуч, праворуч та вгору. Ми також захочемо викликати `preventDefault` для цих клавіш, щоб вони не закінчували ((прокручування)) сторінку.

{{index «trackKeys function», «key code», «event handling», «addEventListener method»}}

Наступна функція за масивом назв клавіш поверне об'єкт, який відстежує поточну позицію цих клавіш. Вона реєструє обробники подій ``keydown`` та ``keyup`` і, коли код клавіші у події присутній у наборі кодів, які вона відстежує, оновлює об'єкт.

```{includeCode: true}
function trackKeys(keys) {
  let down = Object.create(null);
  function track(event) {
    if (keys.includes(event.key)) {
      down[event.key] = event.type == «keydown»;
      event.preventDefault();
    }
  }
  window.addEventListener(«keydown», track);
  window.addEventListener(«keyup», track);
  повернути вниз;
}

const arrowKeys =
  trackKeys([«ArrowLeft», «ArrowRight», «ArrowUp»]);
```

{{index «keydown event», «keyup event»}}

Для обох типів подій використовується однакова функція-обробник. Вона перевіряє властивість `type` об'єкта події, щоб визначити, чи слід оновити стан клавіші на true (`«keydown»`) або false (`«keyup»`).

{{id runAnimation}}

## Запуск гри

{{index «requestAnimationFrame function», [animation, «platform game»]}}

Функція `requestAnimationFrame`, яку ми розглядали у [Главі ?](dom#animationFrame), надає хороший спосіб анімувати гру. Але її інтерфейс досить примітивний - використання цієї функції вимагає від нас відстежувати час останнього виклику нашої функції і викликати `requestAnimationFrame` знову після кожного кадру.

{{index «runAnimation function», «callback function», [function, «as value»], [function, «higher-order»], [animation, «platform game»]}}

Визначимо допоміжну функцію, яка обгорне все це у зручний інтерфейс і дозволить нам просто викликати `runAnimation`, передавши їй функцію, яка очікує різницю в часі як аргумент і малює один кадр. Коли функція frame повертає значення `false`, анімація зупиняється.

```{includeCode: true}
function runAnimation(frameFunc) {
  нехай lastTime = null;
  function frame(time) {
    if (lastTime != null) {
      let timeStep = Math.min(time - lastTime, 100) / 1000;
      if (frameFunc(timeStep) === false) return;
    }
    lastTime = time;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}
```

{{індексний час, дискретизація}}

Я встановив максимальний крок кадру в 100 мілісекунд (одна десята секунди). Коли вкладку або вікно браузера з нашою сторінкою буде приховано, виклики `requestAnimationFrame` буде призупинено, доки вкладку або вікно не буде показано знову. У цьому випадку різниця між `lastTime` і `time` буде складати весь час, протягом якого сторінка була прихована. Просування гри на стільки за один крок виглядало б нерозумно і могло б викликати дивні побічні ефекти, такі як падіння гравця крізь підлогу.

Функція також конвертує кроки у секунди, які є більш зручними для сприйняття, ніж мілісекунди.

{{index «функція зворотного виклику», «функція runLevel», [animation, «platform game»]}}

Функція `runLevel` приймає об'єкт `Level` та конструктор ((display)) і повертає обіцянку. Вона відображає рівень (у `document.body`) і дозволяє користувачеві пройти його. Коли рівень завершено (програно або виграно), `runLevel` чекає ще одну секунду (щоб користувач побачив, що сталося), а потім очищає дисплей, зупиняє анімацію і перетворює обіцянку на стан завершення гри.

```{includeCode: true}
function runLevel(level, Display) {
  let display = new Display(document.body, level);
  let state = State.start(level);
  let ending = 1;
  return new Promise(resolve => {
    runAnimation(time => {
      state = state.update(time, arrowKeys);
      display.syncState(state);
      if (state.status == «playing») {
        return true;
      } else if (ending > 0) {
        ending -= time;
        return true;
      } else {
        display.clear();
        resolve(state.status);
        return false;
      }
    });
  });
}
```

{{index «runGame function»}}

Гра - це послідовність ((рівнів)). Щоразу, коли ((гравець)) помирає, поточний рівень перезапускається. Коли рівень завершено, ми переходимо до наступного рівня. Це можна виразити наступною функцією, яка отримує масив планів рівнів (рядків) і конструктор ((display)):

```{includeCode: true}
async function runGame(plans, Display) {
  for (let level = 0; level < plans.length;) {
    let status = await runLevel(new Level(plans[level]),
                                Display);
    if (status == «won») level++;
  }
  console.log(«Ви виграли!»);
}
```

{{index «asynchronous programming», «event handling»}}

Оскільки ми змусили `runLevel` повертати обіцянку, `runGame` можна написати з використанням функції `async`, як показано у [Глава ?](async). Вона повертає іншу обіцянку, яка виконується, коли гравець завершує гру.

{{index game, «GAME_LEVELS dataset»}}

У зв'язці `GAME_LEVELS` у [пісочниці цієї глави](https://eloquentjavascript.net/code#16)[ ([_https://eloquentjavascript.net/code#16_](https://eloquentjavascript.net/code#16))]{if book} є набір планів ((рівень)), доступних у зв'язці `GAME_LEVELS`. Ця сторінка передає їх до `runGame`, запускаючи власне гру.

```{sandbox: null, focus: yes, lang: html, startCode: true}
<link rel=«stylesheet» href=«css/game.css»>

<body>
  <script>
    runGame(GAME_LEVELS, DOMDisplay);
  </script> </script> </span> </span> </span
</body></body>
```

{{if інтерактивний

Подивись, чи зможеш ти побити їх. Мені було весело будувати їх.

if}}

## Вправи

## Гра завершена

{{index «lives (вправа)», game}}

Традиційно для ((платформних ігор)) гравець починає гру з обмеженою кількістю _життєй_ і віднімає по одному життю щоразу, коли помирає. Коли у гравця закінчуються життя, гра починається з початку.

{{index «runGame function»}}

Налаштуйте `runGame` для реалізації життів. Нехай гравець починає з трьох. Виводити поточну кількість життів (за допомогою `console.log`) кожного разу, коли починається рівень.

{{if interactive

```{lang: html, test: no, focus: yes}
<link rel=«stylesheet» href=«css/game.css»>

<body>
<script>
  // Стара функція runGame. Модифікуємо її...
  async function runGame(plans, Display) {
    for (let level = 0; level < plans.length;) {
      let status = await runLevel(new Level(plans[level]),
                                  Display);
      if (status == «won») level++;
    }
    console.log(«Ви виграли!»);
  }
  runGame(GAME_LEVELS, DOMDisplay);
</script> </span> </span> </span> </span
</body></body>
```

if}}

### Ставимо гру на паузу

{{index «pausing (exercise)», «escape key», keyboard, «runLevel function», «event handling»}}

Зробіть так, щоб гру можна було ставити на паузу (призупиняти) та виводити з паузи натисканням [esc]{назва клавіші}. Це можна зробити, змінивши функцію `runLevel` на обробник подій клавіатури, який перериває або відновлює анімацію при натисканні [esc]{ключова назва}.

{{index «runAnimation function»}}

На перший погляд може здатися, що інтерфейс `runAnimation` не підходить для цього, але це не так, якщо змінити спосіб виклику `runLevel`.

{{index [binding, global], «trackKeys function»}}

Коли у вас це запрацює, ви можете спробувати дещо інше. Спосіб, у який ми реєстрували обробники подій клавіатури, є дещо проблематичним. Об'єкт `arrowKeys` наразі є глобальною прив'язкою, і його обробники подій залишаються доступними навіть тоді, коли гру не запущено. Можна сказати, що вони _((витікають))_ з нашої системи. Розширте `trackKeys`, щоб надати можливість скасовувати його обробники, а потім змініть `runLevel`, щоб він реєстрував свої обробники під час запуску гри і скасовував їх після завершення.

{{if інтерактивний

```{lang: html, focus: yes, test: no}
<link rel=«stylesheet» href=«css/game.css»>

<body>
<script>
  // Стара функція runLevel. Змініть її...
  function runLevel(level, Display) {
    let display = new Display(document.body, level);
    let state = State.start(level);
    let ending = 1;
    return new Promise(resolve => {
      runAnimation(time => {
        state = state.update(time, arrowKeys);
        display.syncState(state);
        if (state.status == «playing») {
          return true;
        } else if (ending > 0) {
          ending -= time;
          return true;
        } else {
          display.clear();
          resolve(state.status);
          return false;
        }
      });
    });
  }
  runGame(GAME_LEVELS, DOMDisplay);
</script>
</body></body
```

if}}

{{hint

{{індекс «пауза (вправа)», [анімація, «гра для платформи»]}}

Анімацію можна перервати, повернувши `false` з функції, переданої `runAnimation`. Її можна продовжити повторним викликом `runAnimation`.

{{закриття індексу}}

Отже, нам потрібно повідомити функцію, яка викликається `runAnimation`, про те, що ми ставимо гру на паузу. Для цього можна використати прив'язку, до якої матимуть доступ і обробник подій, і ця функція.

{{index «обробник подій», «removeEventListener метод», [function, «as value»]}}

Шукаючи спосіб скасувати реєстрацію обробників, зареєстрованих за допомогою `trackKeys`, пам'ятайте, що для успішного видалення обробника до `removeEventListener` має бути передано _точне_ значення функції, яке було передано до `addEventListener`. Таким чином, значення функції `handler`, створене у `trackKeys`, має бути доступним для коду, який скасовує реєстрацію обробників.

Ви можете додати властивість до об'єкта, що повертається `trackKeys`, яка міститиме або значення цієї функції, або метод, який безпосередньо обробляє скасування реєстрації.

підказка}}

### Монстр

{{index «monster (exercise)»}}

Традиційним для платформних ігор є наявність ворогів, яких можна перемогти, стрибнувши на них зверху. У цій вправі вам пропонується додати у гру такий тип актора.

Назвемо його монстром. Монстри рухаються лише по горизонталі. Ви можете змусити їх рухатися у напрямку гравця, підстрибувати вперед-назад, як горизонтальна лава, або мати будь-який інший шаблон руху, який ви хочете. Клас не зобов'язаний відповідати за падіння, але він повинен стежити за тим, щоб монстр не проходив крізь стіни.

Коли монстр торкається гравця, ефект залежить від того, стрибає гравець на нього чи ні. Ви можете наближено визначити це, перевіривши, чи знаходиться низ гравця поруч з верхом монстра. Якщо це так, то монстр зникає. Якщо ні, то гра програна.

{{якщо інтерактивно

```{test: no, lang: html, focus: yes}
<link rel=«stylesheet» href=«css/game.css»>
<style>.monster { background: purple }</style>

<body>
  <script>
    // Закінчити конструктор, оновлення та методи зіткнення
    class Monster {
      constructor(pos, /* ... */) {}

      get type() { return «monster»; }

      static create(pos) {
        return new Monster(pos.plus(new Vec(0, -1)));
      }

      update(time, state) {}

      collide(state) {}
    }

    Monster.prototype.size = new Vec(1.2, 2);

    levelChars[«M»] = Monster;

    runLevel(new Level(`
..................................
.################################.
.#..............................#.
.#..............................#.
.#..............................#.
.#...........................o..#.
.#..@...........................#.
.##########..............########.
..........#..o..o..o..o..o..#........
..........#...........M..#........
..........################........
..................................
`), DOMDisplay);
  </script> </script
</body></body
```

if}}

{{hint

{{index «monster (exercise)», «persistent data structure»}}

Якщо ви хочете реалізувати тип руху, який залежить від стану, наприклад, підстрибування, переконайтеся, що ви зберігаєте необхідний стан в об'єкті актора - включіть його як аргумент конструктора і додайте його як властивість.

Пам'ятайте, що `update` повертає _новий_ об'єкт, а не змінює старий.

{{index «collision detection»}}

При обробці зіткнення знайдіть гравця у `state.actors` і порівняйте його позицію з позицією монстра. Щоб отримати _нижню_ позицію гравця, потрібно додати його вертикальний розмір до його вертикальної позиції. Створення оновленого стану буде нагадувати або метод `collide` `Coin` (видалення актора), або `Lava` (зміна статусу на `lost`), залежно від позиції гравця.

підказка}}
