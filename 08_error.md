{{meta {load_files: [«code/chapter/08_error.js»]}}}

# Баги та помилки

{{quote {author: «Brian Kernighan and P.J. Plauger», title: «The Elements of Programming Style», chapter: true}} {{quote {author: “Brian Kernighan and J.J. Pluger”, title: “The Elements of Programming Style”, chapter: true

Налагоджувати вдвічі важче, ніж писати код. Тому, якщо ви пишете код якомога розумніше, ви, за визначенням, недостатньо розумні, щоб його налагодити.

quote}}

{{figure {url: «img/chapter_picture_8.jpg», alt: «Ілюстрація із зображенням різних комах та сороконіжки», image: “Обрамлення” }}}

{{індекс «Kernighan, Brian», «Plauger, P.J.», налагодження, «обробка помилок»}}

Недоліки у комп'ютерних програмах зазвичай називають _((вадами))s_. Програмістам приємно уявляти їх як дрібнички, що випадково потрапляють у нашу роботу. Насправді, звісно, ми самі їх туди вносимо.

Якщо програма - це викристалізована думка, ми можемо грубо класифікувати помилки на ті, що викликані плутаниною в думках, і ті, що викликані помилками, допущеними при перетворенні думки в код. Перший тип помилок, як правило, важче діагностувати та виправити, ніж другий.

## Мова

{Синтаксичний розбір, аналіз

На багато помилок комп'ютер міг би вказати нам автоматично, якби знав достатньо про те, що ми намагаємося зробити. Але тут на заваді стає нечіткість JavaScript. Його концепція прив'язок і властивостей досить розпливчаста, тому він рідко помічає помилки до того, як програма буде запущена. Але навіть тоді вона дозволяє без нарікань робити деякі явно безглузді речі, наприклад, обчислювати `true * «мавпа»`.

{{індекс [синтаксис, помилка], [властивість, доступ]}}

Є речі, на які JavaScript скаржиться. Написання програми, яка не дотримується граматики мови, негайно викличе незадоволення комп'ютера. Інші речі, такі як виклик чогось, що не є функцією, або пошук властивості за значенням ((невизначеним)), призведуть до повідомлення про помилку, коли програма спробує виконати дію.

{{індекс NaN, помилка}}

Однак часто ваші безглузді обчислення просто видають `NaN` (не число) або невизначене значення, а програма щасливо продовжує роботу, переконана, що вона робить щось значуще. Помилка проявиться лише пізніше, після того, як фальшиве значення пройде через кілька функцій. Воно може взагалі не викликати помилку, але непомітно призвести до того, що висновок програми буде хибним. Знайти джерело таких проблем може бути складно.

Процес пошуку помилок-багів у програмах називається _((налагодженням))_.

## Суворий режим

{{index «строгий режим», [синтаксис, помилка], функція}}

{{indexsee «use strict», «strict mode»}}

JavaScript можна зробити _трохи_ суворішим, увімкнувши _суворий режим_. Це можна зробити, додавши рядок `«use strict»` на початку файлу або тіла функції. Ось приклад:

```{test: «error \«ReferenceError: лічильник не визначено\»"}
function canYouSpotTheProblem() {
  «use strict»;
  for (counter = 0; counter < 10; counter++) {
    console.log(«Happy happy»);
  }
}

canYouSpotTheProblem();
// → ReferenceError: counter не визначено
```

{{індекс ECMAScript, сумісність}}

Код всередині класів та модулів (про які ми поговоримо у [Розділ ?](модулі)) автоматично стає строгим. Стара нестрога поведінка все ще існує лише тому, що від неї може залежати деякий старий код, а розробники мови докладають усіх зусиль, щоб не порушити роботу існуючих програм.

{{index «ключове слово let», [binding, global]}}

Зазвичай, коли ви забуваєте поставити `let` перед прив'язкою, як у випадку з `counter` у прикладі, JavaScript спокійно створює глобальну прив'язку і використовує її. У строгому режимі замість цього буде повідомлено про ((помилку)). Це дуже корисно. Однак слід зазначити, що це не працює, коли зв'язування, про яке йде мова, вже існує десь в області видимості. У такому випадку цикл все одно спокійно перезапише значення прив'язки.

{{index «this binding», «global object», undefined, «strict mode»}}

Ще одна зміна у строгому режимі полягає в тому, що прив'язка `this` зберігає значення `undefined` у функціях, які не викликаються як ((метод))s. При такому виклику поза строгим режимом, `this` посилається на об'єкт глобальної області видимості, тобто об'єкт, властивостями якого є глобальні зв'язки. Тому, якщо ви випадково викликаєте метод або конструктор некоректно в строгому режимі, JavaScript видасть помилку, як тільки спробує щось прочитати з `this`, замість того, щоб радісно записати в глобальну область видимості.

Наприклад, розглянемо наступний код, який викликає функцію ((конструктор)) без ключового слова `new`, так що її `this` буде _не_ посилатися на новостворений об'єкт:

```
function Person(name) { this.name = name; }
let ferdinand = Person(«Ferdinand»); // oops
console.log(name);
// → Фердинанд
```

{{індексна помилка}}

Фіктивний виклик `Person` пройшов успішно, але повернув невизначене значення і створив глобальну прив'язку `name`. У строгому режимі результат буде іншим.

```{test: «error \"TypeError: Cannot set properties of undefined (setting 'name')\«»}
«use strict»;
function Person(name) { this.name = name; }
let ferdinand = Person(«Ferdinand»); // забули new
// → TypeError: Неможливо встановити властивість 'name' невизначеної
```

Це одразу говорить нам про те, що щось не так. Це корисно.

На щастя, конструктори, створені у нотації `class`, завжди будуть скаржитися, якщо їх викликати без `new`, що робить це меншою проблемою навіть у нестрогому режимі.

{{параметр індексу, [зв'язування, іменування], «з оператором»}}

Суворий режим робить ще декілька речей. Він забороняє передавати функції декілька параметрів з однаковими іменами і повністю усуває деякі проблемні особливості мови (наприклад, інструкцію `with`, яка є настільки неправильною, що не обговорюється далі у цій книзі).

{Налагодження індексів

Коротше кажучи, розміщення ``використання strict`` на початку вашої програми рідко зашкодить і може допомогти вам виявити проблему.

## Типи

Деякі мови хочуть знати типи всіх ваших прив'язок і виразів ще до запуску програми. Вони одразу скажуть вам, коли тип використовується неузгоджено. JavaScript враховує типи лише під час виконання програми, і навіть там часто намагається неявно перетворити значення до очікуваного типу, тому це не дуже допомагає.

Тим не менш, типи забезпечують корисну основу для розмови про програми. Багато помилок відбувається через плутанину з типом значення, яке надходить у функцію або виходить з неї. Якщо ви запишете цю інформацію, ви з меншою ймовірністю заплутаєтесь.

Ви можете додати такий коментар перед функцією `findRoute` з попередньої глави, щоб описати її тип:

```
// (graph: Об'єкт, from: рядок, to: рядок) => рядок[]
function findRoute(graph, from, to) {
  // ...
}
```

Існує ряд різних угод для коментування JavaScript-програм за допомогою типів.

Одна з особливостей типів полягає в тому, що вони повинні створювати власну складність, щоб мати можливість описати достатньо коду, щоб бути корисними. Як ви думаєте, який тип буде у функції `randomPick`, яка повертає випадковий елемент з масиву? Вам потрібно ввести _((змінну типу))_, _T_, яка може замінити будь-який тип, щоб ви могли надати `randomPick` тип типу `(T[]) → T` (функція від масиву *T*s до *T*).

{{індекс «перевірка типу», TypeScript}}

{{id «типізація»}}

Коли типи програми відомі, комп'ютер може _перевірити_ їх за вас, вказуючи на помилки ще до запуску програми на виконання. Існує декілька діалектів JavaScript, які додають типи до мови та перевіряють їх. Найпопулярніший з них називається [TypeScript] (https://www.typescriptlang.org/). Якщо ви зацікавлені в тому, щоб додати більше строгості до ваших програм, я рекомендую вам спробувати його.

У цій книзі ми продовжимо використовувати сирий, небезпечний, нетипізований JavaScript код.

## Тестування

{{index «test suite», «run-time error», automation, testing}}

Якщо мова не допоможе нам знайти помилки, доведеться шукати їх важким шляхом: запускати програму і дивитися, чи працює вона правильно.

Робити це вручну, знову і знову, дуже погана ідея. Це не тільки дратує, але й, як правило, неефективно, оскільки потрібно занадто багато часу, щоб вичерпно протестувати все щоразу, коли ви вносите зміни.

Комп'ютери добре справляються з повторюваними завданнями, а тестування - ідеальне повторюване завдання. Автоматизоване тестування - це процес написання програми, яка тестує іншу програму. Написання тестів - це трохи більше роботи, ніж тестування вручну, але коли ви це зробите, ви отримаєте своєрідну суперсилу: вам знадобиться лише кілька секунд, щоб перевірити, що ваша програма все ще поводиться належним чином у всіх ситуаціях, для яких ви написали тести. Якщо ви щось зламаєте, ви одразу це помітите, а не випадково натрапите на це пізніше.

{{index «toUpperCase method»}}

Тести зазвичай мають вигляд невеликих позначених програм, які перевіряють певний аспект вашого коду. Наприклад, набір тестів для (стандартного, можливо, вже протестованого кимось) методу `toUpperCase` може мати такий вигляд:

```
function test(label, body) {
  if (!body()) console.log(`Failed: ${label}`);
}

test(«перетворити латинський текст у верхній регістр», () => { })
  return «hello».toUpperCase() == «HELLO»;
});
test(«перетворити грецький текст у верхній регістр», () => {
  return «Χαίρετε».toUpperCase() == «ΧΑΊΡΕΤΕ»;
});
test(«не конвертувати символи без регістру», () => {}); }); test(«не конвертувати символи без регістру», () => {
  return «مرحبا».toUpperCase() == «مرحبا»;
});
```

{{index «мова домену»}}

Написання подібних тестів призводить до появи досить повторюваного, незручного коду. На щастя, існують програми, які допомагають створювати і запускати набори тестів (_((набори тестів))_), надаючи мову (у вигляді функцій і методів), придатну для вираження тестів, і виводячи інформативну інформацію, коли тест завершується невдачею. Зазвичай вони називаються _((тестові бігуни))_.

{{index «persistent data structure»}}

Деякий код легше тестувати, ніж інший. Як правило, чим більше зовнішніх об'єктів взаємодіє з кодом, тим складніше налаштувати контекст для його тестування. Стиль програмування, показаний у [попередній главі](robot), який використовує самодостатні постійні значення, а не об'єкти, що змінюються, як правило, легко тестувати.

## Налагодження

{Налагодження індексів

Якщо ви помітили, що з вашою програмою щось не так, оскільки вона поводиться неправильно або видає помилки, наступним кроком буде з'ясування того, у  чому полягає проблема.

Іноді це очевидно. Повідомлення ((error)) вказує на певний рядок вашої програми, і якщо ви подивитеся на опис помилки і цей рядок коду, ви часто можете побачити проблему.

{{index «помилка часу виконання»}}

Але не завжди. Іноді рядок, який спричинив проблему, є просто першим місцем, де хитке значення, створене в іншому місці, використовується невірним чином. Якщо ви розв'язували ((вправи)) у попередніх розділах, ви, ймовірно, вже стикалися з такими ситуаціями.

{{індекс «десяткове число», «двійкове число»}}

У наступному прикладі програма намагається перетворити ціле число у рядок у заданій системі числення (десятковій, двійковій і т.д.) шляхом багаторазового виділення останньої ((цифри)), а потім ділення числа, щоб позбутися цієї цифри. Але дивний вивід, який вона зараз видає, свідчить про те, що у ній є ((помилка)).

```
function numberToString(n, base = 10) {
  let result = «», sign = «»;
  if (n < 0) {
    sign = «-»;
    n = -n;
  }
  do {
    result = String(n % base) + result;
    n /= base;
  } while (n > 0);
  знак повернення + результат;
}
console.log(numberToString(13, 10));
// → 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3...
```

{{аналіз індексів}}

Навіть якщо ви вже бачите проблему, уявіть на мить, що ви її не бачите. Ми знаємо, що наша програма не працює, і хочемо з'ясувати чому.

{{index «спроби і помилки»}}

Саме тут ви повинні протистояти бажанню почати вносити випадкові зміни до коду, щоб перевірити, чи стане від цього краще. Замість цього, _думайте_. Проаналізуйте те, що відбувається, і придумайте ((теорію)), чому це може відбуватися. Потім проведіть додаткові спостереження, щоб перевірити цю теорію - або, якщо у вас ще немає теорії, проведіть додаткові спостереження, які допоможуть вам її придумати.

{{index «console.log», вивід, налагодження, ведення журналу}}

Додавання у програму кількох стратегічних викликів `console.log` є хорошим способом отримати додаткову інформацію про те, що робить програма. У цьому випадку ми хочемо, щоб `n` приймала значення `13`, `1`, а потім `0`. Виведемо його значення на початку циклу.

```{lang: null}
13
1.3
0.13
0.013
...
1.5e-323
```

{{округлення індексу}}

_Право_. Ділення 13 на 10 не дає цілого числа. Замість `n /= base`, насправді нам потрібно `n = Math.floor(n / base)`, щоб число було належним чином «зсунуто» вправо.

{{індекс «консоль JavaScript», «оператор відладчика»}}

Альтернативою використанню `console.log` для перегляду поведінки програми є використання можливостей _debugger_ вашого браузера. Браузери мають можливість встановлювати _((точку зупинки))_ на певному рядку вашого коду. Коли виконання програми доходить до рядка з точкою зупинки, воно призупиняється, і ви можете переглянути значення прив'язок у цій точці. Я не буду вдаватися в подробиці, оскільки відладчики відрізняються в різних браузерах, але загляньте в інструменти розробника вашого браузера або пошукайте інструкції в Інтернеті.

Інший спосіб встановити точку зупинки - включити до програми інструкцію `debugger` (яка складається лише з цього ключового слова). Якщо у вашому браузері активовано ((інструменти розробника)), програма призупинятиметься щоразу, коли досягне такого оператора.

## Поширення помилок

{{індекс введення, виведення, «помилка часу виконання», помилка, валідація}}

На жаль, не всім проблемам програміст може запобігти. Якщо ваша програма якимось чином взаємодіє із зовнішнім світом, вона може отримати невірні вхідні дані, бути перевантажена роботою або збій у мережі.

{{index «error recovery»}}

Якщо ви програмуєте тільки для себе, ви можете дозволити собі просто ігнорувати такі проблеми, поки вони не виникнуть. Але якщо ви створюєте щось, що буде використовуватися кимось іншим, ви зазвичай хочете, щоб програма працювала краще, ніж просто падала. Іноді правильним рішенням буде прийняти погані вхідні дані і продовжити роботу. В інших випадках краще повідомити користувачеві про те, що пішло не так, а потім припинити роботу. В обох випадках програма повинна активно реагувати на проблему.

{{index «promptNumber function», validation}}

Припустимо, у вас є функція `promptNumber`, яка запитує у користувача число і повертає його. Що вона повинна повернути, якщо користувач введе «помаранчевий»?

{{індекс null, невизначений, «значення, що повертається», «спеціальне значення, що повертається»}}

Один з варіантів - зробити так, щоб програма повертала спеціальне значення. Типовими варіантами таких значень є `null`, `undefined` або `-1`.

```{test: no}
function promptNumber(question) {
  let result = Number(prompt(question));
  if (Number.isNaN(result)) return null;
  else return result;
}

console.log(promptNumber(«Скільки дерев ви бачите?»));
```

Тепер будь-який код, який викликає `promptNumber`, повинен перевірити, чи було прочитано дійсне число, і якщо ні, то якось відновити його - можливо, перепитавши ще раз або заповнивши значення за замовчуванням. Або ж він може знову повернути спеціальне значення користувачеві, який  його викликав, щоб вказати, що він не зміг виконати запиту.

{{index «обробка помилок»}}

У багатьох ситуаціях, здебільшого коли ((помилки)) є поширеними і користувач повинен явно брати їх до уваги, повернення спеціального значення є гарним способом вказати на помилку. Однак він має свої недоліки. По-перше, що якщо функція вже може повертати всі можливі типи значень? У такій функції вам доведеться зробити щось на кшталт обгортання результату в об'єкт, щоб мати змогу відрізнити успіх від невдачі, як це робить метод `next` в інтерфейсі ітератора.

```
function lastElement(array) {
  if (array.length == 0) {
    return {failed: true};
  } else {
    return {value: array[array.length - 1]};
  }
}
```

{{індекс «спеціальне значення, що повертається», читабельність}}

Друга проблема з поверненням спеціальних значень полягає у тому, що це може призвести до появи незручного коду. Якщо фрагмент коду викликає `promptNumber` 10 разів, він повинен 10 разів перевірити, чи не було повернуто `null`. Якщо у відповідь на знаходження `null` він просто поверне сам `null`, викликувачі функції, у свою чергу, будуть змушені перевіряти його, і так далі.

## Винятки

{{index «обробка помилок»}}

Коли функція не може працювати належним чином, ми часто _хочемо_ просто зупинити її роботу і негайно перейти до місця, яке знає, як вирішити проблему. Це те, що робить _((обробка винятків))_.

{{index [«потік керування», винятки], «здіймання (виняток)», «ключове слово throw», «стек викликів»}}

Винятки - це механізм, який дозволяє коду, що зіткнувся з проблемою, _згенерувати_ (або _викинути_) виняток. Виключенням може бути будь-яке значення. Здіймання винятку дещо нагадує повернення з функції: воно вискакує не лише з поточної функції, але й з усіх її викликів, аж до першого виклику, з якого почалося поточне виконання. Це називається _((розмотування стеку))_. Ви можете пам'ятати стек викликів функцій, згаданий у [Глава ?](functions#stack). Виняток зменшує масштаб цього стеку, відкидаючи всі контексти викликів, з якими він стикається.

{{індекс «обробка помилок», [синтаксис, оператор], «ключове слово catch»}}

Якби винятки завжди зменшувалися до самого низу стеку, від них не було б великої користі. Вони б просто надавали новий спосіб розвалити вашу програму. Їх сила полягає у тому, що ви можете встановити «перешкоди» вздовж стеку, щоб « перехопити» виняток, коли він зменшується. Після того, як ви перехопили виняток, ви можете зробити з ним щось, щоб вирішити проблему, а потім продовжити виконання програми.

Ось приклад:

{{id look}}
```
function promptDirection(question) {
  let result = prompt(question);
  if (result.toLowerCase() == «left») return «L»;
  if (result.toLowerCase() == «right») return «R»;
  згенерувати нове виведення Error("Неправильний напрямок: » + result);
}

функція look() {
  if (promptDirection(«В який бік?») == «Л») {
    return «a house»;
  } else {
    return «два злих ведмеді»;
  }
}

try {
  console.log(«Ви бачите», look());
} catch (error) {
  console.log("Щось пішло не так: » + error);
}
```

{{index «обробка виключень», block, «ключове слово throw», «ключове слово try», «ключове слово catch»}}

Ключове слово `throw` використовується для згенерування виключення. Перехоплення виключення здійснюється шляхом обгортання фрагменту коду у блок `try`, за яким слідує ключове слово `catch`. Коли код у блоці `try` викликає виключення, виконується блок `catch`, а ім'я у круглих дужках прив'язується до значення виключення. Після завершення блоку `catch` - або якщо блок `try` завершується без проблем - програма продовжує роботу за інструкцією `try/catch`.

{{індекс налагодження, «стек викликів», «Тип помилки»}}

У цьому випадку ми використали `Error` ((конструктор)) для створення нашого значення виключення. Це ((стандартний)) конструктор JavaScript, який створює об'єкт з властивістю `message`. Екземпляри `Error` також збирають інформацію про стек викликів, який існував на момент створення виключення, так звану _((трасування стеку))_. Ця інформація зберігається у властивості `stack` і може бути корисною при спробі налагодження проблеми: вона вказує на функцію, в якій виникла проблема, і на те, які функції здійснили невдалий виклик.

{{index «обробка виключень»}}

Зверніть увагу, що функція `look` повністю ігнорує можливість того, що `promptDirection` може спрацювати неправильно. У цьому полягає велика перевага виключень: код обробки помилок потрібен лише в місці виникнення помилки і в місці її обробки. Функції між ними можуть про це забути.

Ну, майже...

## Очищення після винятків

{{index «обробка виключень», «очищення», [«потік управління», exceptions]}}

Наслідки винятків - це ще один різновид потоку керування. Кожна дія, яка може спричинити виключення, а це майже кожен виклик функції та доступ до властивостей, може призвести до раптової втрати управління вашим кодом.

Це означає, що коли код має декілька побічних ефектів, навіть якщо його «звичайний» потік керування виглядає так, ніби всі вони відбудуться завжди, виняток може запобігти деяким з них.

{{index «банківський приклад»}}

Ось дуже поганий банківський код:

```{includeCode: true}
const accounts = {
  a: 100,
  b: 0,
  c: 20
};

function getAccount() {
  let accountName = prompt(«Введіть назву облікового запису»);
  if (!Object.hasOwn(accounts, accountName)) {
    throw new Error(`Не існує такого облікового запису: ${accountName}`);
  }
  return accountName;
}

function transfer(from, amount) {
  if (accounts[from] < amount) return;
  accounts[from] -= amount;
  accounts[getAccount()] += amount;
}
```

Функція `transfer` переказує суму грошей з одного рахунку на інший, запитуючи при цьому назву іншого рахунку. Якщо задано невірну назву рахунку, `getAccount` згенерує виключення.

Але `transfer`  спочатку видаляє гроші з рахунку, а  потім викликає `getAccount` перед тим, як додати їх на інший рахунок. Якщо в цей момент він буде перерваний винятком, то гроші просто зникнуть.

Цей код можна було б написати трохи розумніше, наприклад, викликати `getAccount` до того, як він почне переміщувати гроші. Але часто подібні проблеми виникають більш приховано. Навіть функції, які не виглядають як такі, що можуть згенерувати виключення, можуть зробити це у виняткових обставинах або коли вони містять помилку програміста.

Одним із способів вирішення цієї проблеми є використання меншої кількості побічних ефектів. Знову ж таки, допомагає стиль програмування, який обчислює нові значення замість того, щоб змінювати існуючі дані. Якщо фрагмент коду зупиняється посеред створення нового значення, жодні існуючі структури даних не пошкоджуються, що полегшує їх відновлення.

{{index block, «try keyword», «finally keyword»}}

Оскільки це не завжди практично, інструкції `try` мають ще одну особливість: вони можуть супроводжуватися блоком `finally` або замість блоку `catch`, або на додаток до нього. Блок `finally` говорить «незалежно від того, _що_ станеться, виконайте цей код після спроби виконати код у блоці `try`».

```{includeCode: true}
function transfer(from, amount) {
  if (accounts[from] < amount) return;
  нехай progress = 0;
  try {
    accounts[from] -= amount;
    progress = 1;
    accounts[getAccount()] += amount;
    progress = 2;
  } finally {
    if (progress == 1) {
      accounts[from] += amount;
    }
  }
}
```

Ця версія функції відстежує свій прогрес, і якщо при виході помічає, що її було перервано в точці, де вона створила неузгоджений стан програми, вона виправляє завдану нею шкоду.

Зверніть увагу, що хоча код `finally` виконується, коли у блоці `try` згенеровано виключення, він не впливає на виключення. Після виконання блоку `finally` стек продовжує розмотування.

{{index «exception safety»}}

Писати програми, які працюють надійно навіть тоді, коли виключення виникають у несподіваних місцях, досить складно. Багато людей просто не переймаються цим питанням, а оскільки винятки зазвичай зарезервовано для виняткових обставин, проблема може виникати настільки рідко, що її навіть не помічають. Чи це добре, чи дуже погано, залежить від того, скільки шкоди завдасть програма, коли вийде з ладу.

## Вибіркове перехоплення

{{index «uncaught exception», «exception handling», «JavaScript console», «developer tools», «call stack», error}}

Коли виняток доходить до самого низу стеку, не будучи перехопленим, він обробляється оточенням. Що це означає, залежить від середовища. У браузерах опис помилки зазвичай записується в консоль JavaScript (доступну через меню «Інструменти» або «Розробник» браузера). Node.js, безбраузерне середовище JavaScript, про яке ми поговоримо в [Розділ ?](node), більш обережно ставиться до пошкодження даних. Воно перериває весь процес, коли виникає необроблене виключення.

{{index crash, «обробка помилок»}}

Для програмних помилок часто найкраще, що ви можете зробити, це просто пропустити помилку. Необроблене виключення - це розумний спосіб сигналізувати про несправність програми, а консоль JavaScript у сучасних браузерах надасть вам деяку інформацію про те, які виклики функцій були у стеку, коли виникла проблема.

{{index «user interface»}}

Для проблем, які _очікувано_ трапляються під час рутинного використання, аварійне завершення з необробленим винятком є жахливою стратегією.

{{index [функція, програма], «обробка винятків», «Тип помилки», [прив'язка, невизначений]}}

Неправильне використання мови, наприклад, посилання на неіснуюче зв'язування, пошук властивості за значенням `null` або виклик чогось, що не є функцією, також призведе до генерування винятків. Такі винятки також можна перехоплювати.

{{index «catch keyword»}}

Коли вводиться тіло `catch`, все, що ми знаємо, це те, що _щось_ у нашому тілі `try` викликало виключення. Але ми не знаємо, _що_ зробило або _який_ виняток воно викликало.

{{index «обробка винятків»}}

JavaScript (що є досить кричущим упущенням) не надає прямої підтримки для вибіркового перехоплення винятків: або ви перехоплюєте всі винятки, або не перехоплюєте жодного. Це робить спокусливим _припустити_, що ви отримаєте саме той виняток, про який ви думали, коли писали блок `catch`.

{{index «promptDirection function»}}

Але це може бути не так. Може бути порушено якесь інше ((припущення)), або ви могли внести помилку, яка викликає виняток. Ось приклад, який _намагається_ продовжувати викликати `promptDirection` доти, доки не отримає коректної відповіді:

```{test: no}
for (;;) {
  try {
    let dir = promtDirection(«Where?»); // ← помилка!
    console.log("Ви вибрали », dir);
    break;
  } catch (e) {
    console.log(«Неправильний напрямок. Спробуйте ще раз.»)
  }
}
```

{{індекс «нескінченний цикл», «цикл for», «ключове слово catch», налагодження}}

Конструкція `for (;;)` - це спосіб навмисного створення циклу, який не завершується самостійно. Ми виходимо з циклу тільки тоді, коли дається правильний напрямок. На жаль, ми неправильно написали `promptDirection`, що призведе до помилки «невизначена змінна». Оскільки блок `catch` повністю ігнорує значення виключення (`e`), припускаючи, що він знає, в чому проблема, він помилково трактує помилку зв'язування як таку, що вказує на неправильне введення. Це не тільки призводить до нескінченного циклу, але й «ховає» корисне повідомлення про помилку зв'язування.

Як правило, не перехоплюйте всі винятки, якщо тільки це не має на меті їх «перенаправлення» кудись - наприклад, через мережу, щоб повідомити іншій системі про те, що наша програма впала. І навіть у цьому випадку добре подумайте про те, як ви можете приховати інформацію.

{{index «обробка винятків»}}

Ми хочемо перехопити _конкретний_ тип винятку. Ми можемо зробити це, перевіривши у блоці `catch`, чи виняток, який ми отримали, є саме тим, що нас цікавить, і якщо ні, то перегенерувати його. Але як розпізнати виключення?

Ми могли б порівняти його властивість `message` з повідомленням ((error)), яке ми випадково очікуємо. Але це хиткий спосіб написання коду - ми б використовували інформацію, призначену для споживання людиною (повідомлення), для прийняття програмного рішення. Як тільки хтось змінить (або перекладе) повідомлення, код перестане працювати.

{{index «Тип помилки», «екземпляр оператора», «функція promptDirection»}}

Натомість, давайте визначимо новий тип помилки і використовуватимемо `instanceof` для її ідентифікації.

```{includeCode: true}
class InputError extends Error {}

function promptDirection(question) {
  let result = prompt(question);
  if (result.toLowerCase() == «left») return «L»;
  if (result.toLowerCase() == «right») return «R»;
  згенерувати нове InputError("Неправильний напрямок: » + result);
}
```

{{індекс «ключове слово throw», успадкування}}

Новий клас помилок розширює клас `Error`. Він не має власного конструктора, а це означає, що він успадковує конструктор `Error`, який очікує в якості аргументу рядкове повідомлення. Фактично, він взагалі нічого не визначає - клас порожній. Об'єкти `InputError` поводяться подібно до об'єктів `Error`, за винятком того, що вони мають інший клас, за яким ми можемо їх розпізнати.

{{index «обробка виключень»}}

Тепер цикл може перехоплювати їх більш обережно.

```{test: no}
for (;;) {
  try {
    let dir = promptDirection(«Де?»);
    console.log("Ви вибрали », dir);
    break;
  } catch (e) {
    if (e instanceof InputError) {
      console.log(«Неправильний напрямок. Спробуйте ще раз.»)
    } else {
      throw e;
    }
  }
}
```

{{налагодження індексів}}

Це перехоплює лише екземпляри `InputError` і пропускає винятки, не пов'язані з ним. Якщо ви повторно введете помилку, буде належним чином повідомлено про помилку невизначеного зв'язування.

## Твердження

{{index «assert function», assertion, debugging}}

Твердження - це перевірки всередині програми, які перевіряють, що щось відбувається саме так, як передбачається. Вони використовуються не для обробки ситуацій, які можуть виникнути під час нормальної роботи, а для пошуку помилок програмістів.

Якщо, наприклад, `firstElement` описано як функцію, яку ніколи не слід викликати на порожніх масивах, ми можемо написати її так

```
function firstElement(array) {
  if (array.length == 0) {
    згенерувати нове виключення Error(«firstElement викликано з []»);
  }
  return array[0];
}
```

{{перевірка індексів, «помилка часу виконання», збій, припущення}}

Тепер, замість того, щоб мовчки повернути undefined (що ви отримуєте при читанні неіснуючої властивості масиву), це голосно підірве вашу програму, як тільки ви неправильно її використаєте. Це зменшує ймовірність того, що такі помилки залишаться непоміченими, і полегшує пошук їх причини, коли вони трапляються.

Я не рекомендую намагатися писати твердження для кожного можливого типу поганих вхідних даних. Це займе багато часу і призведе до дуже шумного коду. Краще зарезервуйте їх для помилок, які легко зробити (або які ви самі можете зробити).

## Підсумок

Важливою частиною програмування є пошук, діагностика та виправлення помилок. Проблеми буде легше помітити, якщо у вас є автоматизований набір тестів або якщо ви додасте твердження до ваших програм.

Проблеми, спричинені факторами, що не залежать від програми, зазвичай слід активно планувати. Іноді, коли проблему можна вирішити локально, спеціальне значення, що повертається, є гарним способом відстежити їх. В інших випадках краще використовувати винятки.

Згенероване виключення призводить до розгортання стеку викликів до наступного блоку `try/catch` або до кінця стеку. Значення винятку буде передано блоку `catch`, який його перехоплює, що має перевірити, чи це дійсно очікуваний тип винятку, а потім щось з ним зробити. Щоб допомогти вирішити проблему непередбачуваного потоку керування, спричиненого винятками, можна використовувати блоки `finally`, які гарантують, що фрагмент коду _завжди_ виконується після завершення блоку.

## Вправи

### Повторна спроба

{{index «primitiveMultiply (вправа)», «обробка виключень», «ключове слово throw»}}

Нехай у вас є функція `primitiveMultiply`, яка у 20 відсотках випадків перемножує два числа, а в інших 80 відсотках випадків генерує виключення типу `MultiplicatorUnitFailure`. Напишіть функцію, яка обгортає цю незграбну функцію і просто продовжує спроби до тих пір, поки виклик не буде успішним, після чого повертає результат.

{{index «catch keyword»}}

Переконайтеся, що ви обробляєте тільки ті винятки, які намагаєтеся обробити.

{{if інтерактивний

```{test: no}}
class MultiplicatorUnitFailure extends Error {}

function primitiveMultiply(a, b) {
  if (Math.random() < 0.2) {
    повернути a * b;
  } else {
    throw new MultiplicatorUnitFailure(«Klunk»);
  }
}

function reliableMultiply(a, b) {
  // Ваш код тут.
}

console.log(reliableMultiply(8, 8));
// → 64
```
if}}

{{hint

{{index «primitiveMultiply (exercise)», «try keyword», «catch keyword», «throw keyword»}}

Виклик `primitiveMultiply` обов'язково має відбуватися у блоці `try`. Відповідний блок `catch` повинен перегенерувати виключення, якщо воно не є екземпляром `MultiplicatorUnitFailure`, і забезпечити повторну спробу виклику, якщо є.

Для виконання повторної спроби ви можете використати цикл, який зупиняється лише тоді, коли виклик є успішним - як у прикладі [`look`](error#look) раніше у цій главі - або використати ((рекурсію)) і сподіватися, що ви не отримаєте настільки довгий рядок невдач, що він переповнить стек (що є доволі безпечним варіантом).

підказка}}

### Замкнена скринька

{{index «замкнений ящик (вправа)»}}

Розглянемо наступний (досить надуманий) об'єкт:

```
const box = new class {
  locked = true
  #content = [];

  unlock() { this.locked = false; }
  lock() { this.locked = true; }
  get content() {
    if (this.locked) throw new Error(«Заблоковано!»);
    return this.#content;
  }
};
```

{{index «private property», «access control»}}

Це ((box)) з замком. У ящику знаходиться масив, але ви можете отримати доступ до нього лише тоді, коли ящик розблоковано.

{{index «ключове слово finally», «обробка виключень»}}

Напишіть функцію з назвою `withBoxUnlocked`, яка отримує значення функції як аргумент, розблоковує скриньку, виконує функцію, а потім гарантує, що скриньку буде знову заблоковано перед поверненням, незалежно від того, чи повернула функція аргумент нормально, чи згенерувала виключення.

{{якщо інтерактивний

```
const box = new class {
  locked = true;
  #content = [];

  unlock() { this.locked = false; }
  lock() { this.locked = true; }
  get content() {
    if (this.locked) throw new Error(«Заблоковано!»);
    return this.#content;
  }
};

function withBoxUnlocked(body) {
  // Ваш код тут.
}

withBoxUnlocked(() => { // Ваш код тут.
  box.content.push(«gold piece»);
});

try {
  withBoxUnlocked(() => {
    throw new Error(«Пірати на горизонті! Відбій!»);
  });
} catch (e) {
  console.log("Виникла помилка: » + e);
}
console.log(box.locked);
// → true
```

if}}

Для отримання додаткових балів переконайтеся, що якщо ви викликаєте `withBoxUnlocked`, коли коробку вже розблоковано, то вона залишається розблокованою.

{{hint

{{index «замкнена коробка (вправа)», «finally ключове слово», «try ключове слово»}}

У цій вправі використовується блок `finally`. Ваша функція повинна спочатку розблокувати скриньку, а потім викликати функцію-аргумент з тіла `try`. Блок `finally`, який слідує за ним, повинен знову заблокувати скриньку.

Щоб переконатися, що ми не заблокуємо скриньку, коли вона ще не була заблокована, перевірте її блокування на початку функції і розблокуйте та заблокуйте її тільки тоді, коли вона була заблокована.

підказка}}
