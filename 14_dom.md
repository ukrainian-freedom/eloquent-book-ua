# Об'єктна модель документа

{{quote {author: «Фрідріх Ніцше», author, title: «По той бік добра і зла», author: “Фрідріх Ніцше”, title: “По той бік добра і зла”, chapter: true}}

Дуже погано! Все та ж стара історія! Закінчивши будувати будинок, ви помічаєте, що випадково дізналися щось таке, що мали б знати ще до того, як почали будувати.

quote}}
{{figure {url: «img/chapter_picture_14.jpg», alt: «Ілюстрація із зображенням дерева, на гілках якого висять літери, малюнки та шестерні», »chapter: «Обрамлення"}}}

{{індексне малювання, розбір}}

Коли ви відкриваєте веб-сторінку, ваш браузер отримує її текст ((HTML)) і розбирає його, подібно до нашого синтаксичного аналізатора з [Розділ ?](мова#синтаксичний аналіз). Браузер створює модель ((структури)) документа і використовує цю модель для відображення сторінки на екрані.

{{index «жива структура даних»}}

Таке представлення ((документа)) є однією з іграшок, які програма на JavaScript має у своїй ((пісочниці)). Це структура даних, яку ви можете читати або змінювати. Вона діє як « жива » структура даних: коли її змінюють, сторінка на екрані оновлюється, щоб відобразити зміни.

## Структура документа

{{index [HTML, структура]}}

Ви можете уявити HTML-документ як вкладений набір ((box))ів. Такі теги, як `<body>` і `</body>`, містять інші ((tag))и, які, у свою чергу, містять інші теги або ((text)). Ось приклад документа з [попередньої глави] (браузер):

```{lang: html, sandbox: «homepage»}
<!doctype html>
<html>
  <head>
    <title>Моя домашня сторінка</title>
  </head> </head>
  <body>
    <h1>Моя домашня сторінка</h1>
    <p>Привіт, мене звуть Марін, і це моя домашня сторінка.
    <А ще я написала книгу! Прочитайте її
      <a href=«http://eloquentjavascript.net»>тут</a>.</p>
  </p> <p>
</html>
```

Ця сторінка має наступну структуру:

{{figure {url: «img/html-boxes.svg», alt: «Діаграма, що показує HTML-документ у вигляді набору вкладених блоків. Зовнішній блок позначено як «html» і містить два блоки, позначені як «head» і «body». Всередині них знаходяться інші блоки, деякі з яких містять текст документа.», width: “7cm”}}}.

{{Дивіться «Об'єктна модель документа», DOM}}

Структура даних, яку браузер використовує для представлення документа, має такий вигляд. Для кожного поля існує об'єкт, з яким ми можемо взаємодіяти, щоб з'ясувати, який HTML-тег він представляє, які поля і текст у ньому містяться. Таке представлення називається _об'єктною моделлю документа_, або скорочено _((DOM))_.

{{index «property documentElement», «head property», «body property», «html (HTML-тег)», «body (HTML-тег)», «head (HTML-тег)»}}

Глобальна прив'язка `document` дає нам доступ до цих об'єктів. Його властивість `documentElement` посилається на об'єкт, що представляє тег `<html>`. Оскільки кожен HTML-документ має заголовок і тіло, він також має властивості `head` і `body`, що вказують на ці елементи.

## Дерева

{{index [вкладеність, «об'єктів»]}}

Пригадайте на мить ((дерево синтаксису))и з [Розділу ?](синтаксичний#аналіз мови). Їхні структури напрочуд схожі на структуру документа у браузері. Кожен _((вузол))_ може посилатися на інші вузли, _дочірні_, які, у свою чергу, можуть мати власних дітей. Така форма характерна для вкладених структур, де елементи можуть містити подібні до себе піделементи.

{{index «property documentElement», [DOM, tree]}}

Ми називаємо структуру даних _((деревом))_, коли вона має розгалужену структуру, не має ((циклу))_ (вузол не може містити сам себе, прямо чи опосередковано) та єдиний, чітко визначений _((корінь))_. У випадку DOM, `document.documentElement` слугує коренем.

{{індексне сортування, [«структура даних», «дерево»], «синтаксичне дерево»}}

Дерева часто зустрічаються у комп'ютерних науках. Окрім представлення рекурсивних структур, таких як HTML-документи або програми, вони часто використовуються для зберігання відсортованих ((множин)) даних, оскільки елементи зазвичай можна знайти або вставити ефективніше у дереві, ніж у пласкому масиві.

{{index «leaf node», «Egg language»}}

Типове дерево має різні типи ((node))s. Дерево синтаксису для [яєчної мови](мова) має ідентифікатори, значення та вузли застосування. Вузли застосування можуть мати дочірні вузли, тоді як ідентифікатори та значення є _листям_, або вузлами без дочірніх вузлів.

{{index «body property», [HTML, структура]}}

Те ж саме стосується і DOM. Вузли для _((element))s_, які представляють теги HTML, визначають структуру документа. Вони можуть мати ((дочірній вузол))s. Прикладом такого вузла є `document.body`. Деякі з цих дочірніх вузлів можуть бути ((листовий вузол)), наприклад, частини вузлів ((текст)) або ((коментар)).

{{index «text node», element, «ELEMENT_NODE code», «COMMENT_NODE code», «TEXT_NODE code», «nodeType property»}}

Кожен об'єкт DOM-вузла має властивість `nodeType`, яка містить код (число), що ідентифікує тип вузла. Елементи мають код 1, який також визначається як константна властивість `Node.ELEMENT_NODE`. Текстові вузли, що представляють фрагмент тексту в документі, отримують код 3 (`Node.TEXT_NODE`). Коментарі мають код 8 (`Node.COMMENT_NODE`).

Інший спосіб візуалізації нашого документа ((дерево)) наступний:

{{figure {url: «img/html-tree.svg», alt: «Діаграма, що показує HTML-документ у вигляді дерева, зі стрілками від батьківських вузлів до дочірніх», width: “8cm”}}}.

Листя - це текстові вузли, а стрілки вказують на зв'язки між вузлами типу «батьки-нащадки».

{{id standard}}

## Стандарт

{{index «мова програмування», [інтерфейс, дизайн], [DOM, інтерфейс]}}

Використання криптографічних числових кодів для представлення типів вузлів не дуже схоже на JavaScript. Пізніше у цій главі ми побачимо, що інші частини інтерфейсу DOM також здаються громіздкими і чужорідними. Це тому, що інтерфейс DOM був розроблений не лише для JavaScript. Скоріше, він намагається бути мовно-нейтральним інтерфейсом, який можна використовувати і в інших системах, не тільки для HTML, але і для ((XML)), який є загальним ((форматом даних)) з синтаксисом, схожим на HTML.

{{послідовність індексів, інтеграція}}

Це прикро. Стандарти часто бувають корисними. Але у цьому випадку перевага (міжмовна узгодженість) не є настільки переконливою. Наявність інтерфейсу, належним чином інтегрованого з мовою, якою ви користуєтеся, заощадить вам більше часу, ніж наявність знайомого інтерфейсу різними мовами.

{{index «array-like object», «NodeList type»}}

Як приклад поганої інтеграції, розглянемо властивість `childNodes`, яку мають вузли елементів у DOM. Ця властивість містить масивний об'єкт з властивістю `length` та властивостями, позначеними числами, для доступу до дочірніх вузлів. Але це екземпляр типу `NodeList`, а не справжній масив, тому він не має таких методів, як `slice` і `map`.

{{index [інтерфейс, дизайн], [DOM, конструкція], «побічний ефект»}}

Є проблеми, які просто викликані поганим дизайном. Наприклад, немає можливості створити новий вузол і одразу додати до нього дочірні вузли або ((атрибут))и. Натомість, ви повинні спочатку створити його, а потім додати дочірні елементи та атрибути один за одним, використовуючи побічні ефекти. Код, який інтенсивно взаємодіє з DOM, має тенденцію ставати довгим, повторюваним і потворним.

{{бібліотека індексів}}

Але ці недоліки не є фатальними. Оскільки JavaScript дозволяє створювати власні ((абстракції)), можна розробляти кращі способи вираження операцій, які ми виконуємо. Багато бібліотек, призначених для програмування у браузері, містять такі інструменти.

## Переміщення по дереву

{{покажчик індексу}}

Вузли DOM містять безліч посилань ((link)) на інші сусідні вузли. Наступна діаграма ілюструє це:

{{figure {url: «img/html-links.svg», alt: «Діаграма, яка показує зв'язки між вузлами DOM. Вузол «body» показано у вигляді рамки зі стрілкою «firstChild», що вказує на вузол «h1» на його початку, стрілка «lastChild» - на вузол останнього абзацу, а стрілка «childNodes» - на масив посилань на всі його дочірні вузли. Середній абзац має стрілку «previousSibling», що вказує на вузол перед ним, стрілку «nextSibling» на вузол після нього і стрілку «parentNode», що вказує на вузол «body».», width: “6cm”}}}.

{{index «child node», «parentNode property», «childNodes property»}}

Хоча на діаграмі показано лише один зв'язок кожного типу, кожен вузол має властивість `parentNode`, яка вказує на вузол, частиною якого він є, якщо такий є. Аналогічно, кожен вузол-елемент (вузол типу 1) має властивість `childNodes`, яка вказує на об'єкт ((масивний об'єкт)), що містить його дочірні вузли.

{{index «firstChild property», «lastChild property», «previousSibling property», «nextSibling property»}}

Теоретично, ви можете переміщатися будь-куди в дереві, використовуючи лише ці батьківські та дочірні посилання. Але JavaScript також надає вам доступ до низки додаткових зручних посилань. Властивості `firstChild` і `lastChild` вказують на перший і останній дочірні елементи або мають значення `null` для вузлів без дочірніх елементів. Аналогічно, властивості `previousSibling` та `nextSibling` вказують на сусідні вузли, тобто вузли з тим самим батьком, які з'являються безпосередньо перед або після самого вузла. Для першого нащадка `previousSibling` буде нульовим, а для останнього нащадка `nextSibling` буде нульовим.

{{index «children property», «text node», element}}

Існує також властивість `children`, яка подібна до `childNodes`, але містить лише дочірні елементи (тип 1), а не інші типи дочірніх вузлів. Це може бути корисно, якщо вас не цікавлять текстові вузли.

{{index «talksAbout function», recursion, [nesting, «of objects»]}}

При роботі з такою вкладеною структурою даних, як ця, часто корисними є рекурсивні функції. Наступна функція сканує документ на наявність ((текстовий вузол))ів, що містять заданий рядок, і повертає `true`, якщо вона його знайшла:

{{id talksAbout}}

```{sandbox: «homepage»}
function talksAbout(node, string) {
  if (node.nodeType == Node.ELEMENT_NODE) {
    for (let child of node.childNodes) {
      if (talksAbout(child, string)) {
        return true;
      }
    }
    return false;
  } else if (node.nodeType == Node.TEXT_NODE) { { } return false; } else if (node.nodeType == Node.TEXT_NODE) {
    return node.nodeValue.indexOf(string) > -1;
  }
}

console.log(talksAbout(document.body, «book»));
// → true
```

{{index «властивість nodeValue»}}

Властивість `nodeValue` текстового вузла містить рядок тексту, який він представляє.

## Пошук елементів

{{індекс [DOM, запит], «властивість тіла», «жорстке кодування», [пробіли, «у HTML»]}}

Навігація за цими ((посиланнями)) між батьками, дітьми та братами і сестрами часто буває корисною. Але якщо ми хочемо знайти певний вузол у документі, починати пошук з `document.body` і йти по фіксованому шляху властивостей - погана ідея. Це створює у нашій програмі припущення про точну структуру документа - структуру, яку ви, можливо, захочете змінити пізніше. Іншим ускладнюючим фактором є те, що текстові вузли створюються навіть для пробілів між вузлами. Тег `<body>` у прикладі документа має не три дочірні елементи (`<h1>` і два елементи `<p>`), а сім: ці три елементи, а також пробіли перед, після і між ними.

{{index «search problem», «href attribute», «getElementsByTagName method»}}

Якщо ми хочемо отримати атрибут `href` посилання в цьому документі, ми не хочемо говорити щось на кшталт «Отримати другий дочірній елемент шостого дочірнього елемента тіла документа». Було б краще, якби ми могли сказати «Отримати перше посилання у документі». І ми можемо це зробити.

```{sandbox: «домашня сторінка»}
let link = document.body.getElementsByTagName(«a»)[0];
console.log(link.href);
```

{{index «child node»}}

Усі вузли елементів мають метод `getElementsByTagName`, який збирає всі елементи з заданою назвою тегу, що є нащадками (прямими або непрямими нащадками) цього вузла, і повертає їх у вигляді об'єкта типу масив).

{{index «атрибут id», «метод getElementById»}}

Щоб знайти конкретний _окремий_ вузол, ви можете надати йому атрибут `id` і замість цього використовувати `document.getElementById`.

```{lang: html}
<p>Мій страус Гертруда:</p>
<p><img id=«gertrude» src=«img/ostrich.png»></p>

<script>
  let ostrich = document.getElementById(«gertrude»);
  console.log(ostrich.src);
</script>
```

{{index «метод getElementsByClassName», «атрибут класу»}}

Третій, схожий метод - `getElementsByClassName`, який, як і `getElementsByTagName`, шукає вміст вузла елементів і повертає всі елементи, які мають заданий рядок у своєму атрибуті `class`.

## Зміна документа

{{index «side effect», «removeChild метод», «appendChild метод», «insertBefore метод», [DOM, побудова], [DOM, модифікація]}}

Майже все в структурі даних DOM можна змінювати. Форма дерева документа може бути змінена шляхом зміни відношень між батьком і дочірнім елементом. Вузли мають метод `remove` для видалення їх від поточного батьківського вузла. Щоб додати дочірній вузол до вузла-елемента, можна використати `appendChild`, який додає його в кінець списку дочірніх вузлів, або `insertBefore`, який вставляє вузол, заданий як перший аргумент, перед вузлом, заданим як другий аргумент.

```{lang: html}
<p>Один</p>
<p>Два</p>
<p>Три</p>

<скрипт
  let paragraphs = document.body.getElementsByTagName(«p»);
  document.body.insertBefore(paragraphs[2], paragraphs[0]);
</script> </script> </script> </script> </script> </script> <
```

Вузол може існувати в документі тільки в одному місці. Таким чином, вставка абзацу _Три_ перед абзацом _Один_ спочатку видалить його з кінця документа, а потім вставить на початку, в результаті чого вийде _Три_/_Один_/_Два_. Усі операції, які вставляють вузол кудись, як ((побічний ефект)) призведуть до його видалення з поточної позиції (якщо вона є).

{{index «insertBefore метод», «replaceChild метод»}}

Метод `replaceChild` використовується для заміни дочірньої вершини на іншу. Він приймає в якості аргументів два вузли: новий вузол і вузол, який потрібно замінити. Замінюваний вузол повинен бути дочірнім елементом елемента, для якого викликається метод. Зверніть увагу, що і `replaceChild`, і `insertBefore` очікують _new_ вузол як свій перший аргумент.

## Створення вузлів

{{index «атрибут alt», «img (HTML-тег)», «метод createTextNode»}}

Припустимо, ми хочемо написати скрипт, який замінить усі ((image))и (теги `<img>`) у документі текстом, що міститься у їхніх атрибутах `alt`, які визначають альтернативне текстове представлення зображення. Це передбачає не лише видалення зображень, але й додавання нового текстового вузла на їх місце.

```{lang: html}
<p>Зображення <img src=«img/cat.png» alt=«Cat»> у розділі
  <img src=«img/hat.png» alt=«Hat»>.</p>

<p><button onclick=«replaceImages()»>Замінити</button></p></p>

<скрипт
  function replaceImages() {
    let images = document.body.getElementsByTagName(«img»);
    for (let i = images.length - 1; i >= 0; i--) {
      let image = images[i];
      if (image.alt) {
        let text = document.createTextNode(image.alt);
        image.parentNode.replaceChild(text, image);
      }
    }
  }
</script>
```

{{index «text node»}}

На основі рядка `createTextNode` створює текстовий вузол, який ми можемо вставити у документ, щоб він з'явився на екрані.

{{індекс «жива структура даних», «метод getElementsByTagName», «властивість childNodes»}}

Цикл, який перебирає зображення, починається з кінця списку. Це необхідно тому, що список вузлів, який повертається методом типу `getElementsByTagName` (або властивістю типу `childNodes`), є _живим_. Тобто, він оновлюється при зміні документа. Якби ми почали з початку, видалення першого зображення призвело б до втрати першого елемента списку, тому при другому повторенні циклу, де `i` дорівнює 1, він би зупинився, оскільки довжина колекції тепер також дорівнює 1.

{{index «slice method»}}

Якщо вам потрібна _суцільна_ колекція вузлів, а не жива, ви можете перетворити колекцію у справжній масив, викликавши `Array.from`.

```
let arrayish = {0: «one», 1: «two», length: 2};
let array = Array.from(arrayish);
console.log(array.map(s => s.toUpperCase()));
// → [«ONE», «TWO»]
```

{{index «метод createElement»}}

Для створення вузлів ((element)) можна скористатися методом `document.createElement`. Цей метод отримує ім'я тегу і повертає новий порожній вузол заданого типу.

{{index «Popper, Karl», [DOM, конструкція], «elt function»}}

{{id elt}}

У наступному прикладі визначено утиліту `elt`, яка створює елемент-вузол і розглядає решту її аргументів як дочірні елементи цього вузла. Ця функція потім використовується для додавання атрибуції до цитати.

```{lang: html}
<blockquote id=«quote»>
  Жодна книга не може бути закінчена. Працюючи над нею, ми дізнаємося
  рівно стільки, щоб виявити її недоробленою в той момент, коли ми відвертаємось
  від неї.
</blockquote></blockquote>

<script>
  function elt(type, ...children) {
    let node = document.createElement(type);
    for (let child of children) {
      if (typeof child != «string») node.appendChild(child);
      else node.appendChild(document.createTextNode(child));
    }
    return node;
  }

  document.getElementById(«quote»).appendChild(
    elt(«footer», «-»,
        elt(«strong», «Карл Поппер»),
        », передмова до другого видання »,
        elt(«em», «Відкрите суспільство та його вороги»),
        », 1950"));
</script>
```

{{if book

Ось так виглядає отриманий документ:

{{figure {url: «img/blockquote.png», alt: «Відображене зображення блок-цитати з атрибуцією», width: “8cm”}}}}

if}}

## Атрибути

{{index «href attribute», [DOM, attributes]}}

До деяких елементів ((атрибутів)), таких як `href` для посилань, можна отримати доступ через однойменну властивість на об'єкті елемента ((DOM)). Це стосується більшості стандартних атрибутів, що використовуються найчастіше.

{{індекс «атрибут даних», «метод getAttribute», «метод setAttribute», атрибут}}

HTML дозволяє встановлювати на вузлах будь-які атрибути, які ви хочете. Це може бути корисно, оскільки дозволяє зберігати додаткову інформацію у документі. Щоб прочитати або змінити користувацькі атрибути, які недоступні як звичайні властивості об'єктів, вам слід скористатися методами `getAttribute` та `setAttribute`.

```{lang: html}
<p data-classified=«secret»>Код запуску - 00000000.</p>
<p data-classified=«unclassified»>У мене дві ноги.</p>

<script>
  let paras = document.body.getElementsByTagName(«p»);
  for (let para of Array.from(paras)) {
    if (para.getAttribute(«data-classified») == «secret») {
      para.remove();
    }
  }
</script>
```

Рекомендується додавати до назв таких вигаданих атрибутів префікс `data-`, щоб вони не конфліктували з іншими атрибутами.

{{index «метод getAttribute», «метод setAttribute», «властивість className», «атрибут класу»}}

Існує загальновживаний атрибут `class`, який є ((ключовим словом)) у мові JavaScript. З історичних причин - деякі старі реалізації JavaScript не могли обробляти назви властивостей, що збігаються з ключовими словами - властивість, яка використовується для доступу до цього атрибута, називається `className`. Ви також можете отримати доступ до нього за його справжньою назвою, `«class»`, за допомогою методів `getAttribute` та `setAttribute`.

## Розмітка

{{index layout, «block element», «inline element», «p (HTML tag)», «h1 (HTML tag)», «a (HTML tag)», «strong (HTML tag)»}}

Ви могли помітити, що різні типи елементів розміщуються по-різному. Деякі з них, такі як абзаци (`<p>`) або заголовки (`<h1>`), займають всю ширину документа і виводяться в окремих рядках. Це так звані _блокові_ елементи. Інші, такі як посилання (`<a>`) або елемент `<strong>`, виводяться в одному рядку з навколишнім текстом. Такі елементи називаються _вбудованими_ елементами.

{{малювання індексів}}

Для будь-якого документа браузери здатні обчислити макет, який надає кожному елементу розмір і позицію на основі його типу і вмісту. Цей макет потім використовується для фактичного малювання документа.

{{index «border (CSS)», «offsetWidth property», «offsetHeight property», «clientWidth property», «clientHeight property», dimensions}}

Розмір та положення елемента можна отримати з JavaScript. Властивості `offsetWidth` та `offsetHeight` дають вам простір, який займає елемент у _((пікселях))s_. Піксель - це основна одиниця вимірювання в браузері. Традиційно він відповідає найменшій точці, яку може намалювати екран, але на сучасних дисплеях, які можуть малювати _дуже_ маленькі точки, це вже не так, і піксель браузера може охоплювати декілька точок дисплея.

Аналогічно, `clientWidth` і `clientHeight` дають вам розмір простору _всередині_ елемента, ігноруючи ширину межі.

```{lang: html}
<p style="border: 3px solid red">>></p
  Я замкнений в рамки
</p>

<скрипт
  нехай para = document.body.getElementsByTagName(«p»)[0];
  console.log(«clientHeight:», para.clientHeight);
  // → 19
  console.log(«offsetHeight:», para.offsetHeight);
  // → 25
</script> </script> </script> </script> </script> </script> <
```

{{if book

Якщо надати абзацу рамку, навколо нього буде намальовано прямокутник.

{{figure {url: «img/boxed-in.png», alt: «Зображення абзацу з рамкою», width: “8cm”}}}}

if}}

{{index «getBoundingClientRect method», position, «pageXOffset property», «pageYOffset property»}}

{{id boundingRect}}

Найефективнішим способом знайти точну позицію елемента на екрані є метод `getBoundingClientRect`. Він повертає об'єкт з властивостями `top`, `bottom`, `left` і `right`, які вказують на піксельні позиції сторін елемента відносно лівого верхнього кута екрана. Якщо ви хочете отримати позиції пікселів відносно всього документа, вам слід додати поточну позицію прокрутки, яку можна знайти у прив'язках `pageXOffset` та `pageYOffset`.

{{index «offsetHeight property», «getBoundingClientRect method», drawing, laziness, performance, efficiency}}

Верстка документа може бути досить трудомістким процесом. В інтересах швидкості движки браузерів не перекомпонують документ одразу після внесення змін, а чекають стільки часу, скільки зможуть, перш ніж це зробити. Коли JavaScript-програма, яка змінила документ, завершує роботу, браузеру доводиться обчислювати новий макет, щоб відобразити змінений документ на екрані. Коли програма _запитує_ позицію або розмір чогось, зчитуючи властивості, такі як `offsetHeight` або викликаючи `getBoundingClientRect`, надання цієї інформації також вимагає обчислення ((макет)).

{{індекс «побічний ефект», оптимізація, бенчмарк}}

Програма, яка постійно чергує читання інформації про макет DOM зі зміною DOM, змушує виконувати багато обчислень макета і, як наслідок, працюватиме дуже повільно. Наступний код є прикладом цього. Він містить дві різні програми, які будують рядок з _X_ символів шириною 2,000 пікселів і вимірюють час, який займає кожна з них.

```{lang: html, test: nonumbers}
<p><span id=«one»></span></p></p>
<p><span id=«two»></span></p></p>

<script>
  function time(name, action) {
    let start = Date.now(); // Поточний час в мілісекундах
    action();
    console.log(name, «took», Date.now() - start, «ms»);
  }

  time(«naive», () => {})
    let target = document.getElementById(«one»);
    while (target.offsetWidth < 2000) { { target.appendChild(target.offsetWidth)
      target.appendChild(document.createTextNode(«X»));
    }
  });
  // → naive зайняв 32 мс

  time(«clever», function() {
    let target = document.getElementById(«two»);
    target.appendChild(document.createTextNode(«XXXXX»));
    let total = Math.ceil(2000 / (target.offsetWidth / 5));
    target.firstChild.nodeValue = «X».repeat(total);
  });
  // → clever зайняв 1 мс
</script></script>
```

## Стилізація

{{index «block element», «inline element», style, «strong (HTML tag)», «a (HTML tag)», underline}}

Ми бачили, що різні елементи HTML відображаються по-різному. Деякі з них відображаються як блоки, інші як вбудовані. Деякі додають стиль - `<strong>` робить вміст напівжирним, а `<a>` робить його синім і підкреслює.

{{index «img (HTML-тег)», «поведінка за замовчуванням», «атрибут стилю»}}

Те, як тег `<img>` показує зображення, або тег `<a>` викликає перехід за посиланням при натисканні на нього, сильно залежить від типу елемента. Але ми можемо змінити стиль, пов'язаний з елементом, наприклад, колір тексту або підкреслення. Ось приклад використання властивості `style`:

```{lang: html}
<p><a href=«.»>Звичайне посилання</a></p></p>
<p><a href=«.» style=«color: green»>Зелене посилання</a></p>
```

{{if book

Друге посилання буде зеленим замість стандартного кольору посилання:

{{figure {url: «img/colored-links.png», alt: «Зображення звичайного синього посилання та стилізованого зеленого посилання», width: “2.2cm”}}}}

if}}

{{index «border (CSS)», «color (CSS)», CSS, «символ двокрапки»}}

Атрибут стилю може містити одну або більше _((декларацій))s_, які є властивістю (наприклад, `color`), за якою слідує двокрапка і значення (наприклад, `green`). Якщо оголошень більше одного, їх слід розділяти ((крапкою з комою))s, як у `«color: red; border: none»`.

{{index «display (CSS)», layout}}

На багато аспектів документа можна впливати за допомогою стилів. Наприклад, властивість `display` визначає, чи буде елемент відображатися як блок або як вбудований елемент.

```{lang: html}
Цей текст відображається <strong>вбудовано</strong>,
<strong style=«display: block»>як блок</strong>, і
<strong style=«display: none»>зовсім</strong>.
```

{{index «hidden element»}}

Тег `block` буде виведено у власному рядку, оскільки ((блок-елемент))и не виводяться в лінію з текстом навколо них. Останній тег не відображається взагалі - `display: none` запобігає відображенню елемента на екрані. Це спосіб приховати елементи. Часто він є кращим за повне вилучення елементів з документа, оскільки дозволяє легко показати їх пізніше.

{{if book

{{figure {url: «img/display.png», alt: «Різні стилі відображення», width: “4cm”}}}}

if}}

{{index «color (CSS)», «style attribute»}}

Код JavaScript може безпосередньо маніпулювати стилем елемента через властивість `style` елемента. Ця властивість містить об'єкт, який має властивості для всіх можливих властивостей стилю. Значення цих властивостей є рядками, які ми можемо записати, щоб змінити певний аспект стилю елемента.

```{lang: html}
<p id=«para» style=«color: purple»>
  Гарний текст
</p>

<script>
  let para = document.getElementById(«para»);
  console.log(para.style.color);
  para.style.color = «magenta»;
</script> </script> </script> </script> </script> </script> </script
```

{{index «camel case», capitalization, «hyphen character», «font-family (CSS)»}}

Деякі назви властивостей стилів містять дефіси, наприклад, `font-family`. Оскільки з такими назвами властивостей незручно працювати у JavaScript (вам доведеться сказати `style[«font-family»]`), у назвах властивостей в об'єкті `style` для таких властивостей дефіси видалено, а літери, що стоять після них, взято з великої літери (`style.fontFamily`).

## Каскадні стилі

{{index «правило (CSS)», «стиль (HTML-тег)»}}

{{indexsee «каскадні таблиці стилів», CSS}}
{{indexsee «таблиця стилів», CSS}}

Система стилів для HTML називається _((CSS))_, для _каскадних таблиць стилів_. Таблиця_стилів_ - це набір правил для стилізації елементів у документі. Вона може бути задана всередині тегу `<style>`.

```{lang: html}
<style>
  strong {{lang: html}
    font-style: italic;
    color: gray;
  }
</style></style>
<p>Тепер <strong>сильний текст</strong> виділено курсивом і сірим кольором.</p>
```

{{index «rule (CSS)», «font-weight (CSS)», overlay}}

_((каскадний))_ у назві вказує на те, що декілька таких правил комбінуються для створення остаточного стилю для елемента. У прикладі стиль за замовчуванням для тегів `<strong>`, який надає їм `font-weight: bold`, накладається на правило у тезі `<style>`, яке додає `font-style` і `color`.

{{index «style (HTML-тег)», «атрибут стилю»}}

Коли декілька правил визначають значення для однієї властивості, правило, яке було прочитано останнім, отримує вищий пріоритет і перемагає. Наприклад, якщо правило у тезі `<style>` містить `font-weight: normal`, що суперечить правилу за замовчуванням `font-weight`, текст буде звичайним, _не_ напівжирним. Стилі в атрибуті `style`, застосовані безпосередньо до вузла, мають найвищий пріоритет і завжди перемагають.

{{індекс унікальності, «атрибут класу», «атрибут id»}}

У правилах CSS можна націлюватись на речі, відмінні від імен ((тегів)). Правило для `.abc` застосовується до всіх елементів з `.abc` в атрибуті `class`. Правило для `#xyz` застосовується до елементів з атрибутом `id`, що має значення `«xyz»` (який має бути унікальним у документі).

```{lang: «css"}
.subtle {
  color: gray;
  font-size: 80%;
}
#header {
  background: blue;
  color: white;
}
/* елементи p з ідентифікатором main та класами a і b */
p#main.a.b {
  margin-bottom: 20px;
}
```

{{index «rule (CSS)»}}

Правило ((пріоритету)), яке надає перевагу останньому визначеному правилу, застосовується лише тоді, коли правила мають однакову _((специфічність))_. Специфічність правила - це міра того, наскільки точно воно описує відповідні елементи, що визначається кількістю і типом (тег, клас або ідентифікатор) аспектів елементів, яких воно вимагає. Наприклад, правило, яке визначає `p.a`, є більш специфічним, ніж правила, які визначають `p` або просто `.a`, і, отже, матиме пріоритет над ними.

{{index «прямий дочірній вузол»}}

Запис `p > a {...}` застосовує задані стилі до всіх тегів `<a>`, які є прямими нащадками тегів `<p>`. Аналогічно, `p a {...}` застосовується до всіх тегів `<a>` всередині тегів `<p>`, незалежно від того, чи є вони прямими або непрямими нащадками.

## Селектори запитів

{{складність індексу, CSS, «мова, специфічна для домену», [DOM, запити]}}

У цій книзі ми не будемо часто використовувати таблиці стилів. Розуміння їх корисно при програмуванні в браузері, але вони досить складні і заслуговують на окрему книгу. Основна причина, чому я ввів синтаксис _((селектор))_ - позначення, що використовується в таблицях стилів для визначення того, до яких елементів застосовується набір стилів - полягає в тому, що ми можемо використовувати цю ж міні-мову як ефективний спосіб пошуку елементів DOM.

{{index «querySelectorAll method», «NodeList type»}}

Метод `querySelectorAll`, який визначено як на об'єкті `document`, так і на вузлах елементів, отримує рядок-селектор і повертає `NodeList`, що містить усі елементи, яким він відповідає.

```{lang: html}
<p>А якщо ви підете в погоню за
  <span class=«animal»>кроликів</span></p></p>
<p>І знаєш, що впадеш</p>
<p>Скажи їм, що курить кальян
  <span class=«animal»>гусінь</span></span></p>
<p>Дзвонила тобі</p>

<script>
  function count(selector) {
    return document.querySelectorAll(selector).length;
  }
  console.log(count(«p»)); // Усі елементи <p>
  // → 4
  console.log(count(«.animal»)); // Клас animal
  // → 2
  console.log(count(«p .animal»)); // Тварина всередині <p>
  // → 2
  console.log(count(«p > .animal»)); // Прямий нащадок <p>
  // → 1
</script> </script> </script> </script> </script> </script> </script
```

{{index «жива структура даних»}}

На відміну від таких методів, як `getElementsByTagName`, об'єкт, який повертає `querySelectorAll`, _не_ є живим. Він не зміниться, коли ви зміните документ. Однак це все ще не справжній масив, тому вам потрібно викликати `Array.from`, якщо ви хочете поводитися з ним як з масивом.

{{index «метод querySelector»}}

Метод `querySelector` (без частини `All`) працює подібним чином. Він корисний, якщо вам потрібен конкретний єдиний елемент. Він поверне лише перший знайдений елемент або `null`, якщо не буде знайдено жодного елемента.

{{id animation}}

## Позиціонування та анімація

{{index «position (CSS)», «відносне позиціонування», «top (CSS)», «left (CSS)», «абсолютне позиціонування»}}

Властивість стилю `position` має потужний вплив на верстку. За замовчуванням вона має значення `static`, що означає, що елемент розташовується на своєму звичайному місці в документі. Коли їй встановлено значення `relative`, елемент все одно займає місце у документі, але тепер властивості стилю `top` і `left` можна використовувати для його переміщення відносно цього звичайного місця. Коли `position` має значення `absolute`, елемент вилучається зі звичайного потоку документа - тобто він більше не займає місця і може перекриватися з іншими елементами. Його властивості `top` і `left` можна використовувати для абсолютного позиціонування відносно лівого верхнього кута найближчого елемента, що охоплює, властивість `position` якого не є `статичною`, або відносно документа, якщо такого елемента, що охоплює, не існує.

{{index [animation, «spinning cat»]}}

Ми можемо використати це для створення анімації. У наступному документі показано зображення кота, який рухається по ((еліпсу)):

```{lang: html, startCode: true}
<p style=«text-align: center»>
  <img src=«img/cat.png» style=«position: relative»>
</p>
<script>
  let cat = document.querySelector(«img»);
  let angle = Math.PI / 2;
  function animate(time, lastTime) {
    if (lastTime != null) {
      angle += (time - lastTime) * 0.001;
    }
    cat.style.top = (Math.sin(angle) * 20) + «px»;
    cat.style.left = (Math.cos(angle) * 200) + «px»;
    requestAnimationFrame(newTime => animate(newTime, time));
  }
  requestAnimationFrame(animate);
</script> </span> </span> </span> </span> </p
```

{{if book

Сіра стрілка показує шлях, яким рухається зображення.

{{figure {url: «img/cat-animation.png», alt: «Діаграма, що показує зображення кота з круговою стрілкою, що вказує його рух», width: “8cm”}}}}

if}}

{{index «top (CSS)», «left (CSS)», centering, «relative positioning»}}

Наше зображення вирівняно по центру сторінки і йому присвоєно `позицію` `відносне`. Ми неодноразово оновлюватимемо стилі `top` та `left` цього зображення, щоб перемістити його.

{{index «requestAnimationFrame function», drawing, animation}}

{{id animationFrame}}

Скрипт використовує `requestAnimationFrame` для планування запуску функції `animate` щоразу, коли браузер буде готовий перефарбувати екран. Сама функція `animate` знову викликає `requestAnimationFrame` для планування наступного оновлення. Коли вікно (або вкладка) браузера активне, це призведе до оновлення зі швидкістю близько 60 за секунду, що, як правило, створює гарну анімацію.

{{Часова шкала індексів, блокування}}

Якби ми просто оновлювали DOM у циклі, сторінка застигла б, і на екрані нічого не відобразилося б. Браузери не оновлюють відображення під час виконання JavaScript-програми, а також не дозволяють ніякої взаємодії зі сторінкою. Ось чому нам потрібен `requestAnimationFrame` - він дає браузеру знати, що ми закінчили, і він може продовжувати робити те, що роблять браузери, наприклад, оновлювати екран і реагувати на дії користувача.

{{index «smooth animation»}}

Функції анімації передається поточний ((час)) як аргумент. Щоб забезпечити стабільність руху кота в мілісекунду, вона базує швидкість зміни кута на різниці між поточним часом і останнім запуском функції. Якби вона просто змінювала кут на фіксовану величину за крок, то рух затинався б, коли, наприклад, інша важка задача, запущена на тому ж комп'ютері, заважала функції працювати на долю секунди.

{{index «Math.cos function», «Math.sin function», косинус, синус, тригонометрія}}

{{id sin_cos}}

Переміщення по ((колу))s здійснюється за допомогою тригонометричних функцій `Math.cos` та `Math.sin`. Для тих, хто не знайомий з цими функціями, я коротко опишу їх, оскільки ми будемо час від часу використовувати їх у цій книзі.

{{індексні координати, pi}}

Функції `Math.cos` і `Math.sin` корисні для пошуку точок, які лежать на колі навколо точки (0, 0) радіусом 1. Обидві функції інтерпретують свій аргумент як положення на цьому колі, де 0 позначає точку на крайньому правому краю кола, і рухаються за годинниковою стрілкою, доки 2π (приблизно 6.28) не обійде все коло. Команда `Math.cos` показує координату x точки, яка відповідає даній позиції, а команда `Math.sin` - координату y. Позиції (або кути), більші за 2π або менші за 0, вважаються дійсними - обертання повторюється так, що _a_+2π відноситься до того самого ((кута)), що й _a_.

{{індекс «постійна ПІ»}}

Ця одиниця вимірювання кутів називається ((радіан))s - повне коло дорівнює 2π радіан, подібно до того, як 360 градусів при вимірюванні в градусах. Константа π доступна як `Math.PI` у JavaScript.

{{figure {url: «img/cos_sin.svg», alt: «Діаграма, що показує використання косинуса і синуса для обчислення координат. Показано коло радіусом 1 з двома точками на ньому. Кут від правої сторони кола до точки, в радіанах, використовується для обчислення положення кожної точки, використовуючи 'cos(кут)' для горизонтальної відстані від центру кола і sin(кут) для вертикальної відстані.», width: “6cm”}}}

{{index «змінна-лічильник», «Math.sin функція», «top (CSS)», «Math.cos функція», «left (CSS)», ellipse}}

Код анімації кота зберігає лічильник `angle` для поточного кута анімації і збільшує його кожного разу, коли викликається функція `animate`. Потім він може використовувати цей кут для обчислення поточної позиції елемента зображення. Стиль `top` обчислюється за допомогою функції `Math.sin` і множиться на 20, що є вертикальним радіусом нашого еліпса. Стиль `left` базується на `Math.cos` і множиться на 200, щоб еліпс був значно ширшим, ніж високим.

{{index «unit (CSS)»}}

Зверніть увагу, що стилям зазвичай потрібні _одиниці_. У цьому випадку ми повинні додати `«px»` до числа, щоб сказати браузеру, що ми рахуємо в ((пікселях))s (на відміну від сантиметрів, «емс» або інших одиниць). Це легко забути. Використання чисел без одиниць виміру призведе до того, що ваш стиль буде проігноровано - за винятком числа 0, яке завжди означає одне й те саме, незалежно від одиниці виміру.

## Підсумок

Програми на JavaScript можуть перевіряти і втручатися в документ, який відображається браузером, через структуру даних, яка називається DOM. Ця структура даних представляє модель документа, що відображається браузером, і JavaScript-програма може модифікувати її, щоб змінити видимий документ.

DOM організована як дерево, де елементи розташовані ієрархічно відповідно до структури документа. Об'єкти, що представляють елементи, мають такі властивості, як `parentNode` і `childNode`, які можна використовувати для навігації по цьому дереву.

На спосіб відображення документа можна впливати за допомогою _стилів_, як шляхом додавання стилів безпосередньо до вузлів, так і шляхом визначення правил, які відповідають певним вузлам. Існує багато різних властивостей стилів, таких як `color` або `display`. Код JavaScript може маніпулювати стилем елемента безпосередньо через його властивість `style`.

## Вправи

{{id exercise_table}}

### Створити таблицю

{{index «table (HTML-тег)»}}

HTML-таблиця будується з наступною структурою тегів:

```{lang: html}
<table
  <tr> <tr>
    <th>name</th>
    <th>height</th>
    <th>місце</th>
  
  <tr>
    <td>Кіліманджаро</td>
    <td>5895</td>
    <td>Танзанія</td>
  </tr> </li> </li> <li>Танзанія
</table>
```

{{index «tr (HTML-тег)», «th (HTML-тег)», «td (HTML-тег)»}}

Для кожного _((рядка))_ тег `<table>` містить тег `<tr>`. Всередині цих тегів `<tr>` ми можемо розмістити елементи комірок: або заголовки (`<th>`), або звичайні комірки (`<td>`).

За заданим набором даних про гори, масивом об'єктів з властивостями `name`, `height` і `place`, згенеруйте DOM-структуру для таблиці, яка перераховує ці об'єкти. Вона має один стовпець на ключ і один рядок на об'єкт, а також рядок заголовка з елементами `<th>` у верхній частині, де перераховано назви стовпців.

Напишіть так, щоб стовпці автоматично отримувалися з об'єктів, беручи назви властивостей першого об'єкта у даних.

Покажіть отриману таблицю у документі, додавши її до елемента з атрибутом `id`, що має значення `«mountains»`.

{{index «right-aligning», «text-align (CSS)»}}

Після того, як це спрацює, вирівняйте комірки, що містять числові значення, по правому краю, встановивши їхню властивість `style.textAlign` у значення `«right»`.

{{якщо інтерактивний

```{test: no, lang: html}
<h1>Гори</h1>

<div id=«mountains»></div>

<script>
  const MOUNTAINS = [
    {name: «Кіліманджаро», height: 5895, place: «Танзанія"},
    {назва: «Еверест», висота: 8848, місце: «Непал»}, {назва: «Еверест», висота: 8848, місце: «Непал"},
    {Назва: «Гора Фудзі», висота: 3776, місце: «Японія"},
    {назва: «Ваалсерберг», висота: 323, місце: «Нідерланди"},
    {Назва: «Деналі», висота: 6168, місце: «Сполучені Штати"},
    {name: «Popocatepetl», height: 5465, place: «Мексика"},
    {назва: «Mont Blanc», висота: 4808, місце: «Італія/Франція"}}
  ];

  // Ваш код тут
</script>
```

if}}

{{hint

{{index «метод createElement», «приклад таблиці», «метод appendChild»}}

Ви можете використовувати `document.createElement` для створення нових вузлів елементів, `document.createTextNode` для створення текстових вузлів і метод `appendChild` для вставки вузлів в інші вузли.

{{index «Object.keys function»}}

Вам потрібно буде виконати цикл над іменами ключів один раз, щоб заповнити верхній рядок, а потім повторити його для кожного об'єкта у масиві, щоб побудувати рядки даних. Щоб отримати масив імен ключів з першого об'єкта, скористайтеся функцією `Object.keys`.

{{index «метод getElementById», «метод querySelector»}}

Щоб додати таблицю до правильного батьківського вузла, ви можете використати `document.getElementById` або `document.querySelector` з `«#mountains»` для пошуку вузла.

підказка}}

### Елементи за назвою тегу

{{index «getElementsByTagName метод», рекурсія}}

Метод `document.getElementsByTagName` повертає всі дочірні елементи з заданою назвою тегу. Реалізуйте власну версію цього методу у вигляді функції, яка приймає вузол і рядок (ім'я тегу) як аргументи і повертає масив, що містить усі вузли нащадків елементів із заданим ім'ям тегу. Ваша функція повинна проходити через сам документ. Вона не може використовувати метод типу `querySelectorAll` для виконання роботи.

{{індекс «властивість nodeName», великі літери, «метод toLowerCase», «метод toUpperCase»}}

Щоб знайти ім'я тегу елемента, використовуйте його властивість `nodeName`. Але зауважте, що вона поверне назву тегу у верхньому регістрі. Використовуйте рядкові методи `toLowerCase` або `toUpperCase`, щоб компенсувати це.

{{якщо інтерактивний

```{lang: html, test: no}
<h1>Заголовок з елементом <span>span</span>.</h1>
<p>Абзац з <span>одним</span>, <span>двома</span>
  проміжками.</p>

<скрипт
  function byTagName(node, tagName) {
    // Ваш код тут.
  }

  console.log(byTagName(document.body, «h1»).length);
  // → 1
  console.log(byTagName(document.body, «span»).length);
  // → 3
  нехай para = document.querySelector(«p»);
  console.log(byTagName(para, «span»).length);
  // → 2
</script> </span> </span> </span> </span> </span
```
if}}

{{hint

{{index «метод getElementsByTagName», рекурсія}}

Розв'язок найпростіше виразити за допомогою рекурсивної функції, подібної до функції [`talksAbout`](dom#talksAbout), визначеної раніше у цій главі.

{{індексна конкатенація, «метод конкатенації», закриття}}

Ви можете викликати саму функцію `byTagname` рекурсивно, конкатенуючи отримані масиви для отримання результату. Або ви можете створити внутрішню функцію, яка викликає себе рекурсивно і має доступ до прив'язки масиву, визначеної у зовнішній функції, до якої вона може додавати знайдені елементи, що збігаються. Не забудьте викликати ((внутрішню функцію)) один раз із зовнішньої функції, щоб запустити процес.

{{index «властивість nodeType», «код ELEMENT_NODE»}}

Рекурсивна функція повинна перевіряти тип вузла. Тут нас цікавить лише вузол типу 1 (`Node.ELEMENT_NODE`). Для таких вузлів ми повинні переглянути їхніх дочірніх елементів і для кожного дочірнього елемента перевірити, чи відповідає він запиту, а також виконати рекурсивний виклик для перевірки його власних дочірніх елементів.

підказка}}

### Котячий капелюх

{{index «котячий капелюх (вправа)», [animation, «кіт, що крутиться»]}}

Розширте анімацію кота, визначену [раніше](dom#animation), так, щоб і кіт, і його капелюх (`<img src=«img/hat.png»>`) оберталися на протилежних сторонах еліпса.

Або зробіть так, щоб капелюх обертався навколо кота. Або змініть анімацію якимось іншим цікавим чином.

{{index «абсолютне позиціонування», «top (CSS)», «left (CSS)», «position (CSS)»}}

Щоб полегшити позиціонування декількох об'єктів, ви, ймовірно, захочете перейти до абсолютного позиціонування. Це означає, що «верхній» і «лівий» відраховуватимуться відносно лівого верхнього кута документа. Щоб уникнути використання від'ємних координат, які можуть призвести до переміщення зображення за межі видимої сторінки, ви можете додати до значень позицій фіксовану кількість пікселів.

{{якщо інтерактивний

```{lang: html, test: no}
<style>body { min-height: 200px }</style></style>
<img src=«img/cat.png» id=«cat» style=«position: absolute»>
<img src=«img/hat.png» id=«hat» style=«position: absolute»>

<скрипт
  let cat = document.querySelector(«#cat»);
  let hat = document.querySelector(«#hat»);

  let angle = 0;
  let lastTime = null;
  function animate(time) {
    if (lastTime != null) angle += (time - lastTime) * 0.001;
    lastTime = time;
    cat.style.top = (Math.sin(angle) * 40 + 40) + «px»;
    cat.style.left = (Math.cos(angle) * 200 + 230) + «px»;

    // Ваші розширення тут.

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
</script>
```

if}}

{{підказка

Функції `Math.cos` та `Math.sin` вимірюють кути у радіанах, де повне коло дорівнює 2π. Для заданого кута ви можете отримати протилежний кут, додавши половину цього кута, тобто `Math.PI`. Це може бути корисно для розміщення капелюха на протилежному боці орбіти.

підказка}}
