{{meta {load_files: [«code/chapter/07_robot.js», «code/animatevillage.js»], zip: html}}}}

# Проект: Робот

{{quote {author: «Edsger Dijkstra», title: 

Питання про те, чи можуть машини мислити [...] є настільки ж актуальним, як і питання про те, чи можуть підводні човни плавати.

quote}}

{{index «artificial intelligence», «Dijkstra, Edsger»}}

{{figure {url: «img/chapter_picture_7.jpg», alt: «Ілюстрація робота, що тримає стос пакунків», “chapter”: “framed” }}}

{{index «глава проекту», «читання коду», «запис коду»}}

У «проектних» розділах я ненадовго припиню засипати вас новою теорією, і натомість ми разом працюватимемо над програмою. Теорія необхідна для того, щоб навчитися програмувати, але читати і розуміти реальні програми не менш важливо.

Нашим завданням у цій главі є створення ((автомата)), маленької програми, яка виконує завдання у ((віртуальному світі)). Наш автомат буде поштовим ((роботом)), який забиратиме та розноситиме посилки.

## Медоуфілд

{{index «roads array»}}

Село ((Meadowfield)) не дуже велике. Воно складається з 11 населених пунктів, між якими прокладено 14 доріг. Його можна описати за допомогою цього масиву доріг:

```{includeCode: true}
const roads = [
  «Будинок Аліси - Будинок Боба», “Будинок Аліси - Хатина”,
  «Будинок Аліси-Пошта», “Будинок Боба-Ратуша”,
  «Будинок Дарини - будинок Ерні», “Будинок Дарини - ратуша”,
  «Будинок Ерні - будинок Грети», “Будинок Грети - ферма”,
  «Будинок Грети - магазин», “Ринок - ферма”,
  «Ринок-пошта», “Ринок-магазин”,
  «Ринок-ратуша», »Магазин-ратуша»
];
```

{{figure {url: «img/village2x.png», alt: «Піксельна ілюстрація невеликого села з 11 локаціями, позначеними літерами, та дорогами, що ведуть до них"}}}.

Мережа доріг у селі утворює _((граф))_. Граф - це сукупність точок (місць у селі) з лініями між ними (дорогами). Цей граф і буде світом, яким рухається наш робот.

{{index «roadGraph object»}}

З масивом рядків не дуже зручно працювати. Нас цікавлять пункти призначення, до яких ми можемо дістатися з даного місця. Давайте перетворимо список доріг у структуру даних, яка для кожного місця покаже, куди можна дістатися з нього.

```{includeCode: true}
function buildGraph(edges) {
  let graph = Object.create(null);
  function addEdge(from, to) {
    if (from in graph) {
      graph[from].push(to);
    } else {
      graph[from] = [to];
    }
  }
  for (let [from, to] of edges.map(r => r.split(«-»)) {
    addEdge(from, to);
    addEdge(to, from);
  }
  return граф;
}

const roadGraph = buildGraph(roads);
```

{{index «split method»}}

Отримавши масив ребер, `buildGraph` створює об'єкт карти, який для кожної вершини зберігає масив з'єднаних вершин. Він використовує метод `split` для переходу від рядків доріг, які мають вигляд `«Початок-Кінець»`), до двоелементних масивів, що містять початок і кінець як окремі рядки.

## Задача

Наш ((робот)) буде пересуватись по селу. У різних місцях розкладено посилки, кожна з яких адресована у певне місце. Робот забирає посилки, коли натрапляє на них, і доставляє їх, коли прибуває до місця призначення.

У кожній точці автомат повинен вирішити, куди їхати далі. Він завершить свою роботу, коли всі посилки будуть доставлені.

{{індекс симуляції, «віртуальний світ»}}

Щоб змоделювати цей процес, ми повинні визначити віртуальний світ, який може його описати. Ця модель показує нам, де знаходиться робот і де знаходяться посилки. Коли робот вирішив кудись переїхати, нам потрібно оновити модель, щоб відобразити нову ситуацію.

{{індекс [стан, в об'єктах]}}

Якщо ви мислите в термінах ((об'єктно-орієнтованого програмування)), вашим першим імпульсом може бути почати визначати об'єкти для різних елементів світу: один ((клас)) для робота, один для посилки, можливо, один для місця. Ці об'єкти можуть мати властивості, які описують їх поточний ((стан)), наприклад, купу посилок у певному місці, які ми можемо змінювати при оновленні світу.

Це неправильно. Принаймні, зазвичай так і є. Той факт, що щось звучить як об'єкт, не означає автоматично, що це має бути об'єктом у вашій програмі. Рефлекторне написання класів для кожного поняття у вашій програмі, як правило, призводить до того, що ви отримуєте набір взаємопов'язаних об'єктів, кожен з яких має свій власний внутрішній стан, що змінюється. Такі програми часто важко зрозуміти, а отже, їх легко зламати.

{{index [стан, в об'єктах]}}

Натомість давайте зведемо стан села до мінімального набору значень, які його визначають. Це поточне місцезнаходження робота та колекція недоставлених посилок, кожна з яких має поточне місцезнаходження та адресу призначення. Це все.

{{index «VillageState class», «persistent data structure»}}

Давайте зробимо так, щоб ми не _змінювали_ цей стан, коли робот рухається, а обчислювали _новий_ стан для ситуації після переміщення.

```{includeCode: true}
class VillageState {
  constructor(place, parcels) {
    this.place = place;
    this.parcels = parcels;
  }

  move(destination) {
    if (!roadGraph[this.place].includes(destination)) {
      повернути this;
    } else {
      let parcels = this.parcels.map(p => {
        if (p.place != this.place) return p;
        return { місце: пункт призначення, адреса: p.адреса};
      }).filter(p => p.place != p.address);
      return new VillageState(пункт призначення, посилки);
    }
  }
}
```

Метод `move` - це місце, де відбувається дія. Спочатку він перевіряє, чи існує дорога, яка веде з поточного місця до місця призначення, і якщо ні, то повертає старий стан, оскільки це не є дійсним переміщенням.

{{index «map method», «filter method»}}

Далі метод створює новий стан з пунктом призначення як новим місцем перебування робота. Він також повинен створити новий набір посилок - посилки, які робот перевозить (які знаходяться у поточному місці робота), повинні бути переміщені до нового місця. А посилки, адресовані на нове місце, потрібно доставити - тобто, видалити їх з набору недоставлених посилок. Виклик `map` відповідає за переміщення, а виклик `filter` - за доставку.

При переміщенні об'єкти посилок не змінюються, а створюються заново. Метод `move` дає нам новий стан села, але залишає старий повністю недоторканим.

```
let first = new VillageState(
  «Пошта»,
  [{місце: «Поштове відділення», адреса: «Будинок Аліси»}]
);
let next = first.move(«Alice's House»);

console.log(next.place);
// → Будинок Аліси
console.log(next.parcels);
// → []
console.log(first.place);
// → Пошта
```

Переміщення призводить до доставки посилки, що відображається у наступному стані. Але початковий стан все ще описує ситуацію, коли робот знаходиться на пошті, а посилка не доставлена.

## Постійні дані

{{index «persistent data structure», mutability, [«data structure», immutable]}}

Структури даних, які не змінюються, називаються _((незмінними))_ або _постійними_. Вони поводяться подібно до рядків і чисел, оскільки вони є тим, чим вони є, і залишаються такими, а не містять різні речі в різний час.

У JavaScript майже все  можна змінювати, тому робота зі значеннями, які мають бути постійними, вимагає певної стриманості. Існує функція `Object.freeze`, яка змінює об'єкт так, що запис до його властивостей ігнорується. Ви можете скористатися нею, щоб переконатися, що ваші об'єкти не буде змінено, якщо ви хочете бути обережними. Заморожування вимагає від комп'ютера додаткової роботи, а ігнорування оновлень може заплутати когось з такою ж ймовірністю, як і неправильні дії. Зазвичай я вважаю за краще просто сказати людям, що з певним об'єктом не варто жартувати, і сподіваюся, що вони це запам'ятають.

```
let object = Object.freeze({value: 5});
object.value = 10;
console.log(object.value);
// → 5
```

Чому я намагаюся не змінювати об'єкти, коли мова явно очікує, що я це зроблю? Тому що це допомагає мені розуміти мої програми. Це знову про управління складністю. Коли об'єкти в моїй системі є фіксованими, стабільними речами, я можу розглядати операції над ними ізольовано - переміщення до будинку Аліси з заданого початкового стану завжди призводить до того ж самого нового стану. Коли об'єкти змінюються з часом, це додає цілий новий вимір складності до такого роду міркувань.

Для невеликої системи, подібної до тієї, яку ми будуємо у цій главі, ми можемо впоратися з цією додатковою складністю. Але найважливішим обмеженням на те, які системи ми можемо створювати, є те, наскільки багато ми можемо зрозуміти. Все, що робить ваш код простішим для розуміння, дає можливість побудувати більш амбітну систему.

На жаль, хоча зрозуміти систему, побудовану на постійних структурах даних, простіше, «спроектувати» її, особливо коли ваша мова програмування не допомагає, може бути трохи складніше. У цій книзі ми будемо шукати можливості для використання постійних структур даних, але також будемо використовувати і змінні.

## Моделювання

{{index simulation, «virtual world»}}

Кур'єр ((робот)) дивиться на світ і вирішує, у якому напрямку він хоче рухатися. Можна сказати, що робот - це функція, яка отримує об'єкт `VillageState` і повертає назву найближчого населеного пункту.

{{index «runRobot function»}}

Оскільки ми хочемо, щоб роботи могли запам'ятовувати речі, щоб вони могли складати і виконувати плани, ми також передаємо їм їхню пам'ять і дозволяємо їм повертати нову пам'ять. Таким чином, робот повертає об'єкт, який містить як напрямок, у якому він хоче рухатися, так і значення пам'яті, яке буде повернуто йому при наступному виклику.

```{includeCode: true}
function runRobot(state, robot, memory) {
  for (let turn = 0;; turn++) {
    if (state.parcels.length == 0) {
      console.log(`Зроблено за ${turn} ходів`);
      break;
    }
    let action = robot(state, memory);
    state = state.move(action.direction);
    memory = action.memory;
    console.log(`Переміщено у ${action.direction}`);
  }
}
```

Розглянемо, що повинен зробити робот, щоб «вирішити» заданий стан. Він повинен забрати всі посилки, відвідавши кожне місце, де є посилка, і доставити їх, відвідавши кожне місце, куди адресовано посилку, але тільки після того, як забере посилку.

Яка найбезглуздіша стратегія може спрацювати? Робот може просто йти у випадковому напрямку на кожному кроці. Це означає, що з великою ймовірністю він натрапить на всі посилки, а потім також в якийсь момент досягне місця, куди їх потрібно доставити.

{{index «randomPick function», «randomRobot function»}}

Ось як це може виглядати:

```{includeCode: true}
function randomPick(array) {
  let choice = Math.floor(Math.random() * array.length);
  return array[choice];
}

function randomRobot(state) {
  return {direction: randomPick(roadGraph[state.place])};
}
```

{{index «Math.random function», «Math.floor function», [array, «random element»]}}

Пам'ятайте, що `Math.random()` повертає число від 0 до 1 - але завжди менше 1. Помноживши це число на довжину масиву, а потім застосувавши до нього `Math.floor`, ми отримаємо випадковий індекс масиву.

Оскільки цьому роботу не потрібно нічого запам'ятовувати, він ігнорує свій другий аргумент (пам'ятайте, що функції JavaScript можна викликати з додатковими аргументами без будь-яких негативних наслідків) і опускає властивість `memory` в об'єкті, що повертається.

Щоб змусити цього складного робота працювати, нам спочатку потрібен спосіб створення нового стану з деякими посилками. Статичний метод (написаний тут шляхом безпосереднього додавання властивості до конструктора) є гарним місцем для розміщення цієї функціональності.

```{includeCode: true}
VillageState.random = function(parcelCount = 5) {
  let parcels = [];
  for (let i = 0; i < parcelCount; i++) {
    let address = randomPick(Object.keys(roadGraph));
    let place;
    do {
      place = randomPick(Object.keys(roadGraph));
    } while (place == address);
    parcels.push({place, address});
  }
  return new VillageState(«Пошта», parcels);
};
```

{{index «do loop»}}

Ми не хочемо, щоб посилки відправлялися з того ж місця, куди вони були адресовані. З цієї причини цикл `do` продовжує вибирати нові місця, коли він отримує місце, яке дорівнює адресі.

Запустимо віртуальний світ.

```{test: no}
runRobot(VillageState.random(), randomRobot);
// → Перемістився на Ринок
// → Переїхали до Ратуші
// → ...
// → Виконано за 63 ходи
```

Роботу потрібно багато ходів, щоб доставити посилки, тому що він не дуже добре планує наперед. Ми скоро це виправимо.

{{якщо інтерактивно

Для більш приємного перегляду симуляції ви можете скористатися функцією `runRobotAnimation`, яка доступна у середовищі програмування [цієї глави](https://eloquentjavascript.net/code/#7). Вона запускає симуляцію, але замість виведення тексту показує вам робота, який рухається мапою села.

```{test: no}
runRobotAnimation(VillageState.random(), randomRobot);
```

Спосіб реалізації `runRobotAnimation` поки що залишиться загадкою, але після того, як ви прочитаєте [наступні розділи](dom) цієї книги, у яких обговорюється інтеграція JavaScript у веб-браузери, ви зможете здогадатися, як це працює.

if}}

## Маршрут поштової машини

{{index «mailRoute array»}}

Ми можемо зробити набагато краще, ніж випадковий ((робот)). Простим покращенням може бути використання підказки з того, як працює доставка пошти у реальному світі. Якщо ми знайдемо маршрут, який проходить через усі місця у селі, то робот може проїхати цим маршрутом двічі, і тоді він гарантовано буде доставлений. Ось один з таких маршрутів (починається від поштового відділення):

```{includeCode: true}
const mailRoute = [
  «Будинок Аліси», “Хатина”, “Будинок Аліси”, “Будинок Боба”,
  «Ратуша», “Дім Дарини”, “Дім Ерні”,
  «Будинок Грети», “Магазин”, “Будинок Грети”, “Ферма”,
  «Ринок», »Пошта»
];
```

{{index «routeRobot function»}}

Для реалізації робота, що слідує за маршрутом, нам знадобиться пам'ять робота. Робот зберігає решту маршруту у своїй пам'яті і скидає перший елемент на кожному кроці.

```{includeCode: true}
function routeRobot(state, memory) {
  if (memory.length == 0) {
    memory = mailRoute;
  }
  return {direction: memory[0], memory: memory.slice(1)};
}
```

Цей робот вже набагато швидший. Він зробить максимум 26 поворотів (вдвічі більше, ніж 13-кроковий маршрут), але зазвичай менше.

{{якщо інтерактивно

```{test: no}
runRobotAnimation(VillageState.random(), routeRobot, []);
```

if}}

## Пошук шляху

Все ж таки, я б не назвав сліпе слідування за фіксованим маршрутом розумною поведінкою. ((робот)) міг би працювати ефективніше, якби пристосовував свою поведінку до реальної роботи, яку потрібно виконати.

{{індексний пошук шляху}}

Для цього він повинен мати можливість цілеспрямовано рухатися до певної посилки або до місця, де її потрібно доставити. Для цього, навіть якщо мета знаходиться на відстані більше одного ходу, потрібна певна функція пошуку маршруту.

Задача пошуку маршруту через ((граф)) є типовою _((задачею пошуку))_. Ми можемо сказати, чи є даний розв'язок (маршрут) допустимим, але ми не можемо безпосередньо обчислити розв'язок так, як ми могли б це зробити для 2 + 2. Замість цього ми повинні продовжувати створювати потенційні рішення, поки не знайдемо те, яке працює.

Кількість можливих маршрутів через граф нескінченна. Але при пошуку маршруту з _A_ в _B_ нас цікавлять лише ті, що починаються в _A_. Нас також не цікавлять маршрути, які двічі проходять через одне й те саме місце - це точно не найефективніший маршрут. Таким чином, ми зменшуємо кількість маршрутів, які має розглянути пошуковик маршрутів.

Насправді, оскільки нас здебільшого цікавить _найкоротший_ маршрут, ми хочемо переконатися, що ми розглядаємо короткі маршрути перед тим, як шукати довші. Хорошим підходом було б «вирощувати» маршрути від початкової точки, досліджуючи кожне доступне місце, яке ще не було відвідано, доки маршрут не досягне мети. Таким чином, ми досліджуватимемо лише потенційно цікаві маршрути, і ми знаємо, що перший знайдений нами маршрут буде найкоротшим (або одним з найкоротших, якщо їх більше одного).

{{index «findRoute function»}}

{{id findRoute}}

Ось функція, яка робить це:

```{includeCode: true}
function findRoute(graph, from, to) {
  let work = [{at: from, route: []}];
  for (let i = 0; i < work.length; i++) {
    let {at, route} = work[i];
    for (let place of graph[at]) {
      if (place == to) return route.concat(place);
      if (!work.some(w => w.at == place)) {
        work.push({at: place, route: route.concat(place)});
      }
    }
  }
}
```

Дослідження має відбуватися у правильному порядку - місця, які були досягнуті першими, мають бути досліджені першими. Ми не можемо одразу досліджувати місце, як тільки його досягнемо, тому що це означатиме, що місця, досягнуті _звідти_, також будуть досліджені одразу, і так далі, хоча можуть існувати інші, коротші шляхи, які ще не були досліджені.

Тому функція зберігає _((робочий список))_. Це масив місць, які слід дослідити наступними, разом з маршрутом, який привів нас туди. Пошук починається з початкової позиції і порожнього маршруту.

Потім пошук починається з наступного елемента у списку і досліджує його, тобто переглядає всі дороги, що ведуть з цього місця. Якщо одна з них є метою, можна повернути готовий маршрут. В іншому випадку, якщо ми не дивилися на це місце раніше, до списку додається новий пункт. Якщо ж ми вже переглядали це місце раніше, то, оскільки ми спочатку переглядаємо короткі маршрути, ми знайдемо або довший маршрут до цього місця, або такий самий довгий, як і існуючий, і нам не потрібно буде його досліджувати.

Ви можете уявити це як павутину відомих маршрутів, що виповзає з початкової точки, рівномірно розростаючись на всі боки (але ніколи не заплутуючись у собі). Як тільки перша нитка досягає місця призначення, вона повертається назад до старту, даючи нам наш маршрут.

{{index «connected graph»}}

Наш код не обробляє ситуацію, коли у списку робіт не залишилося жодної роботи, тому що ми знаємо, що наш граф є _зв'язним_, тобто до кожної локації можна дістатися з усіх інших локацій. Ми завжди зможемо знайти маршрут між двома точками, і пошук не може бути невдалим.

```{includeCode: true}
function goalOrientedRobot({місце, посилки}, маршрут) {
  if (route.length == 0) {
    let parcel = parcels[0];
    if (parcel.place != place) {
      route = findRoute(roadGraph, place, parcel.place);
    } else {
      route = findRoute(roadGraph, place, parcel.address);
    }
  }
  return { напрямок: route[0], пам'ять: route.slice(1)};
}
```

{{index «goalOrientedRobot function»}}

Цей робот використовує значення своєї пам'яті як список напрямків для руху, так само як і робот, що слідує за маршрутом. Щоразу, коли цей список порожній, він повинен вирішити, що робити далі. Він бере першу недоставлену посилку в наборі і, якщо її ще не забрали, прокладає маршрут до неї. Якщо ж посилку _забрали_, її все одно потрібно доставити, тому робот прокладає маршрут до адреси доставки.

{{якщо інтерактивний

Давайте подивимося, як це працює.

```{test: no, startCode: true}
runRobotAnimation(VillageState.random(),
                  goalOrientedRobot, []);
```

if}}

Зазвичай цей робот виконує завдання з доставки 5 посилок приблизно за 16 ходів. Це трохи краще, ніж `routeRobot`, але все ще не оптимально. Ми продовжимо вдосконалювати його у вправах.

## Вправи

### Вимірювання робота

{{index «вимірювання робота (вправа)», тестування, автоматизація, «функція compareRobots»}}

Важко об'єктивно порівняти роботів, просто давши їм розв'язати декілька сценаріїв. Можливо, одному з роботів просто пощастило отримати легші завдання або завдання, з якими він добре справляється, а іншому - ні.

Напишіть функцію `compareRobots`, яка бере двох роботів (і їх початкову пам'ять). Вона повинна згенерувати 100 задач і дозволити обом роботам розв'язати кожну з них. Після завершення роботи вона повинна вивести середню кількість кроків, яку зробив кожен робот на кожну задачу.

Заради справедливості, переконайтеся, що ви даєте кожну задачу обом роботам, а не генеруєте різні задачі для кожного робота.

{{if інтерактивний

```{test: no}
function compareRobots(robot1, memory1, robot2, memory2) {
  // Ваш код тут
}

compareRobots(routeRobot, [], goalOrientedRobot, []);
```
if}}

{{hint

{{index «вимірювання робота (вправа)», «функція runRobot»}}

Вам доведеться написати варіант функції `runRobot`, який замість того, щоб виводити події на консоль, повертає кількість кроків, зроблених роботом для виконання завдання.

Після цього ваша функція вимірювання може в циклі генерувати нові стани і підраховувати кроки, зроблені кожним з роботів. Коли вона згенерує достатню кількість вимірювань, вона може використовувати `console.log` для виведення середнього значення для кожного робота, яке дорівнює загальній кількості зроблених кроків, поділеній на кількість вимірювань.

підказка}}

### Ефективність робота

{{index «robot efficiency (exercise)»}}

Чи можете ви написати робота, який виконує завдання доставки швидше, ніж `goalOrientedRobot`? Якщо ви спостерігаєте за поведінкою цього робота, які очевидні дурниці він робить? Як їх можна покращити?

Якщо ви виконали попередню вправу, ви можете скористатися функцією `compareRobots`, щоб перевірити, чи покращили ви робота.

{{if інтерактивний

```{test: no}
// Ваш код тут

runRobotAnimation(VillageState.random(), yourRobot, memory);
```

if}}

{{hint

{{index «ефективність робота (вправа)»}}

Основним обмеженням `goalOrientedRobot` є те, що він розглядає лише одну посилку за раз. Він часто ходитиме туди-сюди по селу, тому що ділянка, на яку він дивиться, знаходиться на іншому кінці мапи, навіть якщо інші знаходяться набагато ближче.

Одним з можливих рішень може бути розрахунок маршрутів для всіх посилок, а потім вибір найкоротшого з них. Ще кращі результати можна отримати, якщо є кілька найкоротших маршрутів, віддавши перевагу тим, які йдуть забрати пакунок, а не доставити пакунок.

підказка}}

### Постійна група

{{index «persistent group (exercise)», «persistent data structure», «Set class», «set (data structure)», «Group class», «PGroup class»}}

Більшість структур даних, що надаються у стандартному середовищі JavaScript, не дуже добре підходять для постійного використання. Масиви мають методи `slice` та `concat`, які дозволяють легко створювати нові масиви, не пошкоджуючи старі. А от клас `Set`, наприклад, не має методів для створення нової множини з додаванням або вилученням елемента.

Напишіть новий клас `PGroup`, схожий на клас `Group` з [Глава ?](об'єкт#групи), який зберігає набір значень. Як і `Group`, він має методи `add`, `delete` і `has`. Однак метод `add` має повертати _новий_ екземпляр `PGroup` з доданим членом і залишати старий екземпляр без змін. Аналогічно, метод `delete` повинен створювати новий екземпляр без заданого члена.

Клас повинен працювати зі значеннями будь-якого типу, а не тільки з рядками. Він _не_ повинен бути ефективним при використанні з великою кількістю значень.

{{index [інтерфейс, об'єкт]}}

((конструктор)) не повинен бути частиною інтерфейсу класу (хоча ви, безумовно, захочете використовувати його всередині). Натомість існує порожній екземпляр `PGroup.empty`, який можна використовувати як початкове значення.

{{index singleton}}

Навіщо вам потрібне лише одне значення `PGroup.empty` замість того, щоб мати функцію, яка щоразу створює нову, порожню мапу?

{{if інтерактивний

```{test: no}}
class PGroup {
  // Ваш код тут
}

let a = PGroup.empty.add(«a»);
let ab = a.add(«b»);
let b = ab.delete(«a»);

console.log(b.has(«b»));
// → true
console.log(a.has(«b»));
// → false
console.log(b.has(«a»));
// → false
```

if}}

{{hint

{{index «persistent map (exercise)», «Set class», [array, creation], «PGroup class»}}

Найзручнішим способом представлення множини значень членів все ж таки є масив, оскільки масиви легко копіювати.

{{index «метод конкатенації», «метод фільтрації»}}

Коли значення додається до групи, ви можете створити нову групу з копією оригінального масиву, до якого додається значення (наприклад, за допомогою `concat`). Коли значення видаляється, ви фільтруєте його з масиву.

Конструктор класу може приймати такий масив як аргумент і зберігати його як (єдину) властивість екземпляра. Цей масив ніколи не оновлюється.

{{index «static property»}}

Щоб додати властивість `empty` до конструктора, ви можете оголосити її як статичну властивість.

Вам потрібен лише один екземпляр `empty`, оскільки всі порожні групи однакові і екземпляри класу не змінюються. Ви можете створити багато різних груп з однієї порожньої групи, не впливаючи на неї.

підказка}}
