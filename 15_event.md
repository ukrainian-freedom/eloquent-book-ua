# Обробка подій

{{quote {автор: «Марк Аврелій», title: Meditations, chapter: true}}

Ви маєте владу над своїм розумом, а не над зовнішніми подіями. Усвідомте це, і ви знайдете силу.

quote}}

{{index_stoicism, «Marcus Aurelius», input, timeline}}
{{figure {url: «img/chapter_picture_15.jpg», alt: «Ілюстрація із зображенням машини Руба Ґолдберґа, що складається з кульки, пилки, ножиць і молотка, які впливають одне на одного в ланцюговій реакції, що вмикає лампочку.», “chapter”, “image”, “alt”: »Ілюстрація із зображенням машини Руба Ґолдберґа: «Обрамлення"}}}.

Деякі програми працюють з прямим введенням даних користувачем, наприклад, за допомогою миші та клавіатури. Таке введення не можна передбачити заздалегідь, як добре організовану структуру даних - воно надходить по частинах, у реальному часі, і програма повинна реагувати на нього у міру надходження.

## Обробники подій

{{index polling, button, «real-time»}}

Уявіть собі інтерфейс, у якому єдиний спосіб дізнатися, чи натиснуто клавішу на ((клавіатурі)) - це прочитати поточний стан цієї клавіші. Щоб мати можливість реагувати на натискання клавіш, вам доведеться постійно зчитувати стан клавіші, щоб встигнути зловити натискання до того, як її знову буде відпущено. Було б небезпечно виконувати інші трудомісткі обчислення, оскільки ви могли б пропустити натискання клавіш.

Деякі примітивні машини обробляють ввід саме так. Наступним кроком є те, що апаратне забезпечення або операційна система помічають натискання клавіш і ставлять їх у чергу. Програма може періодично перевіряти чергу на наявність нових подій і реагувати на те, що вона там знаходить.

{{індекс чуйності, «користувацький досвід»}}

Звісно, програма повинна пам'ятати про перегляд черги, і робити це часто, оскільки будь-який час між натисканням клавіші та помічанням події програмою призведе до того, що програма не реагуватиме на неї. Такий підхід називається _((опитування))_. Більшість програмістів вважають за краще його уникати.

{{index «функція зворотного виклику», «обробка подій»}}

Кращим механізмом є активне сповіщення системою коду про виникнення події. Браузери роблять це, дозволяючи нам реєструвати функції як _обробники_ певних подій.

```{lang: html}
<p>Клікніть цей документ, щоб активувати обробник.</p>
<script>
  window.addEventListener(«click», () => {
    console.log(«Ви стукали?»);
  });
</script>
```

{{індекс «подія кліку», «метод addEventListener», «об'єкт вікна», [браузер, вікно]}}

Зв'язка `window` посилається на вбудований об'єкт, наданий браузером. Він представляє вікно браузера, яке містить документ. Виклик його методу `addEventListener` реєструє другий аргумент, який буде викликано щоразу, коли відбудеться подія, описана його першим аргументом.

## Події та DOM-вузли

{{index «addEventListener method», «event handling», «window object», browser, [DOM, events]}}

Кожен обробник подій браузера реєструється в контексті. У попередньому прикладі ми викликали `addEventListener` на об'єкті `window`, щоб зареєструвати обробник для всього вікна. Такий метод також можна знайти на DOM-елементах та деяких інших типах об'єктів. Слухачі подій викликаються тільки тоді, коли подія відбувається в контексті об'єкта, на якому вони зареєстровані.

```{lang: html}
<button>Клікни мене</button>
<p>Тут немає обробника.</p>
<скрипт
  let button = document.querySelector(«button»);
  button.addEventListener(«click», () => {})
    console.log(«Кнопка натиснута.»);
  });
</script>
```

{{index «click event», «button (HTML-тег)»}}

Цей приклад приєднує обробник до вузла button. Клацання на кнопці викликає запуск цього обробника, але клацання на решті частини документа не викликає.

{{index «onclick attribute», інкапсуляція}}

Надання вузлу атрибуту `onclick` має подібний ефект. Це працює для більшості типів подій - ви можете приєднати обробник через атрибут, ім'я якого є назвою події з `on` перед ним.

Але вузол може мати лише один атрибут `onclick`, тому ви можете зареєструвати лише один обробник на вузол у такий спосіб. Метод `addEventListener` дозволяє додавати будь-яку кількість обробників, тобто безпечно додавати обробники, навіть якщо на елементі вже є інший обробник.

{{index «removeEventListener method»}}

Метод `removeEventListener`, викликаний з аргументами, подібними до `addEventListener`, видаляє обробник.

```{lang: html}
<button>Кнопка однократної дії</button>
<скрипт
  let button = document.querySelector(«button»);
  function once() {
    console.log(«Виконано.»);
    button.removeEventListener(«click», once);
  }
  button.addEventListener(«click», once);
</script>
```

{{index [function, «as value»]}}

Функція, що передається в `removeEventListener`, має бути тим самим значенням функції, що передається в `addEventListener`. Якщо вам потрібно скасувати реєстрацію обробника, вам слід надати функції-обробнику ім'я (у прикладі `once`), щоб мати змогу передати те саме значення функції до обох методів.

## Об'єкти подій

{{index «властивість кнопки», «обробка подій»}}

Хоча ми досі ігнорували це, функціям обробників подій передається аргумент:  об'єкт _((об'єкт події))_. Цей об'єкт містить додаткову інформацію про подію. Наприклад, якщо ми хочемо дізнатися, _яка_ ((кнопка миші)) була натиснута, ми можемо подивитися на властивість `button` об'єкта події.

```{lang: html}
<button>Клікніть мене як завгодно</button>
<script>
  let button = document.querySelector(«button»);
  button.addEventListener(«mousedown», event => {})
    if (event.button == 0) {
      console.log(«Ліва кнопка»);
    } else if (event.button == 1) {
      console.log(«Середня кнопка»);
    } else if (event.button == 2) {
      console.log(«Права кнопка»);
    }
  });
</script>
```

{{індекс «тип події», «властивість типу»}}

Інформація, що зберігається в об'єкті події, відрізняється залежно від типу події. (Ми обговоримо різні типи пізніше у цій главі.) Властивість `type` об'єкта завжди містить рядок, що ідентифікує подію (наприклад, `«click»` або `«mousedown»`).

## Поширення

{{index «event propagation», «parent node»}}

{{indexsee bubbling, «event propagation»}}

{{indexsee propagation, «event propagation»}}

Для більшості типів подій обробники, зареєстровані на дочірніх вузлах, також отримуватимуть події, що відбуваються у дочірніх вузлах. Якщо натиснуто кнопку всередині абзацу, обробники подій у цьому абзаці також побачать подію натискання.

{{index «обробка подій»}}

Але якщо і абзац, і кнопка мають обробник, то більш специфічний обробник - той, що на кнопці, - буде оброблений першим. Кажуть, що подія _поширюється_ назовні від вузла, де вона сталася, до батьківського вузла цього вузла і далі до кореня документа. Нарешті, після того, як всі обробники, зареєстровані на певному вузлі, дочекалися своєї черги, обробники, зареєстровані на всьому документі ((вікні)), отримують можливість відреагувати на подію.

{{index «stopPropagation method», «click event»}}

У будь-який момент обробник події може викликати метод `stopPropagation` на об'єкті події, щоб запобігти отриманню події обробниками, зареєстрованими вище. Це може бути корисно, коли, наприклад, у вас є кнопка всередині іншого елемента, на який можна натиснути, і ви не хочете, щоб натискання на кнопку активувало поведінку натискання на зовнішньому елементі.

{{index «mousedown event», «pointer event»}}

У наступному прикладі реєструються обробники події «наведення миші» як для кнопки, так і для абзацу навколо неї. При натисканні правою кнопкою миші обробник для кнопки викликає `stopPropagation`, який зупиняє виконання обробника для абзацу. При натисканні кнопки іншою кнопкою миші (кнопка миші) будуть запущені обидва обробники.

```{lang: html}
<p>Абзац з кнопкою <button>button</button>.</p>
<script>
  let para = document.querySelector(«p»);
  let button = document.querySelector(«button»);
  para.addEventListener(«mousedown», () => {})
    console.log(«Обробник для пункту.»);
  });
  button.addEventListener(«mousedown», event => {}); button.addEventListener(«mousedown», event => {})
    console.log(«Обробник для кнопки.»);
    if (event.button == 2) event.stopPropagation();
  });
</script>
```

{{index «propagation», «target property»}}

Більшість об'єктів подій мають властивість `target`, яка посилається на вузол, де вони виникли. Ви можете використовувати цю властивість, щоб переконатися, що ви випадково не обробляєте щось, що поширилося з вузла, який ви не хочете обробляти.

Також можна використовувати властивість `target`, щоб закинути широку мережу для певного типу подій. Наприклад, якщо у вас є вузол, що містить довгий список кнопок, може бути зручніше зареєструвати обробник одного кліку на зовнішньому вузлі і змусити його використовувати властивість `target` для визначення того, чи була натиснута кнопка, ніж реєструвати окремі обробники для всіх кнопок.

```{lang: html}
<button>A</button>
<button>B</button>
<button>C</button>
<script>
  document.body.addEventListener(«click», event => {
    if (event.target.nodeName == «BUTTON») {
      console.log(«Clicked», event.target.textContent);
    }
  });
</script>
```

## Дії за замовчуванням

{{прокрутка індексу, «поведінка за замовчуванням», «обробка подій»}}

Багато подій мають дію за замовчуванням. Якщо ви натиснете кнопку ((посилання)), вас буде перенаправлено на цільове посилання. Якщо ви натиснете стрілку вниз, браузер прокрутить сторінку вниз. Якщо ви натиснете правою кнопкою миші, ви отримаєте контекстне меню. І так далі.

{{index «preventDefault method»}}

Для більшості типів подій обробники подій JavaScript викликаються _до_ того, як відбудеться поведінка за замовчуванням. Якщо обробник не хоче, щоб відбувалася ця нормальна поведінка, зазвичай тому, що він вже подбав про обробку події, він може викликати метод `preventDefault` на об'єкті події.

{{Очікування індексу}}

Це може бути використано для реалізації ваших власних ((клавіатурних)) комбінацій клавіш або ((контекстного меню)). Він також може бути використаний для неприємного втручання у поведінку, яку очікують користувачі. Наприклад, ось посилання, за яким неможливо перейти:

```{lang: html}
<a href=«https://developer.mozilla.org/»>MDN</a>
<скрипт
  let link = document.querySelector(«a»);
  link.addEventListener(«click», event => {})
    console.log(«Nope.»);
    event.preventDefault();
  });
</script>
```

{{індекс юзабіліті}}

Намагайтеся не робити такі речі без дійсно вагомої причини. Людям, які користуються вашою сторінкою, буде неприємно, коли очікувана поведінка буде порушена.

Залежно від браузера, деякі події взагалі неможливо перехопити. У Chrome, наприклад, комбінація клавіш ((клавіатура)) для закриття поточної вкладки ([ctrl]{ім'я}-W або [command]{ім'я}-W) не може бути оброблена JavaScript.

## Ключові події

{{індекс клавіатури, «подія натискання клавіші», «подія натискання клавіші», «обробка подій»}}

Коли натискається клавіша на клавіатурі, ваш браузер генерує подію «натискання клавіші». Коли клавішу відпускається, відбувається подія ``keyup``.

```{lang: html, focus: true}
<p>Ця сторінка стає фіолетовою, коли ви утримуєте клавішу V.</p>
<script>
  window.addEventListener(«keydown», event => {
    if (event.key == «v») {
      document.body.style.background = «violet»;
    }
  });
  window.addEventListener(«keyup», event => {
    if (event.key == «v») {
      document.body.style.background = «»;
    }
  });
</script>
```

{{index «repeating key»}}

Незважаючи на свою назву, `«натискання клавіші»` спрацьовує не лише тоді, коли клавішу фізично натиснуто. Коли клавішу натиснуто і утримується, подія спрацьовує знову щоразу, коли клавіша _повторюється_. Іноді з цим потрібно бути обережним. Наприклад, якщо ви додаєте кнопку до DOM, коли натиснуто клавішу, і видаляєте її, коли клавішу відпускається, ви можете випадково додати сотні кнопок, якщо утримувати клавішу натиснутою довше.

{{index «key property»}}

У попередньому прикладі ми розглядали властивість `key` об'єкта події, щоб дізнатися, про яку клавішу йдеться у події. Ця властивість містить рядок, який для більшості клавіш відповідає тому, що буде введено при натисканні цієї клавіші. Для спеціальних клавіш, таких як [enter]{назва клавіші}, ця властивість містить рядок з назвою клавіші (у цьому випадку `«Enter»`). Якщо під час натискання клавіші утримувати [shift]{назва клавіші}, це також може вплинути на назву клавіші - `«v»` стане `«V»`, а `«1»` може стати `«!»`, якщо натискання [shift]{назва клавіші}-1 призведе до такого результату на вашій клавіатурі.

{{index «клавіша-модифікатор», «клавіша shift», «клавіша керування», «клавіша alt», «метаклавіша», «командна клавіша», «властивість ctrlKey», «властивість shiftKey», «властивість altKey», «властивість metaKey»}}

Клавіші-модифікатори, такі як [shift]{назва клавіші}, [ctrl]{назва клавіші}, [alt]{назва клавіші} та [meta]{назва клавіші} ([command]{назва клавіші} на Mac) генерують події клавіш так само, як і звичайні клавіші. Під час пошуку комбінацій клавіш ви також можете дізнатися, чи утримуються ці клавіші натиснутими, переглянувши властивості `shiftKey`, `ctrlKey`, `altKey` та `metaKey` подій клавіатури та миші.

```{lang: html, focus: true}
<p>Для продовження натисніть клавішу Control-Space.
<script>
  window.addEventListener(«keydown», event => {
    if (event.key == « » && event.ctrlKey) {
      console.log(«Продовжуємо!»);
    }
  });
</script>
```

{{index «button (HTML-тег)», «атрибут tabindex», [DOM, events]}}

Вузол DOM, в якому відбувається подія натискання клавіші, залежить від елемента, який має ((focus)) при натисканні клавіші. Більшість вузлів не можуть мати фокус, якщо ви не надасте їм атрибут `tabindex`, але такі елементи, як ((link)), кнопки та поля форм можуть. Ми повернемося до форми ((поле))s у [Главі ?] (http#forms). Коли ні на чому конкретному не сфокусовано увагу, `document.body` діє як цільовий вузол ключових подій.

Коли користувач вводить текст, використання ключових подій для визначення того, що саме вводиться, є проблематичним. Деякі платформи, зокрема віртуальна клавіатура на ((Android)) ((телефоні)), не генерують ключові події. Але навіть якщо у вас старомодна клавіатура, деякі типи введення тексту не відповідають натисканням клавіш у прямому сенсі, наприклад, _редактор методів введення_ (_((IME))_) програмне забезпечення, яке використовують люди, чиї сценарії не вміщуються на клавіатурі, де для створення символів комбінується кілька натискань клавіш.

Щоб помітити, коли щось було введено, елементи, у які можна вводити дані, такі як теги `<input>` та `<textarea>`, викликають подію `«input»` щоразу, коли користувач змінює їхній вміст. Щоб отримати фактичний вміст, який було введено, найкраще безпосередньо прочитати його з сфокусованого поля, що ми обговорюємо у [Розділ ?](http#forms).

## Події з вказівниками

Наразі існує два широко використовувані способи вказівки на об'єкти на екрані: миша (включно з пристроями, що діють як миші, наприклад, тачпади та трекболи) та сенсорні екрани. Вони спричиняють різні типи подій.

### Клацання мишею

{{індекс «подія при натисканні кнопки миші», «подія при наведенні курсору миші», «курсор миші»}}

Натискання ((кнопки миші)) спричиняє низку подій. Події «mousedown»` і «mouseup»` подібні до подій «keydown»` і «keyup»` і спрацьовують, коли кнопку натиснуто і відпущено. Вони відбуваються у вузлах DOM, які знаходяться безпосередньо під вказівником миші, коли відбувається подія.

{{index «click event»}}

Після події `«mouseup»` відбувається подія `«click»` на конкретному вузлі, на якому відбулося і натискання, і відпускання кнопки. Наприклад, якщо я натисну кнопку миші на одному абзаці, а потім переміщу вказівник на інший абзац і відпущу кнопку, подія `«click»` відбудеться на елементі, який містить обидва ці абзаци.

{{index «dblclick event», «подвійне клацання»}}

Якщо два кліки відбуваються близько один до одного, то після другого кліку також відбувається подія `«dblclick»` (подвійний клік).

{{index pixel, «clientX property», «clientY property», «pageX property», «pageY property», «event object»}}

Для отримання точної інформації про місце, де відбулася подія миші, можна подивитися на її властивості `clientX` та `clientY`, які містять координати події (у пікселях) відносно лівого верхнього кута вікна, або `pageX` та `pageY`, які відносяться до лівого верхнього кута всього документа (які можуть відрізнятися при прокручуванні вікна).

{{index «border-radius (CSS)», «абсолютне позиціонування», «приклад програми малювання»}}

{{id mouse_drawing}}

Наступна програма реалізує примітивну програму малювання. Кожного разу, коли ви клацаєте на документі, вона додає крапку під вказівником миші.

```{lang: html}
<style>
  body {
    height: 200px;
    background: beige;
  }
  .dot {
    height: 8px; width: 8px;
    border-radius: 4px; /* закруглює кути */
    background: teal;
    position: absolute;
  }
</style> </style
<script>
  window.addEventListener(«click», event => {})
    нехай dot = document.createElement(«div»);
    dot.className = «dot»;
    dot.style.left = (event.pageX - 4) + «px»;
    dot.style.top = (event.pageY - 4) + «px»;
    document.body.appendChild(dot);
  });
</script>
```

Ми створимо менш примітивний додаток для малювання у [Глава ?](paint).

### Рух миші

{{index «mousemove event»}}

Кожного разу, коли вказівник миші рухається, відбувається подія ``mousemove``. Цю подію можна використовувати для відстеження положення миші. Типовою ситуацією, у якій це може бути корисно, є реалізація певної форми функціональності миші-((перетягування)).

{{index «draggable bar example»}}

Як приклад, у наступній програмі показано смужку і налаштовано обробники подій таким чином, що перетягування ліворуч або праворуч на цій смужці робить її вужчою або ширшою:

```{lang: html, startCode: true}
<p>Перетягніть смугу, щоб змінити її ширину:</p> <p>Перетягніть смугу, щоб змінити її ширину
<div style=«background: orange; width: 60px; height: 20px»>
</div> </div> </div> </div> </div> </div
<script>
  let lastX; // Відстежує останню зафіксовану позицію мишки по X
  let bar = document.querySelector(«div»);
  bar.addEventListener(«mousedown», event => {})
    if (event.button == 0) {
      lastX = event.clientX;
      window.addEventListener(«mousemove», moved);
      event.preventDefault(); // Заборонити вибір
    }
  });

  function moved(event) {
    if (event.buttons == 0) {
      window.removeEventListener(«mousemove», moved);
    } else {
      let dist = event.clientX - lastX;
      let newWidth = Math.max(10, bar.offsetWidth + dist);
      bar.style.width = newWidth + «px»;
      lastX = event.clientX;
    }
  }
</script> </span> </span> </span> </span> </span>.
```

{{if book

Результуюча сторінка виглядає наступним чином:

{{figure {url: «img/drag-bar.png», alt: «Зображення панелі, що перетягується», width: “5.3cm”}}}}

if}}

{{index «mouseup event», «mousemove event»}}

Зверніть увагу, що обробник `«mousemove»` реєструється на все вікно ((вікно)). Навіть якщо під час зміни розміру миша вийде за межі панелі, ми все одно хочемо оновити розмір кнопки, доки вона утримується натиснутою.

{{index «buttons property», «button property», «bitfield»}}

Ми повинні зупинити зміну розміру смуги, коли кнопку миші буде відпущено. Для цього ми можемо використати властивість `buttons` (зверніть увагу на множину), яка повідомляє нам про кнопки, які наразі утримуються натиснутими. Коли вона дорівнює 0, жодної кнопки не натиснуто. Коли кнопки натиснуто, значення властивості `buttons` дорівнює сумі кодів цих кнопок - ліва кнопка має код 1, права - 2, а середня - 4. Наприклад, якщо утримувати ліву та праву кнопки, значення властивості `buttons` буде 3.

Зверніть увагу, що порядок цих кодів відрізняється від того, який використовувався для `button`, де середня кнопка йшла перед правою. Як вже було сказано, послідовність не є сильною стороною інтерфейсу програмування браузера.

### Події дотику

{{індекс дотику, «подія наведення миші», «подія наведення миші», «подія клацання»}}

Стиль графічного браузера, який ми використовуємо, був розроблений з урахуванням інтерфейсів миші, в той час, коли сенсорні екрани були рідкістю. Щоб змусити Інтернет «працювати» на ранніх телефонах з сенсорним екраном, браузери для цих пристроїв певною мірою вдавали, що події дотику є подіями миші. Якщо ви торкнетеся екрана, то отримаєте події «наведення миші», «наведення миші» і «клацання».

Але ця ілюзія не дуже надійна. Сенсорний екран працює не так, як миша: він не має декількох кнопок, ви не можете відстежувати палець, коли його немає на екрані (щоб імітувати «рух миші»), і він дозволяє декільком пальцям перебувати на екрані одночасно.

Події миші покривають сенсорну взаємодію лише у простих випадках - якщо ви додасте обробник «клацання» до кнопки, користувачі сенсорного вводу все одно зможуть нею користуватися. Але щось на кшталт смуги зі змінним розміром у попередньому прикладі не працює на сенсорному екрані.

{{index «touchstart event», «touchmove event», «touchend event»}}

Існують певні типи подій, які запускаються при взаємодії з дотиком. Коли палець починає торкатися екрана, виникає подія «початок торкання». Якщо палець рухається під час торкання, відбувається подія «дотик-переміщення».  Нарешті, коли палець припиняє торкатися екрана, ви побачите подію ``touchnd``.

{{index «touches property», «clientX property», «clientY property», «pageX property», «pageY property»}}

Оскільки багато сенсорних екранів можуть розпізнавати кілька пальців одночасно, ці події не мають єдиного набору координат, пов'язаних з ними. Натомість, їхні ((об'єкт події)) мають властивість `touch`, яка містить ((масивний об'єкт)) точок, кожна з яких має власні властивості `clientX`, `clientY`, `pageX` та `pageY`.

Ви можете зробити щось на кшталт цього, щоб показати червоні кола навколо кожного дотику пальця:

```{lang: html}
<style>
  dot { position: absolute; display: block;
        border: 2px solid red; border-radius: 50px;
        height: 100px; width: 100px; }
</style> </style> </style> </style> </style> </style> </style
<p>Доторкніться до цієї сторінки</p>
<скрипт
  function update(event) {
    for (let dot; dot = document.querySelector(«dot»);) {
      dot.remove();
    }
    for (let i = 0; i < event.touches.length; i++) {
      let {pageX, pageY} = event.touches[i];
      let dot = document.createElement(«dot»);
      dot.style.left = (pageX - 50) + «px»;
      dot.style.top = (pageY - 50) + «px»;
      document.body.appendChild(dot);
    }
  }
  window.addEventListener(«touchstart», update);
  window.addEventListener(«touchmove», update);
  window.addEventListener(«touchend», update);
</script> </script> </script> </script> </script> </script> <
```

{{index «preventDefault method»}}

Вам часто буде потрібно викликати `preventDefault` в обробниках подій дотику, щоб перевизначити поведінку браузера за замовчуванням (яка може включати прокрутку сторінки при свайпі) і запобігти спрацьовуванню подій миші, для яких  також може бути передбачено обробник.

## Події прокрутки

{{index scrolling, «scroll event», «event handling»}}

Щоразу, коли елемент прокручується, для нього викликається подія ``прокрутки``. Це має різні застосування, наприклад, щоб знати, на що користувач наразі дивиться (для вимкнення позаекранної ((анімації)) або надсилання ((шпигунських)) звітів до вашого злого штабу), або для відображення певних ознак прогресу (виділяючи частину змісту або показуючи номер сторінки).

У наступному прикладі над документом намальовано ((індикатор виконання)), який оновлюється, заповнюючись при прокручуванні вниз:

```{lang: html}
<style>
  #progress {
    border-bottom: 2px solid blue;
    width: 0;
    position: fixed;
    top: 0; left: 0;
  }
</style> </style
<div id=«progress»></div></div>
<script>
  // Створюємо деякий вміст
  document.body.appendChild(document.createTextNode(
    «supercalifragilisticexpialidocious «.repeat(1000)));

  let bar = document.querySelector(«#progress»);
  window.addEventListener(«scroll», () => {} window.addEventListener(«scroll», () => {})
    let max = document.body.scrollHeight - innerHeight;
    bar.style.width = `${(pageYOffset / max) * 100}%`;
  });
</script>
```

{{index «unit (CSS)», scrolling, «position (CSS)», «fixed positioning», «absolute positioning», percentage, «repeat method»}}

Надання елементу `позиції` `фіксованої` діє подібно до `абсолютної` позиції, але також запобігає його прокручуванню разом з рештою документа. Внаслідок цього наша смужка прогресу залишиться зверху. Його ширина змінюється для відображення поточного прогресу. Ми використовуємо `%`, а не `px`, як одиницю при встановленні ширини, щоб розмір елемента залежав від ширини сторінки.

{{index «властивість innerHeight», «властивість innerWidth», «властивість pageYOffset»}}

Глобальна прив'язка `innerHeight` дає нам висоту вікна, яку ми повинні відняти від загальної висоти прокрутки - ви не можете продовжувати прокрутку, коли досягаєте нижньої частини документа. Існує також прив'язка `innerWidth` для ширини вікна. Поділивши `pageYOffset`, поточну позицію прокрутки, на максимальну позицію прокрутки і помноживши на 100, ми отримаємо відсоток для смужки прогресу.

{{index «preventDefault method»}}

Виклик методу `preventDefault` на подію прокрутки не зупиняє прокрутку. Насправді, обробник події викликається лише _після_ прокрутки.

## Події фокусування

{{index «event handling», «focus event», «blur event»}}

Коли елемент отримує фокус ((focus)), браузер генерує подію `«focus»` для нього. Коли елемент втрачає фокус, він отримує подію «розмиття».

{{index «event propagation»}}

На відміну від подій, розглянутих раніше, ці дві події не поширюються. Обробник батьківського елемента не отримує повідомлення, коли дочірній елемент отримує або втрачає фокус.

{{index «input (HTML-тег)», «help text example»}}

У наступному прикладі показано текст довідки для ((текстового поля)), на якому наразі встановлено фокус:

```{lang: html}
<p>Назва: <input type=«text» data-help=«Ваше повне ім'я»></p></p> <input type=«text» data-help=«Ваше повне ім'я»></p>
<p>Вік: <input type=«text» data-help=«Ваш вік у роках»></p> </p>
<p id=«help»></p> <p id=«help»></p>

<скрипт
  let help = document.querySelector(«#help»);
  let fields = document.querySelectorAll(«input»);
  for (let field of Array.from(fields)) {
    field.addEventListener(«focus», event => {
      let text = event.target.getAttribute(«data-help»);
      help.textContent = text;
    });
    field.addEventListener(«blur», event => {
      help.textContent = «»;
    });
  }
</script>
```

{{if book

На цьому знімку екрана показано текст довідки для поля віку:

{{figure {url: «img/help-field.png», alt: «Скріншот довідкового тексту під полем віку», width: “4.4cm”}}}}

if}}

{{index «focus event», «blur event»}}

Об'єкт ((window)) отримуватиме події «фокус» та «розмиття», коли користувач переходить з або до вкладки або вікна браузера, у якому показано документ.

## Подія завантаження

{{index «script (HTML-тег)», «load event»}}

Коли сторінка завершує завантаження, у вікні та об'єктах тіла документа спрацьовує подія `«load»`. Це часто використовується для планування ((ініціалізації)) дій, які вимагають побудови всього ((документа)). Пам'ятайте, що вміст тегів `<script>` виконується одразу після зустрічі з тегом. Це може бути занадто рано, наприклад, коли скрипту потрібно зробити щось з частинами документа, які з'являються після тегу `<script>`.

{{index «event propagation», «img (HTML-тег)»}}

Такі елементи, як ((image))s та теги скриптів, які завантажують зовнішній файл, також мають подію `«load»`, яка вказує на те, що файли, на які вони посилаються, було завантажено. Як і події, пов'язані з фокусом, події завантаження не поширюються.

{{index «beforeunload event», «page reload», «preventDefault method»}}

Коли ви закриваєте сторінку або переходите з неї (наприклад, за посиланням), відбувається подія `«beforeunload»`. Основне призначення цієї події - запобігти випадковій втраті роботи користувача при закритті документа. Якщо ви відвернете поведінку за замовчуванням для цієї події _і_ встановите властивість `returnValue` об'єкта події у значення рядок, браузер покаже користувачеві діалогове вікно із запитом про те, чи дійсно він хоче залишити сторінку. Це діалогове вікно може містити ваш рядок, але оскільки деякі шкідливі сайти намагаються використовувати ці діалогові вікна, щоб заплутати користувачів і змусити їх залишитися на сторінці, щоб переглянути нечесну рекламу про схуднення, більшість браузерів більше не показують їх.

{{id timeline}}

## Події та цикл обробки подій

{{index «requestAnimationFrame function», «event handling», timeline, «script (HTML tag)»}}

У контексті циклу обробки подій, як описано у [Розділ ?](async), обробники подій браузера поводяться подібно до інших асинхронних сповіщень. Вони запускаються за розкладом, коли відбувається подія, але повинні дочекатися завершення інших запущених скриптів, перш ніж вони отримають шанс на запуск.

Той факт, що події можуть бути оброблені тільки тоді, коли більше нічого не виконується, означає, що якщо цикл обробки подій пов'язаний з іншою роботою, будь-яка взаємодія зі сторінкою (яка відбувається через події) буде відкладена до тих пір, поки не з'явиться час на її обробку. Отже, якщо ви заплануєте занадто багато роботи, або з довготривалими обробниками подій, або з великою кількістю короткотривалих, сторінка стане повільною і громіздкою у використанні.

Для випадків, коли ви _дуже_ хочете виконати якусь трудомістку роботу у фоновому режимі, не заморожуючи сторінку, браузери надають дещо, що називається _((web worker))s_. Робочий процес - це JavaScript-процес, який виконується паралельно з основним сценарієм, на власній часовій шкалі.

Уявіть, що піднесення числа до квадрату - це важке, довготривале обчислення, яке ми хочемо виконати в окремому ((потоці)). Ми можемо написати файл під назвою `code/squareworker.js`, який відповідатиме на повідомлення, обчислюючи квадрат і надсилаючи повідомлення назад.

```
addEventListener(«message», event => {
  postMessage(event.data * event.data);
});
```

Щоб уникнути проблем, пов'язаних з тим, що декілька ((потоків)) звертаються до одних і тих самих даних, робітники не надають спільного доступу до своїх ((глобальної області видимості)) або будь-яких інших даних оточенню основного скрипта. Натомість, вам доводиться спілкуватися з ними, надсилаючи повідомлення туди і назад.

Цей код породжує робітника, який запускає цей скрипт, надсилає йому кілька повідомлень і виводить відповіді.

```{test: no}
let squareWorker = new Worker(«code/squareworker.js»);
squareWorker.addEventListener(«message», event => {})
  console.log(«Працівник відповів:», event.data);
});
squareWorker.postMessage(10);
squareWorker.postMessage(24);
```

{{index «postMessage method», «message event»}}

Функція `postMessage` надсилає повідомлення, яке викликає подію `«message»` у приймачі. Скрипт, який створив працівника, надсилає та отримує повідомлення через об'єкт `Worker`, тоді як працівник спілкується зі скриптом, який його створив, надсилаючи та слухаючи безпосередньо у його ((глобальній області видимості)). Як повідомлення можна надсилати лише значення, які можна представити у форматі JSON - інша сторона отримає їхню _копію_, а не саме значення.

## Таймери

{{index timeout, «функція setTimeout», «функція clearTimeout»}}

Функція `setTimeout`, яку ми розглядали у [Розділі ?](async), планує виклик іншої функції пізніше, через задану кількість мілісекунд. Іноді вам потрібно скасувати заплановану функцію. Ви можете зробити це, зберігши значення, повернуте `setTimeout`, і викликавши для нього `clearTimeout`.

```
let bombTimer = setTimeout(() => {}}.
  console.log(«BOOM!»);
}, 500);

if (Math.random() < 0.5) { // ймовірність 50%
  console.log(«Знешкоджено.»);
  clearTimeout(bombTimer);
}
```

{{index «cancelAnimationFrame function», «requestAnimationFrame function»}}

Функція `cancelAnimationFrame` працює так само, як і `clearTimeout`. Її виклик для значення, повернутого функцією `requestAnimationFrame`, скасує цей кадр (за умови, що його ще не було викликано).

{{index «setInterval function», «clearInterval function», repetition}}

Подібний набір функцій `setInterval` та `clearInterval` використовується для встановлення таймерів, які мають повторюватися кожні _X_ мілісекунд.

```
let ticks = 0;
let clock = setInterval(() => {}}
  console.log(«tick», ticks++);
  if (ticks == 10) {
    clearInterval(clock);
    console.log(«stop.»);
  }
}, 200);
```

## Дебаунсинг

{{оптимізація індексу, «подія переміщення миші», «подія прокрутки», блокування}}

Деякі типи подій можуть швидко спрацьовувати багато разів поспіль, наприклад, події ``mousemove`` та ``scroll``. При обробці таких подій ви повинні бути обережними і не робити нічого надто довготривалого, інакше ваш обробник забиратиме так багато часу, що взаємодія з документом почне здаватися повільною.

{{index «функція setTimeout»}}

Якщо вам потрібно зробити щось нетривіальне у такому обробнику, ви можете використати `setTimeout`, щоб переконатися, що ви не робите це занадто часто. Зазвичай це називається _((дебаунсинг))_ події. Існує декілька дещо різних підходів до цього.

{{index «textarea (HTML-тег)», «функція clearTimeout», «подія натискання клавіші»}}

Наприклад, припустимо, що ми хочемо реагувати, коли користувач щось ввів, але не хочемо робити це негайно на кожну подію введення. Коли користувач вводить щось швидко, ми просто хочемо дочекатися паузи. Замість того, щоб негайно виконувати дію в обробнику події, ми встановлюємо таймаут. Ми також очистимо попередній таймаут (якщо такий є), щоб коли події відбудуться близько одна до одної (ближче, ніж наша затримка таймауту), таймаут від попередньої події буде скасовано.

```{lang: html}
<textarea>Наберіть щось тут...</textarea>
<script>
  let textarea = document.querySelector(«textarea»);
  let timeout;
  textarea.addEventListener(«input», () => {})
    clearTimeout(timeout);
    timeout = setTimeout(() => console.log(«Введено!»), 500);
  });
</script>
```

{{index «неохайне програмування»}}

Надання невизначеного значення функції `clearTimeout` або її виклик під час таймауту, який вже закінчився, не має жодного ефекту. Таким чином, нам не потрібно дбати про те, коли викликати цю функцію, і ми просто робимо це для кожної події.

{{index «mousemove event»}}

Ми можемо використовувати дещо інший шаблон, якщо ми хочемо розмістити відповіді так, щоб вони були розділені принаймні певним інтервалом ((часу)), але хочемо запускати їх _під час_ серії подій, а не одразу після них. Наприклад, ми можемо захотіти реагувати на події ``mousemove`` показом поточних координат миші, але лише кожні 250 мілісекунд.

```{lang: html}
<script>
  нехай scheduled = null;
  window.addEventListener(«mousemove», event => {
    if (!scheduled) {
      setTimeout(() => {
        document.body.textContent =
          `Наведення миші на ${scheduled.pageX}, ${scheduled.pageY}`;
        scheduled = null;
      }, 250);
    }
    scheduled = event;
  });
</script>
```

## Підсумок

Обробники подій дозволяють виявляти події, що відбуваються на нашій веб-сторінці, та реагувати на них. Для реєстрації такого обробника використовується метод `addEventListener`.

Кожна подія має тип («натискання клавіші»`, «фокус»` і так далі), який її ідентифікує. Більшість подій викликаються на конкретному елементі DOM, а потім поширюються на предків цього елемента, дозволяючи обробникам, пов'язаним з цими елементами, обробляти їх.

Коли викликається обробник події, йому передається об'єкт події з додатковою інформацією про подію. Цей об'єкт також має методи, які дозволяють зупинити подальше поширення (`stopPropagation`) і запобігти обробці події браузером за замовчуванням (`preventDefault`).

Натискання клавіші викликає події `keydown` та `keyup`. Натискання кнопки миші спричиняє події `mousedown`, `mousedup` та `click`. Переміщення миші спричиняє події «mousemove»`. Взаємодія з сенсорним екраном призводить до подій «touchstart», «touchmove» і «touchend».

Прокручування можна виявити за допомогою події «scroll», а зміну фокусу - за допомогою подій «focus» і «blur». Коли документ завершує завантаження, у вікні з'являється подія ``load``.

## Вправи

### Повітряна кулька

{{index «balloon (вправа)», «стрілка»}}

Напишіть сторінку, яка відображає ((повітряну кульку)) (використовуючи повітряну кульку ((емодзі)), 🎈). Коли ви натискаєте стрілку вгору, вона має надутися (вирости) на 10 відсотків. Коли ви натискаєте стрілку вниз, вона повинна здутися (зменшитися) на 10 відсотків.

{{index «font-size (CSS)»}}

Ви можете керувати розміром тексту (емодзі - це текст), встановивши властивість CSS `font-size` (`style.fontSize`) для його батьківського елемента. Не забудьте вказати одиницю виміру, наприклад, пікселі (`10px`).

Назви клавіш зі стрілками - `«ArrowUp»` та `«ArrowDown»`. Переконайтеся, що клавіші змінюють лише кульку, не прокручуючи сторінку.

Після того, як ви переконаєтеся, що все працює, додайте функцію, за якою, якщо ви надуєте кульку більше певного розміру, вона «вибухне». У цьому випадку вибух означає, що вона замінюється на емодзі 💥, а обробник події видаляється (щоб ви не могли надути або здути вибух).

{{якщо інтерактивний

```{test: no, lang: html, focus: yes}}
<p>🎈</p>

<script>
  // Ваш код тут
</script>
```

if}}

{{hint

{{index «keydown event», «key property», «balloon (exercise)»}}

Вам слід зареєструвати обробник події `«натискання клавіші»` і переглядати `event.key`, щоб визначити, яку клавішу зі стрілкою вгору або вниз було натиснуто.

Поточний розмір можна зберегти у прив'язці, щоб ви могли на його основі визначити новий розмір. Буде корисно визначити функцію, яка оновлює розмір - як прив'язку, так і стиль кульки у DOM, - щоб ви могли викликати її з обробника події, а також, можливо, один раз під час запуску, щоб встановити початковий розмір.

{{index «replaceChild метод», «textContent властивість»}}

Ви можете змінити кульку на вибух, замінивши текстову вершину на іншу (за допомогою методу `replaceChild`) або встановивши властивість `textContent` її батьківської вершини на новий рядок.

підказка}}

### Слід миші

{{index animation, «слід миші (вправа)»}}

На початку розвитку JavaScript, а це був час яскравих домашніх сторінок з великою кількістю анімованих зображень, люди придумали кілька дійсно надихаючих способів використання мови. Одним з них був _слід миші_- серія елементів, які слідували за вказівником миші, коли ви переміщували його по сторінці.

{{index «absolute positioning», «background (CSS)»}}

У цій вправі я хочу, щоб ви реалізували слід миші. Використовуйте абсолютно позиціоновані елементи `<div>` з фіксованим розміром і кольором фону (див. приклад [code](event#mouse_drawing) у розділі «Клацання мишею»). Створіть групу таких елементів і, коли миша рухається, відображайте їх слідом за вказівником миші.

{{index «mousemove event»}}

Тут можливі різні підходи. Ви можете зробити свій слід настільки простим або складним, наскільки хочете. Простим рішенням для початку є збереження фіксованої кількості елементів сліду і циклічне проходження через них, переміщуючи наступний елемент у поточну позицію миші щоразу, коли відбувається подія ``mousemove``.

{{if інтерактивний

```{lang: html, test: no}
<style>
  .trail { /* назва класу для елементів сліду */
    position: absolute;
    height: 6px; width: 6px;
    border-radius: 3px;
    background: teal;
  }
  body { { height: 0; width: 0
    height: 300px;
  }
</style> </style> </style> </style> </style> </style> </style

<script>
  // Ваш код тут.
</script>
```

if}}

{{hint

{{index «слід миші (вправа)»}}

Створювати елементи найкраще за допомогою циклу. Додайте їх до документа, щоб вони з'явилися. Щоб мати доступ до них пізніше і змінювати їхнє положення, вам слід зберігати елементи у масиві.

{{index «подія переміщення миші», [масив, індексація], «оператор залишку», «оператор %»}}

Циклічно переглядати їх можна, зберігаючи змінну-лічильник ((змінна-лічильник)) і додаючи до неї 1 щоразу, коли спрацьовує подія `«mousemove»`. Оператор залишку (`% elements.length`) можна використати для отримання дійсного індексу масиву, щоб вибрати елемент, який ви хочете позиціонувати під час даної події.

{{index simulation, «requestAnimationFrame function»}}

Іншого цікавого ефекту можна досягти, моделюючи просту ((фізичну)) систему. Використовуйте подію `«mousemove»` лише для оновлення пари прив'язок, які відстежують положення миші. Потім використовуйте `requestAnimationFrame` для імітації притягування елементів, що відслідковують положення вказівника миші. На кожному кроці анімації оновлюйте їхню позицію на основі їхнього положення відносно вказівника (і, за бажанням, швидкості, яка зберігається для кожного елемента). Вирішення питання про те, як це зробити, залежить від вас.

підказка}}

### Вкладки

{{index «інтерфейс з вкладками (вправа)»}}

Панелі з вкладками є поширеним явищем у користувацьких інтерфейсах. Вони дають змогу вибрати панель інтерфейсу, обравши одну з декількох вкладок, що «стирчать» над елементом.

{{index «кнопка (тег HTML)», «відображення (CSS)», «прихований елемент», «атрибут даних»}}

Реалізуйте простий інтерфейс з вкладками. Напишіть функцію `asTabs`, яка отримує DOM-вузол і створює інтерфейс з вкладками, що показує дочірні елементи цього вузла. Вона повинна вставити список елементів `<button>` у верхній частині вузла, по одному для кожного дочірнього елемента, що містить текст, отриманий з атрибуту `data-tabname` дочірнього елемента. Усі дочірні вузли, окрім одного, слід приховати (встановити стиль відображення `display` у значення `none`). Поточний видимий вузол можна вибрати за допомогою кнопок.

Коли це спрацює, розширте його, щоб змінити стиль кнопки для поточно вибраної вкладки так, щоб було зрозуміло, яку саме вкладку вибрано.

{{якщо інтерактивно

```{lang: html, test: no}
<tab-panel>
  <div data-tabname=«one»>Вкладка один</div>
  <div data-tabname=«two»>Друга вкладка</div>
  <div data-tabname=«three»>Табуляція три</div>
</tab-panel> </tab-panel
<скрипт
  function asTabs(node) {
    // Ваш код тут.
  }
  asTabs(document.querySelector(«tab-panel»));
</script>
```

if}}

{{hint

{{індекс «текстовий вузол», «властивість childNodes», «жива структура даних», «інтерфейс з вкладками (вправа)», [пробіл, «в HTML»]}}

Однією з пасток, з якою ви можете зіткнутися, є те, що ви не можете безпосередньо використовувати властивість `childNodes` вузла як колекцію вузлів вкладок. З одного боку, коли ви додасте кнопки, вони також стануть дочірніми вузлами і опиняться у цьому об'єкті, оскільки він є живою структурою даних. З іншого боку, текстові вузли, створені для заповнення пробілів між вузлами, також знаходяться у `childNodes`, але не повинні мати власних вкладок. Ви можете використовувати `children` замість `childNodes`, щоб ігнорувати текстові вузли.

{{index «TEXT_NODE code», «nodeType property»}}

Ви можете почати зі створення масиву вкладок, щоб мати легкий доступ до них. Щоб реалізувати стилізацію кнопок, ви можете зберігати об'єкти, які містять як панель вкладок, так і їхні кнопки.

Я рекомендую написати окрему функцію для зміни вкладок. Ви можете або зберігати попередньо вибрану вкладку і змінювати лише стилі, необхідні для того, щоб приховати її і показати нову, або просто оновлювати стиль усіх вкладок щоразу, коли вибирається нова вкладка.

Можливо, ви захочете викликати цю функцію негайно, щоб інтерфейс починався з першої видимої вкладки.

підказка}}
